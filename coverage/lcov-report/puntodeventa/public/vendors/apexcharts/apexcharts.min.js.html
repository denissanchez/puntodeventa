
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for puntodeventa/public/vendors/apexcharts/apexcharts.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">puntodeventa/public/vendors/apexcharts</a> apexcharts.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/7286</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/7349</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1636</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/3</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/*!
 * ApexCharts v3.19.2
 * (c) 2018-2020 Juned Chhipa
 * Released under the MIT License.
 */
<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >"object"==typeof exports&amp;&amp;"undefined"!=typeof module?module.exports=e():"function"==typeof define&amp;&amp;define.amd?define(e):(t=t||self).ApexCharts=e()}</span>(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(){"use strict";function <span class="fstat-no" title="function not covered" >t(</span>e){<span class="cstat-no" title="statement not covered" >return(t="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return typeof t}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>)(e)}</span>function <span class="fstat-no" title="function not covered" >e(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!(t instanceof e))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span></span>function <span class="fstat-no" title="function not covered" >i(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++){var a=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(t,a.key,a)}</span>}</span>function <span class="fstat-no" title="function not covered" >a(</span>t,e,a){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;i(t.prototype,e),a&amp;&amp;i(t,a),t}</span>function <span class="fstat-no" title="function not covered" >s(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,e){var i=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>if(Object.getOwnPropertySymbols){var a=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertySymbols(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(a=a.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(t,e).enumerable}</span>))),i.push.apply(i,a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >n(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var i=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?arguments[e]:{};<span class="cstat-no" title="statement not covered" ></span>e%2?r(Object(i),!0).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s(t,e,i[e])}</span>)):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >o(</span>t,e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof e&amp;&amp;null!==e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Super expression must either be null or a function");<span class="cstat-no" title="statement not covered" >t</span></span>.prototype=Object.create(e&amp;&amp;e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&amp;&amp;h(t,e)}</span>function <span class="fstat-no" title="function not covered" >l(</span>t){<span class="cstat-no" title="statement not covered" >return(l=Object.setPrototypeOf?Object.getPrototypeOf:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.__proto__||Object.getPrototypeOf(t)}</span>)(t)}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,e){<span class="cstat-no" title="statement not covered" >return(h=Object.setPrototypeOf||<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.__proto__=e,t}</span>)(t,e)}</span>function <span class="fstat-no" title="function not covered" >c(</span>t,e){<span class="cstat-no" title="statement not covered" >return!e||"object"!=typeof e&amp;&amp;"function"!=typeof e?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(void 0===t)<span class="cstat-no" title="statement not covered" >throw new ReferenceError("this hasn't been initialised - super() hasn't been called");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>(t):e}</span>function <span class="fstat-no" title="function not covered" >d(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >new Array(t.length);</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >i[e]=t[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>}</span>(t)||<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))<span class="cstat-no" title="statement not covered" >return Array.from(t)}</span></span>(t)||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to spread non-iterable instance")}</span>()}</span>var g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >i(</span>){<span class="cstat-no" title="statement not covered" >e(this,i)}<span class="cstat-no" title="statement not covered" ></span>return a(i,[{key:"shadeRGBColor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >e.split(","),</span>a=<span class="cstat-no" title="statement not covered" >t&lt;0?0:255,</span>s=<span class="cstat-no" title="statement not covered" >t&lt;0?-1*t:t,</span>r=<span class="cstat-no" title="statement not covered" >parseInt(i[0].slice(4),10),</span>n=<span class="cstat-no" title="statement not covered" >parseInt(i[1],10),</span>o=<span class="cstat-no" title="statement not covered" >parseInt(i[2],10);<span class="cstat-no" title="statement not covered" ></span>return"rgb("+(Math.round((a-r)*s)+r)+","+(Math.round((a-n)*s)+n)+","+(Math.round((a-o)*s)+o)+")"}</span>},{key:"shadeHexColor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >parseInt(e.slice(1),16),</span>a=<span class="cstat-no" title="statement not covered" >t&lt;0?0:255,</span>s=<span class="cstat-no" title="statement not covered" >t&lt;0?-1*t:t,</span>r=<span class="cstat-no" title="statement not covered" >i&gt;&gt;16,</span>n=<span class="cstat-no" title="statement not covered" >i&gt;&gt;8&amp;255,</span>o=<span class="cstat-no" title="statement not covered" >255&amp;i;<span class="cstat-no" title="statement not covered" ></span>return"#"+(16777216+65536*(Math.round((a-r)*s)+r)+256*(Math.round((a-n)*s)+n)+(Math.round((a-o)*s)+o)).toString(16).slice(1)}</span>},{key:"shadeColor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return i.isColorHex(e)?this.shadeHexColor(t,e):this.shadeRGBColor(t,e)}</span>}],[{key:"bind",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.apply(e,arguments)}</span>}</span>},{key:"isObject",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"object"===t(e)&amp;&amp;!Array.isArray(e)&amp;&amp;null!=e}</span>},{key:"listToArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(e=0;e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >i[e]=t[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>},{key:"extend",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>"function"!=typeof Object.assign&amp;&amp;(Object.assign=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(null==t)<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot convert undefined or null to object");<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >Object(t),</span>i=<span class="cstat-no" title="statement not covered" >1;</span>i&lt;arguments.length;i++){var a=<span class="cstat-no" title="statement not covered" >arguments[i];<span class="cstat-no" title="statement not covered" ></span>if(null!=a)<span class="cstat-no" title="statement not covered" >for(var s in a)<span class="cstat-no" title="statement not covered" >a.hasOwnProperty(s)&amp;&amp;(e[s]=a[s])}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn e}</span>);v</span>ar a=<span class="cstat-no" title="statement not covered" >Object.assign({},t);<span class="cstat-no" title="statement not covered" ></span>return this.isObject(t)&amp;&amp;this.isObject(e)&amp;&amp;Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >i.isObject(e[r])&amp;&amp;r in t?a[r]=i.extend(t[r],e[r]):Object.assign(a,s({},r,e[r]))}</span>)),a}</span>},{key:"extendArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.push(i.extend(e,t))}</span>)),t=a}</span>},{key:"monthMod",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t%12}</span>},{key:"clone",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("[object Array]"===Object.prototype.toString.call(e)){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;e.length;a++)<span class="cstat-no" title="statement not covered" >i[a]=this.clone(e[a]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>i</span>f("[object Null]"===Object.prototype.toString.call(e))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f("object"===t(e)){var s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var r in e)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(r)&amp;&amp;(s[r]=this.clone(e[r]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>},{key:"log10",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Math.log(t)/Math.LN10}</span>},{key:"roundToBase10",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Math.pow(10,Math.floor(Math.log10(t)))}</span>},{key:"roundToBase",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Math.pow(e,Math.floor(Math.log(t)/Math.log(e)))}</span>},{key:"parseNumber",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null===t?t:parseFloat(t)}</span>},{key:"randomId",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(Math.random()+1).toString(36).substring(4)}</span>},{key:"noExponents",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >String(t).split(/[eE]/);<span class="cstat-no" title="statement not covered" ></span>if(1===e.length)<span class="cstat-no" title="statement not covered" >return e[0];v</span></span>ar i=<span class="cstat-no" title="statement not covered" >"",</span>a=<span class="cstat-no" title="statement not covered" >t&lt;0?"-":"",</span>s=<span class="cstat-no" title="statement not covered" >e[0].replace(".",""),</span>r=<span class="cstat-no" title="statement not covered" >Number(e[1])+1;<span class="cstat-no" title="statement not covered" ></span>if(r&lt;0){<span class="cstat-no" title="statement not covered" >for(i=a+"0.";r++;)<span class="cstat-no" title="statement not covered" >i+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn i+s.replace(/^-/,"")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r-=s.length;r--;)<span class="cstat-no" title="statement not covered" >i+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn s+i}</span>},{key:"getDimensions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >getComputedStyle(t),</span>i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >t.clientHeight,</span>s=<span class="cstat-no" title="statement not covered" >t.clientWidth;<span class="cstat-no" title="statement not covered" ></span>return a-=parseFloat(e.paddingTop)+parseFloat(e.paddingBottom),s-=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight),i.push(s),i.push(a),i}</span>},{key:"getBoundingClientRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>return{top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:t.clientWidth,height:t.clientHeight,x:e.left,y:e.top}}</span>},{key:"getLargestStringFromArr",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)&amp;&amp;(e=e.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.length&gt;e.length?t:e}</span>))),t.length&gt;e.length?t:e}</span>),0)}</span>},{key:"hexToRgba",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:"#999999",</span>e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:.6;<span class="cstat-no" title="statement not covered" ></span>"#"!==t.substring(0,1)&amp;&amp;(t="#999999");v</span>ar i=<span class="cstat-no" title="statement not covered" >t.replace("#","");<span class="cstat-no" title="statement not covered" ></span>i=i.match(new RegExp("(.{"+i.length/3+"})","g"));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++)<span class="cstat-no" title="statement not covered" >i[a]=parseInt(1===i[a].length?i[a]+i[a]:i[a],16);<span class="cstat-no" title="statement not covered" >r</span></span>eturn void 0!==e&amp;&amp;i.push(e),"rgba("+i.join(",")+")"}</span>},{key:"getOpacityFromRGBA",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseFloat(t.replace(/^.*,(.+)\)/,"$1"))}</span>},{key:"rgb2hex",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(t=t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))&amp;&amp;4===t.length?"#"+("0"+parseInt(t[1],10).toString(16)).slice(-2)+("0"+parseInt(t[2],10).toString(16)).slice(-2)+("0"+parseInt(t[3],10).toString(16)).slice(-2):""}</span>},{key:"isColorHex",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)}</span>},{key:"polarToCartesian",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >(a-90)*Math.PI/180;<span class="cstat-no" title="statement not covered" ></span>return{x:t+i*Math.cos(s),y:e+i*Math.sin(s)}}</span>},{key:"escapeString",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:"x",</span>i=<span class="cstat-no" title="statement not covered" >t.toString().slice();<span class="cstat-no" title="statement not covered" ></span>return i=i.replace(/[` ~!@#$%^&amp;*()_|+\-=?;:'",.&lt;&gt;{}[\]\\/]/gi,e)}</span>},{key:"negToZero",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:t}</span>},{key:"moveIndexInArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(i&gt;=t.length)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >i-t.length+1;</span>a--;)<span class="cstat-no" title="statement not covered" >t.push(void 0);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.splice(i,0,t.splice(e,1)[0]),t}</span>},{key:"extractNumber",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseFloat(t.replace(/[^\d.]*/g,""))}</span>},{key:"findAncestor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(;(t=t.parentElement)&amp;&amp;!t.classList.contains(e););<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>},{key:"setELstyles",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i in e)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(i)&amp;&amp;(t.style.key=e[i])}</span></span>},{key:"isNumber",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!isNaN(t)&amp;&amp;parseFloat(Number(t))===t&amp;&amp;!isNaN(parseInt(t,10))}</span>},{key:"isFloat",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Number(t)===t&amp;&amp;t%1!=0}</span>},{key:"isSafari",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return/^((?!chrome|android).)*safari/i.test(navigator.userAgent)}</span>},{key:"isFirefox",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return navigator.userAgent.toLowerCase().indexOf("firefox")&gt;-1}</span>},{key:"isIE11",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(-1!==window.navigator.userAgent.indexOf("MSIE")||window.navigator.appVersion.indexOf("Trident/")&gt;-1)<span class="cstat-no" title="statement not covered" >return!0}</span></span>},{key:"isIE",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >window.navigator.userAgent,</span>e=<span class="cstat-no" title="statement not covered" >t.indexOf("MSIE ");<span class="cstat-no" title="statement not covered" ></span>if(e&gt;0)<span class="cstat-no" title="statement not covered" >return parseInt(t.substring(e+5,t.indexOf(".",e)),10);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.indexOf("Trident/")&gt;0){var i=<span class="cstat-no" title="statement not covered" >t.indexOf("rv:");<span class="cstat-no" title="statement not covered" ></span>return parseInt(t.substring(i+3,t.indexOf(".",i)),10)}</span>v</span>ar a=<span class="cstat-no" title="statement not covered" >t.indexOf("Edge/");<span class="cstat-no" title="statement not covered" ></span>return a&gt;0&amp;&amp;parseInt(t.substring(a+5,t.indexOf(".",a)),10)}</span>}]),i}</span>(),</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getDefaultFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>t.unfilter(!0),(new window.SVG.Filter).size("120%","180%","-5%","-40%"),"none"!==i.config.states.normal.filter?this.applyFilter(t,e,i.config.states.normal.filter.type,i.config.states.normal.filter.value):i.config.chart.dropShadow.enabled&amp;&amp;this.dropShadow(t,i.config.chart.dropShadow,e)}</span>},{key:"addNormalFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>i.config.chart.dropShadow.enabled&amp;&amp;!t.node.classList.contains("apexcharts-marker")&amp;&amp;this.dropShadow(t,i.config.chart.dropShadow,e)}</span>},{key:"addLightenFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >i.intensity;<span class="cstat-no" title="statement not covered" ></span>if(!g.isFirefox()){<span class="cstat-no" title="statement not covered" >t.unfilter(!0);<span class="cstat-no" title="statement not covered" >n</span>ew window.SVG.Filter;<span class="cstat-no" title="statement not covered" >t</span>.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >s.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>(i.enabled?a.addShadow(t,e,i):t).componentTransfer({rgb:{type:"linear",slope:1.5,intercept:r}})}</span>)),t.filterer.node.setAttribute("filterUnits","userSpaceOnUse"),this._scaleFilterSize(t.filterer.node)}</span>}</span>},{key:"addDarkenFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >i.intensity;<span class="cstat-no" title="statement not covered" ></span>if(!g.isFirefox()){<span class="cstat-no" title="statement not covered" >t.unfilter(!0);<span class="cstat-no" title="statement not covered" >n</span>ew window.SVG.Filter;<span class="cstat-no" title="statement not covered" >t</span>.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >s.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>(i.enabled?a.addShadow(t,e,i):t).componentTransfer({rgb:{type:"linear",slope:r}})}</span>)),t.filterer.node.setAttribute("filterUnits","userSpaceOnUse"),this._scaleFilterSize(t.filterer.node)}</span>}</span>},{key:"applyFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:.5;<span class="cstat-no" title="statement not covered" ></span>switch(i){case"none":<span class="cstat-no" title="statement not covered" >this.addNormalFilter(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"lighten":<span class="cstat-no" title="statement not covered" >this.addLightenFilter(t,e,{intensity:a});<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"darken":<span class="cstat-no" title="statement not covered" >this.addDarkenFilter(t,e,{intensity:a})}</span>}</span>},{key:"addShadow",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >i.blur,</span>s=<span class="cstat-no" title="statement not covered" >i.top,</span>r=<span class="cstat-no" title="statement not covered" >i.left,</span>n=<span class="cstat-no" title="statement not covered" >i.color,</span>o=<span class="cstat-no" title="statement not covered" >i.opacity,</span>l=<span class="cstat-no" title="statement not covered" >t.flood(Array.isArray(n)?n[e]:n,o).composite(t.sourceAlpha,"in").offset(r,s).gaussianBlur(a).merge(t.source);<span class="cstat-no" title="statement not covered" ></span>return t.blend(t.source,l)}</span>},{key:"dropShadow",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0,</span>a=<span class="cstat-no" title="statement not covered" >e.top,</span>s=<span class="cstat-no" title="statement not covered" >e.left,</span>r=<span class="cstat-no" title="statement not covered" >e.blur,</span>n=<span class="cstat-no" title="statement not covered" >e.color,</span>o=<span class="cstat-no" title="statement not covered" >e.opacity,</span>l=<span class="cstat-no" title="statement not covered" >e.noUserSpaceOnUse,</span>h=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return t.unfilter(!0),g.isIE()&amp;&amp;"radialBar"===h.config.chart.type?t:(n=Array.isArray(n)?n[i]:n,t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>e=g.isSafari()||g.isFirefox()||g.isIE()?t.flood(n,o).composite(t.sourceAlpha,"in").offset(s,a).gaussianBlur(r):t.flood(n,o).composite(t.sourceAlpha,"in").offset(s,a).gaussianBlur(r).merge(t.source),t.blend(t.source,e)}</span>)),l||t.filterer.node.setAttribute("filterUnits","userSpaceOnUse"),this._scaleFilterSize(t.filterer.node),t)}</span>},{key:"setSelectionFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==a.globals.selectedDataPoints[e]&amp;&amp;a.globals.selectedDataPoints[e].indexOf(i)&gt;-1){<span class="cstat-no" title="statement not covered" >t.node.setAttribute("selected",!0);v</span>ar s=<span class="cstat-no" title="statement not covered" >a.config.states.active.filter;<span class="cstat-no" title="statement not covered" ></span>"none"!==s&amp;&amp;this.applyFilter(t,e,s.type,s.value)}</span>}</span>},{key:"_scaleFilterSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var i in e)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(i)&amp;&amp;t.setAttribute(i,e[i])}</span></span>({width:"200%",height:"200%",x:"-50%",y:"-50%"})}</span>}]),t}</span>(),</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.setEasingFunctions()}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"setEasingFunctions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >if(!this.w.globals.easing){<span class="cstat-no" title="statement not covered" >switch(this.w.config.chart.animations.easing){case"linear":<span class="cstat-no" title="statement not covered" >t="-";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"easein":<span class="cstat-no" title="statement not covered" >t="&lt;";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"easeout":<span class="cstat-no" title="statement not covered" >t="&gt;";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"easeinout":<span class="cstat-no" title="statement not covered" >t="&lt;&gt;";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"swing":<span class="cstat-no" title="statement not covered" >t=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t-=1)*t*((e+1)*t+e)+1}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bounce":<span class="cstat-no" title="statement not covered" >t=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&lt;1/2.75?7.5625*t*t:t&lt;2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t&lt;2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"elastic":<span class="cstat-no" title="statement not covered" >t=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t===!!t?t:Math.pow(2,-10*t)*Math.sin((t-.075)*(2*Math.PI)/.3)+1}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >t="&lt;&gt;"}<span class="cstat-no" title="statement not covered" ></span>t</span>his.w.globals.easing=t}</span>}</span>},{key:"animateLine",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >t.attr(e).animate(a).attr(i)}</span>},{key:"animateCircleRadius",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r){<span class="cstat-no" title="statement not covered" >e||(e=0),t.attr({r:e}).animate(a,s).attr({r:i}).afterAll((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r()}</span>))}</span>},{key:"animateCircle",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >t.attr({r:e.r,cx:e.cx,cy:e.cy}).animate(a,s).attr({r:i.r,cx:i.cx,cy:i.cy})}</span>},{key:"animateRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >t.attr(e).animate(a).attr(i).afterAll((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s()}</span>))}</span>},{key:"animatePathsGradually",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.el,</span>i=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>a=<span class="cstat-no" title="statement not covered" >t.j,</span>s=<span class="cstat-no" title="statement not covered" >t.fill,</span>r=<span class="cstat-no" title="statement not covered" >t.pathFrom,</span>n=<span class="cstat-no" title="statement not covered" >t.pathTo,</span>o=<span class="cstat-no" title="statement not covered" >t.speed,</span>l=<span class="cstat-no" title="statement not covered" >t.delay,</span>h=<span class="cstat-no" title="statement not covered" >this.w,</span>c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>h.config.chart.animations.animateGradually.enabled&amp;&amp;(c=h.config.chart.animations.animateGradually.delay),h.config.chart.animations.dynamicAnimation.enabled&amp;&amp;h.globals.dataChanged&amp;&amp;"bar"!==h.config.chart.type&amp;&amp;(c=0),this.morphSVG(e,i,a,"line"!==h.config.chart.type||h.globals.comboCharts?s:"stroke",r,n,o,l*c)}</span>},{key:"showDelayedElements",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.w.globals.delayedElements.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.el.classList.remove("apexcharts-element-hidden")}</span>))}</span>},{key:"animationCompleted",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>e.globals.animationEnded||(e.globals.animationEnded=!0,this.showDelayedElements(),"function"==typeof e.config.chart.events.animationEnd&amp;&amp;e.config.chart.events.animationEnd(this.ctx,{el:t,w:e}))}</span>},{key:"morphSVG",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r,n,o){var l=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>s||(s=t.attr("pathFrom")),r||(r=t.attr("pathTo"));v</span>ar c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"radar"===h.config.chart.type&amp;&amp;(n=1),"M 0 ".concat(h.globals.gridHeight)}</span>;<span class="cstat-no" title="statement not covered" ></span>(!s||s.indexOf("undefined")&gt;-1||s.indexOf("NaN")&gt;-1)&amp;&amp;(s=c()),(r.indexOf("undefined")&gt;-1||r.indexOf("NaN")&gt;-1)&amp;&amp;(r=c()),h.globals.shouldAnimate||(n=1),t.plot(s).animate(1,h.globals.easing,o).plot(s).animate(n,h.globals.easing,o).plot(r).afterAll((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >g.isNumber(i)?i===h.globals.series[h.globals.maxValsInArrayIndex].length-2&amp;&amp;h.globals.shouldAnimate&amp;&amp;l.animationCompleted(t):"none"!==a&amp;&amp;h.globals.shouldAnimate&amp;&amp;(!h.globals.comboCharts&amp;&amp;e===h.globals.series.length-1||h.globals.comboCharts)&amp;&amp;l.animationCompleted(t),l.showDelayedElements()}</span>))}</span>}]),t}</span>(),</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawLine",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:"#a8a8a8",</span>r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;5&amp;&amp;void 0!==arguments[5]?arguments[5]:0,</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;6&amp;&amp;void 0!==arguments[6]?arguments[6]:null,</span>o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >o.globals.dom.Paper.line().attr({x1:t,y1:e,x2:i,y2:a,stroke:s,"stroke-dasharray":r,"stroke-width":n});<span class="cstat-no" title="statement not covered" ></span>return l}</span>},{key:"drawRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:0,</span>e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0,</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:0,</span>s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:0,</span>r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;5&amp;&amp;void 0!==arguments[5]?arguments[5]:"#fefefe",</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;6&amp;&amp;void 0!==arguments[6]?arguments[6]:1,</span>o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;7&amp;&amp;void 0!==arguments[7]?arguments[7]:null,</span>l=<span class="cstat-no" title="statement not covered" >arguments.length&gt;8&amp;&amp;void 0!==arguments[8]?arguments[8]:null,</span>h=<span class="cstat-no" title="statement not covered" >arguments.length&gt;9&amp;&amp;void 0!==arguments[9]?arguments[9]:0,</span>c=<span class="cstat-no" title="statement not covered" >this.w,</span>d=<span class="cstat-no" title="statement not covered" >c.globals.dom.Paper.rect();<span class="cstat-no" title="statement not covered" ></span>return d.attr({x:t,y:e,width:i&gt;0?i:0,height:a&gt;0?a:0,rx:s,ry:s,opacity:n,"stroke-width":null!==o?o:0,stroke:null!==l?l:"none","stroke-dasharray":h}),d.node.setAttribute("fill",r),d}</span>},{key:"drawPolygon",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:"#e1e1e1",</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:1,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:"none",</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >s.globals.dom.Paper.polygon(t).attr({fill:a,stroke:e,"stroke-width":i});<span class="cstat-no" title="statement not covered" ></span>return r}</span>},{key:"drawCircle",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:null,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals.dom.Paper.circle(2*t);<span class="cstat-no" title="statement not covered" ></span>return null!==e&amp;&amp;a.attr(e),a}</span>},{key:"drawPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.d,</span>i=<span class="cstat-no" title="statement not covered" >void 0===e?"":e,</span>a=<span class="cstat-no" title="statement not covered" >t.stroke,</span>s=<span class="cstat-no" title="statement not covered" >void 0===a?"#a8a8a8":a,</span>r=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>n=<span class="cstat-no" title="statement not covered" >void 0===r?1:r,</span>o=<span class="cstat-no" title="statement not covered" >t.fill,</span>l=<span class="cstat-no" title="statement not covered" >t.fillOpacity,</span>h=<span class="cstat-no" title="statement not covered" >void 0===l?1:l,</span>c=<span class="cstat-no" title="statement not covered" >t.strokeOpacity,</span>d=<span class="cstat-no" title="statement not covered" >void 0===c?1:c,</span>g=<span class="cstat-no" title="statement not covered" >t.classes,</span>u=<span class="cstat-no" title="statement not covered" >t.strokeLinecap,</span>f=<span class="cstat-no" title="statement not covered" >void 0===u?null:u,</span>p=<span class="cstat-no" title="statement not covered" >t.strokeDashArray,</span>x=<span class="cstat-no" title="statement not covered" >void 0===p?0:p,</span>b=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return null===f&amp;&amp;(f=b.config.stroke.lineCap),(i.indexOf("undefined")&gt;-1||i.indexOf("NaN")&gt;-1)&amp;&amp;(i="M 0 ".concat(b.globals.gridHeight)),b.globals.dom.Paper.path(i).attr({fill:o,"fill-opacity":h,stroke:s,"stroke-opacity":d,"stroke-linecap":f,"stroke-width":n,"stroke-dasharray":x,class:g})}</span>},{key:"group",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:null,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals.dom.Paper.group();<span class="cstat-no" title="statement not covered" ></span>return null!==t&amp;&amp;i.attr(t),i}</span>},{key:"move",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >["M",t,e].join(" ");<span class="cstat-no" title="statement not covered" ></span>return i}</span>},{key:"line",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:null,</span>a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return null===i?a=["L",t,e].join(" "):"H"===i?a=["H",t].join(" "):"V"===i&amp;&amp;(a=["V",e].join(" ")),a}</span>},{key:"curve",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r){var n=<span class="cstat-no" title="statement not covered" >["C",t,e,i,a,s,r].join(" ");<span class="cstat-no" title="statement not covered" ></span>return n}</span>},{key:"quadraticCurve",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >return["Q",t,e,i,a].join(" ")}</span>},{key:"arc",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r,n){var o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;7&amp;&amp;void 0!==arguments[7]&amp;&amp;arguments[7],</span>l=<span class="cstat-no" title="statement not covered" >"A";<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(l="a");v</span>ar h=<span class="cstat-no" title="statement not covered" >[l,t,e,i,a,s,r,n].join(" ");<span class="cstat-no" title="statement not covered" ></span>return h}</span>},{key:"renderPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >t.j,</span>a=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>s=<span class="cstat-no" title="statement not covered" >t.pathFrom,</span>r=<span class="cstat-no" title="statement not covered" >t.pathTo,</span>o=<span class="cstat-no" title="statement not covered" >t.stroke,</span>l=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>h=<span class="cstat-no" title="statement not covered" >t.strokeLinecap,</span>c=<span class="cstat-no" title="statement not covered" >t.fill,</span>d=<span class="cstat-no" title="statement not covered" >t.animationDelay,</span>g=<span class="cstat-no" title="statement not covered" >t.initialSpeed,</span>p=<span class="cstat-no" title="statement not covered" >t.dataChangeSpeed,</span>x=<span class="cstat-no" title="statement not covered" >t.className,</span>b=<span class="cstat-no" title="statement not covered" >t.shouldClipToGrid,</span>m=<span class="cstat-no" title="statement not covered" >void 0===b||b,</span>v=<span class="cstat-no" title="statement not covered" >t.bindEventsOnPaths,</span>y=<span class="cstat-no" title="statement not covered" >void 0===v||v,</span>w=<span class="cstat-no" title="statement not covered" >t.drawShadow,</span>k=<span class="cstat-no" title="statement not covered" >void 0===w||w,</span>A=<span class="cstat-no" title="statement not covered" >this.w,</span>S=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>C=<span class="cstat-no" title="statement not covered" >new f(this.ctx),</span>L=<span class="cstat-no" title="statement not covered" >this.w.config.chart.animations.enabled,</span>P=<span class="cstat-no" title="statement not covered" >L&amp;&amp;this.w.config.chart.animations.dynamicAnimation.enabled,</span>T=<span class="cstat-no" title="statement not covered" >!!(L&amp;&amp;!A.globals.resized||P&amp;&amp;A.globals.dataChanged&amp;&amp;A.globals.shouldAnimate);<span class="cstat-no" title="statement not covered" ></span>T?e=s:(e=r,A.globals.animationEnded=!0);v</span>ar z=<span class="cstat-no" title="statement not covered" >A.config.stroke.dashArray,</span>I=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>I=Array.isArray(z)?z[a]:A.config.stroke.dashArray;v</span>ar M=<span class="cstat-no" title="statement not covered" >this.drawPath({d:e,stroke:o,strokeWidth:l,fill:c,fillOpacity:1,classes:x,strokeLinecap:h,strokeDashArray:I});<span class="cstat-no" title="statement not covered" ></span>if(M.attr("index",a),m&amp;&amp;M.attr({"clip-path":"url(#gridRectMask".concat(A.globals.cuid,")")}),"none"!==A.config.states.normal.filter.type)<span class="cstat-no" title="statement not covered" >S.getDefaultFilter(M,a);e</span>lse <span class="cstat-no" title="statement not covered" >if(A.config.chart.dropShadow.enabled&amp;&amp;k&amp;&amp;(!A.config.chart.dropShadow.enabledOnSeries||A.config.chart.dropShadow.enabledOnSeries&amp;&amp;-1!==A.config.chart.dropShadow.enabledOnSeries.indexOf(a))){var E=<span class="cstat-no" title="statement not covered" >A.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>S.dropShadow(M,E,a)}<span class="cstat-no" title="statement not covered" ></span>y</span></span>&amp;&amp;(M.node.addEventListener("mouseenter",this.pathMouseEnter.bind(this,M)),M.node.addEventListener("mouseleave",this.pathMouseLeave.bind(this,M)),M.node.addEventListener("mousedown",this.pathMouseDown.bind(this,M))),M.attr({pathTo:r,pathFrom:s});v</span>ar X=<span class="cstat-no" title="statement not covered" >{el:M,j:i,realIndex:a,pathFrom:s,pathTo:r,fill:c,strokeWidth:l,delay:d};<span class="cstat-no" title="statement not covered" ></span>return!L||A.globals.resized||A.globals.dataChanged?!A.globals.resized&amp;&amp;A.globals.dataChanged||C.showDelayedElements():C.animatePathsGradually(n({},X,{speed:g})),A.globals.dataChanged&amp;&amp;P&amp;&amp;T&amp;&amp;C.animatePathsGradually(n({},X,{speed:p})),M}</span>},{key:"drawPattern",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:"#a8a8a8",</span>s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:0,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >r.globals.dom.Paper.pattern(e,i,(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >"horizontalLines"===t?r.line(0,0,i,0).stroke({color:a,width:s+1}):"verticalLines"===t?r.line(0,0,0,e).stroke({color:a,width:s+1}):"slantedLines"===t?r.line(0,0,e,i).stroke({color:a,width:s}):"squares"===t?r.rect(e,i).fill("none").stroke({color:a,width:s}):"circles"===t&amp;&amp;r.circle(e).fill("none").stroke({color:a,width:s})}</span>));<span class="cstat-no" title="statement not covered" ></span>return n}</span>},{key:"drawGradient",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){var r,n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;5&amp;&amp;void 0!==arguments[5]?arguments[5]:null,</span>o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;6&amp;&amp;void 0!==arguments[6]?arguments[6]:null,</span>l=<span class="cstat-no" title="statement not covered" >arguments.length&gt;7&amp;&amp;void 0!==arguments[7]?arguments[7]:null,</span>h=<span class="cstat-no" title="statement not covered" >arguments.length&gt;8&amp;&amp;void 0!==arguments[8]?arguments[8]:0,</span>c=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>e.length&lt;9&amp;&amp;0===e.indexOf("#")&amp;&amp;(e=g.hexToRgba(e,a)),i.length&lt;9&amp;&amp;0===i.indexOf("#")&amp;&amp;(i=g.hexToRgba(i,s));v</span>ar d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >1,</span>f=<span class="cstat-no" title="statement not covered" >1,</span>p=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>null!==o&amp;&amp;(d=void 0!==o[0]?o[0]/100:0,u=void 0!==o[1]?o[1]/100:1,f=void 0!==o[2]?o[2]/100:1,p=void 0!==o[3]?o[3]/100:null);v</span>ar x=<span class="cstat-no" title="statement not covered" >!("donut"!==c.config.chart.type&amp;&amp;"pie"!==c.config.chart.type&amp;&amp;"polarArea"!==c.config.chart.type&amp;&amp;"bubble"!==c.config.chart.type);<span class="cstat-no" title="statement not covered" ></span>if(r=null===l||0===l.length?c.globals.dom.Paper.gradient(x?"radial":"linear",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.at(d,e,a),t.at(u,i,s),t.at(f,i,s),null!==p&amp;&amp;t.at(p,e,a)}</span>)):c.globals.dom.Paper.gradient(x?"radial":"linear",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >(Array.isArray(l[h])?l[h]:l).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.at(e.offset/100,e.color,e.opacity)}</span>))}</span>)),x){var b=<span class="cstat-no" title="statement not covered" >c.globals.gridWidth/2,</span>m=<span class="cstat-no" title="statement not covered" >c.globals.gridHeight/2;<span class="cstat-no" title="statement not covered" ></span>"bubble"!==c.config.chart.type?r.attr({gradientUnits:"userSpaceOnUse",cx:b,cy:m,r:n}):r.attr({cx:.5,cy:.5,r:.8,fx:.2,fy:.2})}</span>else<span class="cstat-no" title="statement not covered" >"vertical"===t?r.from(0,0).to(0,1):"diagonal"===t?r.from(0,0).to(1,1):"horizontal"===t?r.from(0,1).to(1,1):"diagonal2"===t&amp;&amp;r.from(1,0).to(0,1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>},{key:"drawText",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=<span class="cstat-no" title="statement not covered" >t.y,</span>s=<span class="cstat-no" title="statement not covered" >t.text,</span>r=<span class="cstat-no" title="statement not covered" >t.textAnchor,</span>n=<span class="cstat-no" title="statement not covered" >t.fontSize,</span>o=<span class="cstat-no" title="statement not covered" >t.fontFamily,</span>l=<span class="cstat-no" title="statement not covered" >t.fontWeight,</span>h=<span class="cstat-no" title="statement not covered" >t.foreColor,</span>c=<span class="cstat-no" title="statement not covered" >t.opacity,</span>d=<span class="cstat-no" title="statement not covered" >t.cssClass,</span>g=<span class="cstat-no" title="statement not covered" >void 0===d?"":d,</span>u=<span class="cstat-no" title="statement not covered" >t.isPlainText,</span>f=<span class="cstat-no" title="statement not covered" >void 0===u||u,</span>p=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return void 0===s&amp;&amp;(s=""),r||(r="start"),h&amp;&amp;h.length||(h=p.config.chart.foreColor),o=o||p.config.chart.fontFamily,l=l||"regular",(e=Array.isArray(s)?p.globals.dom.Paper.text((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;s.length;e++)<span class="cstat-no" title="statement not covered" >0===e?t.tspan(s[e]):t.tspan(s[e]).newLine()}</span></span>)):f?p.globals.dom.Paper.plain(s):p.globals.dom.Paper.text((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.tspan(s)}</span>))).attr({x:i,y:a,"text-anchor":r,"dominant-baseline":"auto","font-size":n,"font-family":o,"font-weight":l,fill:h,class:"apexcharts-text "+g}),e.node.style.fontFamily=o,e.node.style.opacity=c,e}</span>},{key:"drawMarker",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t=t||0;v</span>ar a=<span class="cstat-no" title="statement not covered" >i.pSize||0,</span>s=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if("square"===i.shape){var r=<span class="cstat-no" title="statement not covered" >void 0===i.pRadius?a/2:i.pRadius;<span class="cstat-no" title="statement not covered" ></span>null!==e&amp;&amp;a||(a=0,r=0);v</span>ar n=<span class="cstat-no" title="statement not covered" >1.2*a+r,</span>o=<span class="cstat-no" title="statement not covered" >this.drawRect(n,n,n,n,r);<span class="cstat-no" title="statement not covered" ></span>o.attr({x:t-n/2,y:e-n/2,cx:t,cy:e,class:i.class?i.class:"",fill:i.pointFillColor,"fill-opacity":i.pointFillOpacity?i.pointFillOpacity:1,stroke:i.pointStrokeColor,"stroke-width":i.pWidth?i.pWidth:0,"stroke-opacity":i.pointStrokeOpacity?i.pointStrokeOpacity:1}),s=o}</span>else<span class="cstat-no" title="statement not covered" >"circle"!==i.shape&amp;&amp;i.shape||(g.isNumber(e)||(a=0,e=0),s=this.drawCircle(a,{cx:t,cy:e,class:i.class?i.class:"",stroke:i.pointStrokeColor,fill:i.pointFillColor,"fill-opacity":i.pointFillOpacity?i.pointFillOpacity:1,"stroke-width":i.pWidth?i.pWidth:0,"stroke-opacity":i.pointStrokeOpacity?i.pointStrokeOpacity:1}));<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>},{key:"pathMouseEnter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >parseInt(t.node.getAttribute("index"),10),</span>r=<span class="cstat-no" title="statement not covered" >parseInt(t.node.getAttribute("j"),10);<span class="cstat-no" title="statement not covered" ></span>if("function"==typeof i.config.chart.events.dataPointMouseEnter&amp;&amp;i.config.chart.events.dataPointMouseEnter(e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}),this.ctx.events.fireEvent("dataPointMouseEnter",[e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}]),("none"===i.config.states.active.filter.type||"true"!==t.node.getAttribute("selected"))&amp;&amp;"none"!==i.config.states.hover.filter.type&amp;&amp;"none"!==i.config.states.active.filter.type&amp;&amp;!i.globals.isTouchDevice){var n=<span class="cstat-no" title="statement not covered" >i.config.states.hover.filter;<span class="cstat-no" title="statement not covered" ></span>a.applyFilter(t,s,n.type,n.value)}</span>}</span>},{key:"pathMouseLeave",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >parseInt(t.node.getAttribute("index"),10),</span>r=<span class="cstat-no" title="statement not covered" >parseInt(t.node.getAttribute("j"),10);<span class="cstat-no" title="statement not covered" ></span>"function"==typeof i.config.chart.events.dataPointMouseLeave&amp;&amp;i.config.chart.events.dataPointMouseLeave(e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}),this.ctx.events.fireEvent("dataPointMouseLeave",[e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}]),"none"!==i.config.states.active.filter.type&amp;&amp;"true"===t.node.getAttribute("selected")||"none"!==i.config.states.hover.filter.type&amp;&amp;a.getDefaultFilter(t,s)}</span>},{key:"pathMouseDown",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >parseInt(t.node.getAttribute("index"),10),</span>r=<span class="cstat-no" title="statement not covered" >parseInt(t.node.getAttribute("j"),10),</span>n=<span class="cstat-no" title="statement not covered" >"false";<span class="cstat-no" title="statement not covered" ></span>if("true"===t.node.getAttribute("selected")){<span class="cstat-no" title="statement not covered" >if(t.node.setAttribute("selected","false"),i.globals.selectedDataPoints[s].indexOf(r)&gt;-1){var o=<span class="cstat-no" title="statement not covered" >i.globals.selectedDataPoints[s].indexOf(r);<span class="cstat-no" title="statement not covered" ></span>i.globals.selectedDataPoints[s].splice(o,1)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!i.config.states.active.allowMultipleDataPointsSelection&amp;&amp;i.globals.selectedDataPoints.length&gt;0){<span class="cstat-no" title="statement not covered" >i.globals.selectedDataPoints=[];v</span>ar l=<span class="cstat-no" title="statement not covered" >i.globals.dom.Paper.select(".apexcharts-series path").members,</span>h=<span class="cstat-no" title="statement not covered" >i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >Array.prototype.forEach.call(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.node.setAttribute("selected","false"),a.getDefaultFilter(t,s)}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>c(l),c(h)}<span class="cstat-no" title="statement not covered" ></span>t</span>.node.setAttribute("selected","true"),n="true",void 0===i.globals.selectedDataPoints[s]&amp;&amp;(i.globals.selectedDataPoints[s]=[]),i.globals.selectedDataPoints[s].push(r)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("true"===n){var d=<span class="cstat-no" title="statement not covered" >i.config.states.active.filter;<span class="cstat-no" title="statement not covered" ></span>"none"!==d&amp;&amp;a.applyFilter(t,s,d.type,d.value)}</span>else<span class="cstat-no" title="statement not covered" >"none"!==i.config.states.active.filter.type&amp;&amp;a.getDefaultFilter(t,s);<span class="cstat-no" title="statement not covered" >"</span></span>function"==typeof i.config.chart.events.dataPointSelection&amp;&amp;i.config.chart.events.dataPointSelection(e,this.ctx,{selectedDataPoints:i.globals.selectedDataPoints,seriesIndex:s,dataPointIndex:r,w:i}),e&amp;&amp;this.ctx.events.fireEvent("dataPointSelection",[e,this.ctx,{selectedDataPoints:i.globals.selectedDataPoints,seriesIndex:s,dataPointIndex:r,w:i}])}</span>},{key:"rotateAroundCenter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.getBBox();<span class="cstat-no" title="statement not covered" ></span>return{x:e.x+e.width/2,y:e.y+e.height/2}}</span>},{key:"getTextRects",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;4&amp;&amp;void 0!==arguments[4])||arguments[4],</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >this.drawText({x:-200,y:-200,text:t,textAnchor:"start",fontSize:e,fontFamily:i,foreColor:"#fff",opacity:0});<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;n.attr("transform",a),r.globals.dom.Paper.add(n);v</span>ar o=<span class="cstat-no" title="statement not covered" >n.bbox();<span class="cstat-no" title="statement not covered" ></span>return s||(o=n.node.getBoundingClientRect()),n.remove(),{width:o.width,height:o.height}}</span>},{key:"placeTextWithEllipsis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if("function"==typeof t.getComputedTextLength&amp;&amp;(t.textContent=e,e.length&gt;0&amp;&amp;t.getComputedTextLength()&gt;=i/.8)){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >e.length-3;</span>a&gt;0;a-=3)<span class="cstat-no" title="statement not covered" >if(t.getSubStringLength(0,a)&lt;=i/.8)<span class="cstat-no" title="statement not covered" >return void(t.textContent=e.substring(0,a)+"...");<span class="cstat-no" title="statement not covered" >t</span></span></span>.textContent="."}</span>}</span>}],[{key:"setAttrs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i in e)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(i)&amp;&amp;t.setAttribute(i,e[i])}</span></span>}]),t}</span>(),</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.annoCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"setOrientations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:null,</span>i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if("vertical"===t.label.orientation){var a=<span class="cstat-no" title="statement not covered" >null!==e?e:0,</span>s=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a,"']"));<span class="cstat-no" title="statement not covered" ></span>if(null!==s){var r=<span class="cstat-no" title="statement not covered" >s.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>s.setAttribute("x",parseFloat(s.getAttribute("x"))-r.height+4),"top"===t.label.position?s.setAttribute("y",parseFloat(s.getAttribute("y"))+r.width):s.setAttribute("y",parseFloat(s.getAttribute("y"))-r.width);v</span>ar n=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.rotateAroundCenter(s),</span>o=<span class="cstat-no" title="statement not covered" >n.x,</span>l=<span class="cstat-no" title="statement not covered" >n.y;<span class="cstat-no" title="statement not covered" ></span>s.setAttribute("transform","rotate(-90 ".concat(o," ").concat(l,")"))}</span>}</span>}</span>},{key:"addBackgroundToAnno",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(!e.label.text||e.label.text&amp;&amp;!e.label.text.trim())<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),</span>s=<span class="cstat-no" title="statement not covered" >t.getBoundingClientRect(),</span>r=<span class="cstat-no" title="statement not covered" >e.label.style.padding.left,</span>n=<span class="cstat-no" title="statement not covered" >e.label.style.padding.right,</span>o=<span class="cstat-no" title="statement not covered" >e.label.style.padding.top,</span>l=<span class="cstat-no" title="statement not covered" >e.label.style.padding.bottom;<span class="cstat-no" title="statement not covered" ></span>"vertical"===e.label.orientation&amp;&amp;(o=e.label.style.padding.left,l=e.label.style.padding.right,r=e.label.style.padding.top,n=e.label.style.padding.bottom);v</span>ar h=<span class="cstat-no" title="statement not covered" >s.left-a.left-r,</span>c=<span class="cstat-no" title="statement not covered" >s.top-a.top-o,</span>d=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawRect(h-i.globals.barPadForNumericAxis,c,s.width+r+n,s.height+o+l,e.label.borderRadius,e.label.style.background,1,e.label.borderWidth,e.label.borderColor,0);<span class="cstat-no" title="statement not covered" ></span>return e.id&amp;&amp;d.node.classList.add(e.id),d}</span>},{key:"annotationsBackground",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i,a,s){var r=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations .apexcharts-").concat(s,"-annotation-label[rel='").concat(a,"']"));<span class="cstat-no" title="statement not covered" ></span>if(r){var n=<span class="cstat-no" title="statement not covered" >r.parentNode,</span>o=<span class="cstat-no" title="statement not covered" >t.addBackgroundToAnno(r,i);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;n.insertBefore(o.node,r)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>e.config.annotations.xaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >i(t,e,"xaxis")}</span>)),e.config.annotations.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >i(t,e,"yaxis")}</span>)),e.config.annotations.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >i(t,e,"point")}</span>))}</span>},{key:"makeAnnotationDraggable",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w.config.annotations[e][i];<span class="cstat-no" title="statement not covered" ></span>t.draggable().on("dragend",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("x"),</span>i=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("y"),</span>s=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("cx"),</span>r=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("cy");<span class="cstat-no" title="statement not covered" ></span>a.x=e,a.y=i,s&amp;&amp;r&amp;&amp;(a.x=s,a.y=r)}</span>)),t.node.addEventListener("mousedown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.stopPropagation(),t.selectize({pointSize:8,rotationPoint:!1,pointType:"rect"}),t.resize().on("resizedone",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("width"),</span>i=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("height"),</span>s=<span class="cstat-no" title="statement not covered" >t.target.getAttribute("r");<span class="cstat-no" title="statement not covered" ></span>a.width=e,a.height=i,s&amp;&amp;(a.radius=s)}</span>))}</span>))}</span>},{key:"getStringX",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>e.config.xaxis.convertedCatToNumeric&amp;&amp;e.globals.categoryLabels.length&amp;&amp;(t=e.globals.categoryLabels.indexOf(t)+1);v</span>ar a=<span class="cstat-no" title="statement not covered" >e.globals.labels.indexOf(t),</span>s=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child("+(a+1)+")");<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(i=parseFloat(s.getAttribute("x"))),i}</span>}]),t}</span>(),</span>b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.annoCtx=i,this.invertAxis=this.annoCtx.invertAxis}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"addXaxisAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >this.invertAxis?a.globals.minY:a.globals.minX,</span>r=<span class="cstat-no" title="statement not covered" >this.invertAxis?a.globals.maxY:a.globals.maxX,</span>n=<span class="cstat-no" title="statement not covered" >this.invertAxis?a.globals.yRange[0]:a.globals.xRange,</span>o=<span class="cstat-no" title="statement not covered" >(t.x-s)/(n/a.globals.gridWidth);<span class="cstat-no" title="statement not covered" ></span>this.annoCtx.inversedReversedAxis&amp;&amp;(o=(r-t.x)/(n/a.globals.gridWidth));v</span>ar l=<span class="cstat-no" title="statement not covered" >t.label.text;<span class="cstat-no" title="statement not covered" ></span>"category"!==a.config.xaxis.type&amp;&amp;!a.config.xaxis.convertedCatToNumeric||this.invertAxis||a.globals.dataFormatXNumeric||(o=this.annoCtx.helpers.getStringX(t.x));v</span>ar h=<span class="cstat-no" title="statement not covered" >t.strokeDashArray;<span class="cstat-no" title="statement not covered" ></span>if(g.isNumber(o)){<span class="cstat-no" title="statement not covered" >if(null===t.x2||void 0===t.x2){var c=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawLine(o+t.offsetX,0+t.offsetY,o+t.offsetX,a.globals.gridHeight+t.offsetY,t.borderColor,h,t.borderWidth);<span class="cstat-no" title="statement not covered" ></span>e.appendChild(c.node),t.id&amp;&amp;c.node.classList.add(t.id)}</span>else{var d=<span class="cstat-no" title="statement not covered" >(t.x2-s)/(n/a.globals.gridWidth);<span class="cstat-no" title="statement not covered" ></span>if(this.annoCtx.inversedReversedAxis&amp;&amp;(d=(r-t.x2)/(n/a.globals.gridWidth)),"category"!==a.config.xaxis.type&amp;&amp;!a.config.xaxis.convertedCatToNumeric||this.invertAxis||a.globals.dataFormatXNumeric||(d=this.annoCtx.helpers.getStringX(t.x2)),d&lt;o){var u=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>o=d,d=u}</span>v</span>ar f=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawRect(o+t.offsetX,0+t.offsetY,d-o,a.globals.gridHeight+t.offsetY,0,t.fillColor,t.opacity,1,t.borderColor,h);<span class="cstat-no" title="statement not covered" ></span>f.node.classList.add("apexcharts-annotation-rect"),f.attr("clip-path","url(#gridRectMask".concat(a.globals.cuid,")")),e.appendChild(f.node),t.id&amp;&amp;f.node.classList.add(t.id)}</span>v</span>ar p=<span class="cstat-no" title="statement not covered" >"top"===t.label.position?4:a.globals.gridHeight,</span>x=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.getTextRects(l,parseFloat(t.label.style.fontSize)),</span>b=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawText({x:o+t.label.offsetX,y:p+t.label.offsetY-("vertical"===t.label.orientation?"top"===t.label.position?x.width/2-12:-x.width/2:0),text:l,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});<span class="cstat-no" title="statement not covered" ></span>b.attr({rel:i}),e.appendChild(b.node),this.annoCtx.helpers.setOrientations(t,i)}</span>}</span>},{key:"drawXAxisAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.group({class:"apexcharts-xaxis-annotations"});<span class="cstat-no" title="statement not covered" ></span>return e.config.annotations.xaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >t.addXaxisAnnotation(e,i.node,a)}</span>)),i}</span>}]),t}</span>(),</span>m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getStackedSeriesTotals",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0===t.globals.series.length)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.globals.series[t.globals.maxValsInArrayIndex].length;i++){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.globals.series.length;s++)<span class="cstat-no" title="statement not covered" >void 0!==t.globals.series[s][i]&amp;&amp;(a+=t.globals.series[s][i]);<span class="cstat-no" title="statement not covered" >e</span></span>.push(a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.globals.stackedSeriesTotals=e,e}</span>},{key:"getSeriesTotalByIndex",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:null;<span class="cstat-no" title="statement not covered" ></span>return null===t?this.w.config.series.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t+e}</span>),0):this.w.globals.series[t].reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t+e}</span>),0)}</span>},{key:"isSeriesNull",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:null;<span class="cstat-no" title="statement not covered" ></span>return 0===(null===t?this.w.config.series.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==t}</span>)):this.w.config.series[t].data.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==t}</span>))).length}</span>},{key:"seriesHaveSameValues",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.w.globals.series[t].every((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return t===i[0]}</span>))}</span>},{key:"getCategoryLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >t.slice();<span class="cstat-no" title="statement not covered" ></span>return e.config.xaxis.convertedCatToNumeric&amp;&amp;(i=t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.config.xaxis.labels.formatter(t-e.globals.minX+1)}</span>))),i}</span>},{key:"getLargestSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>t.globals.maxValsInArrayIndex=t.globals.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.length}</span>)).indexOf(Math.max.apply(Math,t.globals.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.length}</span>))))}</span>},{key:"getLargestMarkerSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.globals.markers.size.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e=Math.max(e,t)}</span>)),t.globals.markers.largestSize=e,e}</span>},{key:"getSeriesTotals",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>t.globals.seriesTotals=t.globals.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(t))<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.length;a++)<span class="cstat-no" title="statement not covered" >i+=t[a];e</span></span>lse <span class="cstat-no" title="statement not covered" >i+=t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>))}</span>},{key:"getSeriesTotalsXRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return i.globals.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(a,s){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;a.length;n++)<span class="cstat-no" title="statement not covered" >i.globals.seriesX[s][n]&gt;t&amp;&amp;i.globals.seriesX[s][n]&lt;e&amp;&amp;(r+=a[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>))}</span>},{key:"getPercentSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>t.globals.seriesPercent=t.globals.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){var a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e.length;s++){var r=<span class="cstat-no" title="statement not covered" >t.globals.stackedSeriesTotals[s],</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(n=100*e[s]/r),a.push(n)}</span>e</span>lse{var o=<span class="cstat-no" title="statement not covered" >100*e/t.globals.seriesTotals.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t+e}</span>),0);<span class="cstat-no" title="statement not covered" ></span>a.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>))}</span>},{key:"getCalculatedRatios",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e,i,a,s=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >.1,</span>h=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(s.yRange=[],s.isMultipleYAxis)<span class="cstat-no" title="statement not covered" >for(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;s.minYArr.length;c++)<span class="cstat-no" title="statement not covered" >s.yRange.push(Math.abs(s.minYArr[c]-s.maxYArr[c])),o.push(0);e</span></span>lse <span class="cstat-no" title="statement not covered" >s.yRange.push(Math.abs(s.minY-s.maxY));<span class="cstat-no" title="statement not covered" >s</span></span>.xRange=Math.abs(s.maxX-s.minX),s.zRange=Math.abs(s.maxZ-s.minZ);<span class="cstat-no" title="statement not covered" >f</span>or(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;s.yRange.length;d++)<span class="cstat-no" title="statement not covered" >r.push(s.yRange[d]/s.gridHeight);<span class="cstat-no" title="statement not covered" >i</span></span>f(e=s.xRange/s.gridWidth,i=Math.abs(s.initialMaxX-s.initialMinX)/s.gridWidth,t=s.yRange/s.gridWidth,a=s.xRange/s.gridHeight,(n=s.zRange/s.gridHeight*16)||(n=1),s.minY!==Number.MIN_VALUE&amp;&amp;0!==Math.abs(s.minY)&amp;&amp;(s.hasNegs=!0),s.isMultipleYAxis){<span class="cstat-no" title="statement not covered" >o=[];<span class="cstat-no" title="statement not covered" >f</span>or(var g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;r.length;g++)<span class="cstat-no" title="statement not covered" >o.push(-s.minYArr[g]/r[g])}</span></span>else <span class="cstat-no" title="statement not covered" >o.push(-s.minY/r[0]),s.minY!==Number.MIN_VALUE&amp;&amp;0!==Math.abs(s.minY)&amp;&amp;(l=-s.minY/t,h=s.minX/e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{yRatio:r,invertedYRatio:t,zRatio:n,xRatio:e,initialXRatio:i,invertedXRatio:a,baseLineInvertedY:l,baseLineY:o,baseLineX:h}}</span>},{key:"getLogSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return i.globals.seriesLog=t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >return i.config.yaxis[a]&amp;&amp;i.config.yaxis[a].logarithmic?t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null===t?null:e.getLogVal(t,a)}</span>)):t}</span>)),i.globals.invalidLogScale?t:i.globals.seriesLog}</span>},{key:"getLogVal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return(Math.log(t)-Math.log(i.globals.minYArr[e]))/(Math.log(i.globals.maxYArr[e])-Math.log(i.globals.minYArr[e]))}</span>},{key:"getLogYRatios",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>return a.yLogRatio=t.slice(),a.logYRange=a.yRange.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >if(i.config.yaxis[s]&amp;&amp;e.w.config.yaxis[s].logarithmic){var r,n=<span class="cstat-no" title="statement not covered" >-Number.MAX_VALUE,</span>o=<span class="cstat-no" title="statement not covered" >Number.MIN_VALUE;<span class="cstat-no" title="statement not covered" ></span>return a.seriesLog.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.config.yaxis[e]&amp;&amp;i.config.yaxis[e].logarithmic&amp;&amp;(n=Math.max(t,n),o=Math.min(t,o))}</span>))}</span>)),r=Math.pow(a.yRange[s],Math.abs(o-n)/a.yRange[s]),a.yLogRatio[s]=r/a.gridHeight,r}</span>}</span>)),a.invalidLogScale?t.slice():a.yLogRatio}</span>}],[{key:"checkComboSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;void 0!==t[0].type&amp;&amp;(e=!0,t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"bar"!==t.type&amp;&amp;"column"!==t.type&amp;&amp;"candlestick"!==t.type||i++}</span>))),{comboBarCount:i,comboCharts:e}}</span>},{key:"extendArrayProps",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return e.yaxis&amp;&amp;(e=t.extendYAxis(e,i)),e.annotations&amp;&amp;(e.annotations.yaxis&amp;&amp;(e=t.extendYAxisAnnotations(e)),e.annotations.xaxis&amp;&amp;(e=t.extendXAxisAnnotations(e)),e.annotations.points&amp;&amp;(e=t.extendPointAnnotations(e))),e}</span>}]),t}</span>(),</span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.annoCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"addYaxisAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a,s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >t.strokeDashArray,</span>n=<span class="cstat-no" title="statement not covered" >this._getY1Y2("y1",t),</span>o=<span class="cstat-no" title="statement not covered" >t.label.text;<span class="cstat-no" title="statement not covered" ></span>if(null===t.y2||void 0===t.y2){var l=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawLine(0+t.offsetX,n+t.offsetY,s.globals.gridWidth+t.offsetX,n+t.offsetY,t.borderColor,r,t.borderWidth);<span class="cstat-no" title="statement not covered" ></span>e.appendChild(l.node),t.id&amp;&amp;l.node.classList.add(t.id)}</span>else{<span class="cstat-no" title="statement not covered" >if((a=this._getY1Y2("y2",t))&gt;n){var h=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=a,a=h}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawRect(0+t.offsetX,a+t.offsetY,s.globals.gridWidth+t.offsetX,n-a,0,t.fillColor,t.opacity,1,t.borderColor,r);<span class="cstat-no" title="statement not covered" ></span>c.node.classList.add("apexcharts-annotation-rect"),c.attr("clip-path","url(#gridRectMask".concat(s.globals.cuid,")")),e.appendChild(c.node),t.id&amp;&amp;c.node.classList.add(t.id)}</span>v</span>ar d=<span class="cstat-no" title="statement not covered" >"right"===t.label.position?s.globals.gridWidth:0,</span>g=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawText({x:d+t.label.offsetX,y:(a||n)+t.label.offsetY-3,text:o,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});<span class="cstat-no" title="statement not covered" ></span>g.attr({rel:i}),e.appendChild(g.node)}</span>},{key:"_getY1Y2",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i,a=<span class="cstat-no" title="statement not covered" >"y1"===t?e.y:e.y2,</span>s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(this.annoCtx.invertAxis){var r=<span class="cstat-no" title="statement not covered" >s.globals.labels.indexOf(a);<span class="cstat-no" title="statement not covered" ></span>s.config.xaxis.convertedCatToNumeric&amp;&amp;(r=s.globals.categoryLabels.indexOf(a));v</span>ar n=<span class="cstat-no" title="statement not covered" >s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child("+(r+1)+")");<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(i=parseFloat(n.getAttribute("y")))}</span>else{var o;<span class="cstat-no" title="statement not covered" >if(s.config.yaxis[e.yAxisIndex].logarithmic)<span class="cstat-no" title="statement not covered" >o=(a=new m(this.annoCtx.ctx).getLogVal(a,e.yAxisIndex))/s.globals.yLogRatio[e.yAxisIndex];e</span>lse <span class="cstat-no" title="statement not covered" >o=(a-s.globals.minYArr[e.yAxisIndex])/(s.globals.yRange[e.yAxisIndex]/s.globals.gridHeight);<span class="cstat-no" title="statement not covered" >i</span></span>=s.globals.gridHeight-o,s.config.yaxis[e.yAxisIndex]&amp;&amp;s.config.yaxis[e.yAxisIndex].reversed&amp;&amp;(i=o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>},{key:"drawYAxisAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.group({class:"apexcharts-yaxis-annotations"});<span class="cstat-no" title="statement not covered" ></span>return e.config.annotations.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >t.addYaxisAnnotation(e,i.node,a)}</span>)),i}</span>}]),t}</span>(),</span>y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.annoCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"addPointAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.annoCtx.invertAxis&amp;&amp;console.warn("Point annotation is not supported in horizontal bar charts.");v</span>ar o,l=<span class="cstat-no" title="statement not covered" >parseFloat(t.y);<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof t.x){var h=<span class="cstat-no" title="statement not covered" >a.globals.labels.indexOf(t.x);<span class="cstat-no" title="statement not covered" ></span>a.config.xaxis.convertedCatToNumeric&amp;&amp;(h=a.globals.categoryLabels.indexOf(t.x)),s=this.annoCtx.helpers.getStringX(t.x),null===t.y&amp;&amp;(l=a.globals.series[t.seriesIndex][h])}</span>else <span class="cstat-no" title="statement not covered" >s=(t.x-a.globals.minX)/(a.globals.xRange/a.globals.gridWidth);<span class="cstat-no" title="statement not covered" >a</span></span>.config.yaxis[t.yAxisIndex].logarithmic?o=(l=new m(this.annoCtx.ctx).getLogVal(l,t.yAxisIndex))/a.globals.yLogRatio[t.yAxisIndex]:o=(l-a.globals.minYArr[t.yAxisIndex])/(a.globals.yRange[t.yAxisIndex]/a.globals.gridHeight);<span class="cstat-no" title="statement not covered" >i</span>f(r=a.globals.gridHeight-o-parseFloat(t.label.style.fontSize)-t.marker.size,n=a.globals.gridHeight-o,a.config.yaxis[t.yAxisIndex]&amp;&amp;a.config.yaxis[t.yAxisIndex].reversed&amp;&amp;(r=o+parseFloat(t.label.style.fontSize)+t.marker.size,n=o),g.isNumber(s)){var c=<span class="cstat-no" title="statement not covered" >{pSize:t.marker.size,pWidth:t.marker.strokeWidth,pointFillColor:t.marker.fillColor,pointStrokeColor:t.marker.strokeColor,shape:t.marker.shape,pRadius:t.marker.radius,class:"apexcharts-point-annotation-marker ".concat(t.marker.cssClass," ").concat(t.id?t.id:"")},</span>d=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawMarker(s+t.marker.offsetX,n+t.marker.offsetY,c);<span class="cstat-no" title="statement not covered" ></span>e.appendChild(d.node);v</span>ar u=<span class="cstat-no" title="statement not covered" >t.label.text?t.label.text:"",</span>f=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.drawText({x:s+t.label.offsetX,y:r+t.label.offsetY,text:u,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-point-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});<span class="cstat-no" title="statement not covered" ></span>if(f.attr({rel:i}),e.appendChild(f.node),t.customSVG.SVG){var p=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.group({class:"apexcharts-point-annotations-custom-svg "+t.customSVG.cssClass});<span class="cstat-no" title="statement not covered" ></span>p.attr({transform:"translate(".concat(s+t.customSVG.offsetX,", ").concat(r+t.customSVG.offsetY,")")}),p.node.innerHTML=t.customSVG.SVG,e.appendChild(p.node)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.image.path){var x=<span class="cstat-no" title="statement not covered" >t.image.width?t.image.width:20,</span>b=<span class="cstat-no" title="statement not covered" >t.image.height?t.image.height:20;<span class="cstat-no" title="statement not covered" ></span>this.annoCtx.addImage({x:s+t.image.offsetX-x/2,y:r+t.image.offsetY-b/2,width:x,height:b,path:t.image.path,appendTo:".apexcharts-point-annotations"})}</span>}</span>}</span>},{key:"drawPointAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.annoCtx.graphics.group({class:"apexcharts-point-annotations"});<span class="cstat-no" title="statement not covered" ></span>return e.config.annotations.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >t.addPointAnnotation(e,i.node,a)}</span>)),i}</span>}]),t}</span>();</span>var w,k,A=<span class="cstat-no" title="statement not covered" >{name:"en",options:{months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],toolbar:{exportToSVG:"Download SVG",exportToPNG:"Download PNG",exportToCSV:"Download CSV",menu:"Menu",selection:"Selection",selectionZoom:"Selection Zoom",zoomIn:"Zoom In",zoomOut:"Zoom Out",pan:"Panning",reset:"Reset Zoom"}}},</span>S=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >e(this,t),this.yAxis={show:!0,showAlways:!1,showForNullSeries:!0,seriesName:void 0,opposite:!1,reversed:!1,logarithmic:!1,tickAmount:void 0,forceNiceScale:!1,max:void 0,min:void 0,floating:!1,decimalsInFloat:void 0,labels:{show:!0,minWidth:0,maxWidth:160,offsetX:0,offsetY:0,align:void 0,rotate:0,padding:20,style:{colors:[],fontSize:"11px",fontWeight:400,fontFamily:void 0,cssClass:""},formatter:void 0},axisBorder:{show:!1,color:"#e0e0e0",width:1,offsetX:0,offsetY:0},axisTicks:{show:!1,color:"#e0e0e0",width:6,offsetX:0,offsetY:0},title:{text:void 0,rotate:90,offsetY:0,offsetX:0,style:{color:void 0,fontSize:"11px",fontWeight:900,fontFamily:void 0,cssClass:""}},tooltip:{enabled:!1,offsetX:0},crosshairs:{show:!0,position:"front",stroke:{color:"#b6b6b6",width:1,dashArray:0}}},this.pointAnnotation={x:0,y:null,yAxisIndex:0,seriesIndex:0,marker:{size:4,fillColor:"#fff",strokeWidth:2,strokeColor:"#333",shape:"circle",offsetX:0,offsetY:0,radius:2,cssClass:""},label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"middle",offsetX:0,offsetY:0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}},customSVG:{SVG:void 0,cssClass:void 0,offsetX:0,offsetY:0},image:{path:void 0,width:20,height:20,offsetX:0,offsetY:0}},this.yAxisAnnotation={y:0,y2:null,strokeDashArray:1,fillColor:"#c2c2c2",borderColor:"#c2c2c2",borderWidth:1,opacity:.3,offsetX:0,offsetY:0,yAxisIndex:0,label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"end",position:"right",offsetX:0,offsetY:-3,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}}},this.xAxisAnnotation={x:0,x2:null,strokeDashArray:1,fillColor:"#c2c2c2",borderColor:"#c2c2c2",borderWidth:1,opacity:.3,offsetX:0,offsetY:0,label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"middle",orientation:"vertical",position:"top",offsetX:0,offsetY:0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}}},this.text={x:0,y:0,text:"",textAnchor:"start",foreColor:void 0,fontSize:"13px",fontFamily:void 0,fontWeight:400,appendTo:".apexcharts-annotations",backgroundColor:"transparent",borderColor:"#c2c2c2",borderRadius:0,borderWidth:0,paddingLeft:4,paddingRight:4,paddingTop:2,paddingBottom:2},this.shape={x:0,y:0,type:"rect",width:"100%",height:50,appendTo:".apexcharts-annotations",backgroundColor:"#fff",opacity:1,borderWidth:0,borderRadius:4,borderColor:"#c2c2c2"}}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{annotations:{position:"front",yaxis:[this.yAxisAnnotation],xaxis:[this.xAxisAnnotation],points:[this.pointAnnotation],texts:[],images:[],shapes:[]},chart:{animations:{enabled:!0,easing:"easeinout",speed:800,animateGradually:{delay:150,enabled:!0},dynamicAnimation:{enabled:!0,speed:350}},background:"transparent",locales:[A],defaultLocale:"en",dropShadow:{enabled:!1,enabledOnSeries:void 0,top:2,left:2,blur:4,color:"#000",opacity:.35},events:{animationEnd:void 0,beforeMount:void 0,mounted:void 0,updated:void 0,click:void 0,mouseMove:void 0,legendClick:void 0,markerClick:void 0,selection:void 0,dataPointSelection:void 0,dataPointMouseEnter:void 0,dataPointMouseLeave:void 0,beforeZoom:void 0,zoomed:void 0,scrolled:void 0},foreColor:"#373d3f",fontFamily:"Helvetica, Arial, sans-serif",height:"auto",parentHeightOffset:15,redrawOnParentResize:!0,id:void 0,group:void 0,offsetX:0,offsetY:0,selection:{enabled:!1,type:"x",fill:{color:"#24292e",opacity:.1},stroke:{width:1,color:"#24292e",opacity:.4,dashArray:3},xaxis:{min:void 0,max:void 0},yaxis:{min:void 0,max:void 0}},sparkline:{enabled:!1},brush:{enabled:!1,autoScaleYaxis:!0,target:void 0},stacked:!1,stackType:"normal",toolbar:{show:!0,offsetX:0,offsetY:0,tools:{download:!0,selection:!0,zoom:!0,zoomin:!0,zoomout:!0,pan:!0,reset:!0,customIcons:[]},autoSelected:"zoom"},type:"line",width:"100%",zoom:{enabled:!0,type:"x",autoScaleYaxis:!1,zoomedArea:{fill:{color:"#90CAF9",opacity:.4},stroke:{color:"#0D47A1",opacity:.4,width:1}}}},plotOptions:{bar:{horizontal:!1,columnWidth:"70%",barHeight:"70%",distributed:!1,startingShape:"flat",endingShape:"flat",rangeBarOverlap:!0,colors:{ranges:[],backgroundBarColors:[],backgroundBarOpacity:1,backgroundBarRadius:0},dataLabels:{position:"top",maxItems:100,hideOverflowingLabels:!0,orientation:"horizontal"}},bubble:{minBubbleRadius:void 0,maxBubbleRadius:void 0},candlestick:{colors:{upward:"#00B746",downward:"#EF403C"},wick:{useFillColor:!0}},heatmap:{radius:2,enableShades:!0,shadeIntensity:.5,reverseNegativeShade:!1,distributed:!1,useFillColorAsStroke:!1,colorScale:{inverse:!1,ranges:[],min:void 0,max:void 0}},radialBar:{inverseOrder:!1,startAngle:0,endAngle:360,offsetX:0,offsetY:0,hollow:{margin:5,size:"50%",background:"transparent",image:void 0,imageWidth:150,imageHeight:150,imageOffsetX:0,imageOffsetY:0,imageClipped:!0,position:"front",dropShadow:{enabled:!1,top:0,left:0,blur:3,color:"#000",opacity:.5}},track:{show:!0,startAngle:void 0,endAngle:void 0,background:"#f2f2f2",strokeWidth:"97%",opacity:1,margin:5,dropShadow:{enabled:!1,top:0,left:0,blur:3,color:"#000",opacity:.5}},dataLabels:{show:!0,name:{show:!0,fontSize:"16px",fontFamily:void 0,fontWeight:600,color:void 0,offsetY:0,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>},value:{show:!0,fontSize:"14px",fontFamily:void 0,fontWeight:400,color:void 0,offsetY:16,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t+"%"}</span>},total:{show:!1,label:"Total",fontSize:"16px",fontWeight:600,fontFamily:void 0,color:void 0,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.globals.seriesTotals.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t+e}</span>),0)/t.globals.series.length+"%"}</span>}}},pie:{customScale:1,offsetX:0,offsetY:0,startAngle:0,expandOnClick:!0,dataLabels:{offset:0,minAngleToShowLabel:10},donut:{size:"65%",background:"transparent",labels:{show:!1,name:{show:!0,fontSize:"16px",fontFamily:void 0,fontWeight:600,color:void 0,offsetY:-10,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>},value:{show:!0,fontSize:"20px",fontFamily:void 0,fontWeight:400,color:void 0,offsetY:10,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>},total:{show:!1,showAlways:!1,label:"Total",fontSize:"16px",fontWeight:400,fontFamily:void 0,color:void 0,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.globals.seriesTotals.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t+e}</span>),0)}</span>}}}},polarArea:{rings:{strokeWidth:1,strokeColor:"#e8e8e8"}},radar:{size:void 0,offsetX:0,offsetY:0,polygons:{strokeWidth:1,strokeColors:"#e8e8e8",connectorColors:"#e8e8e8",fill:{colors:void 0}}}},colors:void 0,dataLabels:{enabled:!0,enabledOnSeries:void 0,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==t?t:""}</span>,textAnchor:"middle",distributed:!1,offsetX:0,offsetY:0,style:{fontSize:"12px",fontFamily:void 0,fontWeight:600,colors:void 0},background:{enabled:!0,foreColor:"#fff",borderRadius:2,padding:4,opacity:.9,borderWidth:1,borderColor:"#fff",dropShadow:{enabled:!1,top:1,left:1,blur:1,color:"#000",opacity:.45}},dropShadow:{enabled:!1,top:1,left:1,blur:1,color:"#000",opacity:.45}},fill:{type:"solid",colors:void 0,opacity:.85,gradient:{shade:"dark",type:"horizontal",shadeIntensity:.5,gradientToColors:void 0,inverseColors:!0,opacityFrom:1,opacityTo:1,stops:[0,50,100],colorStops:[]},image:{src:[],width:void 0,height:void 0},pattern:{style:"squares",width:6,height:6,strokeWidth:2}},grid:{show:!0,borderColor:"#e0e0e0",strokeDashArray:0,position:"back",xaxis:{lines:{show:!1}},yaxis:{lines:{show:!0}},row:{colors:void 0,opacity:.5},column:{colors:void 0,opacity:.5},padding:{top:0,right:10,bottom:0,left:12}},labels:[],legend:{show:!0,showForSingleSeries:!1,showForNullSeries:!0,showForZeroSeries:!0,floating:!1,position:"bottom",horizontalAlign:"center",inverseOrder:!1,fontSize:"12px",fontFamily:void 0,fontWeight:400,width:void 0,height:void 0,formatter:void 0,tooltipHoverFormatter:void 0,offsetX:-20,offsetY:4,labels:{colors:void 0,useSeriesColors:!1},markers:{width:12,height:12,strokeWidth:0,fillColors:void 0,strokeColor:"#fff",radius:12,customHTML:void 0,offsetX:0,offsetY:0,onClick:void 0},itemMargin:{horizontal:5,vertical:2},onItemClick:{toggleDataSeries:!0},onItemHover:{highlightDataSeries:!0}},markers:{discrete:[],size:0,colors:void 0,strokeColors:"#fff",strokeWidth:2,strokeOpacity:.9,strokeDashArray:0,fillOpacity:1,shape:"circle",radius:2,offsetX:0,offsetY:0,onClick:void 0,onDblClick:void 0,showNullDataPoints:!0,hover:{size:void 0,sizeOffset:3}},noData:{text:void 0,align:"center",verticalAlign:"middle",offsetX:0,offsetY:0,style:{color:void 0,fontSize:"14px",fontFamily:void 0}},responsive:[],series:void 0,states:{normal:{filter:{type:"none",value:0}},hover:{filter:{type:"lighten",value:.15}},active:{allowMultipleDataPointsSelection:!1,filter:{type:"darken",value:.65}}},title:{text:void 0,align:"left",margin:5,offsetX:0,offsetY:0,floating:!1,style:{fontSize:"14px",fontWeight:900,fontFamily:void 0,color:void 0}},subtitle:{text:void 0,align:"left",margin:5,offsetX:0,offsetY:30,floating:!1,style:{fontSize:"12px",fontWeight:400,fontFamily:void 0,color:void 0}},stroke:{show:!0,curve:"smooth",lineCap:"butt",width:2,colors:void 0,dashArray:0},tooltip:{enabled:!0,enabledOnSeries:void 0,shared:!0,followCursor:!1,intersect:!1,inverseOrder:!1,custom:void 0,fillSeriesColor:!1,theme:"light",style:{fontSize:"12px",fontFamily:void 0},onDatasetHover:{highlightDataSeries:!1},x:{show:!0,format:"dd MMM",formatter:void 0},y:{formatter:void 0,title:{formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>}},z:{formatter:void 0,title:"Size: "},marker:{show:!0,fillColors:void 0},items:{display:"flex"},fixed:{enabled:!1,position:"topRight",offsetX:0,offsetY:0}},xaxis:{type:"category",categories:[],convertedCatToNumeric:!1,sorted:!1,offsetX:0,offsetY:0,labels:{show:!0,rotate:-45,rotateAlways:!1,hideOverlappingLabels:!0,trim:!1,minHeight:void 0,maxHeight:120,showDuplicates:!0,style:{colors:[],fontSize:"12px",fontWeight:400,fontFamily:void 0,cssClass:""},offsetX:0,offsetY:0,format:void 0,formatter:void 0,datetimeUTC:!0,datetimeFormatter:{year:"yyyy",month:"MMM 'yy",day:"dd MMM",hour:"HH:mm",minute:"HH:mm:ss"}},axisBorder:{show:!0,color:"#e0e0e0",width:"100%",height:1,offsetX:0,offsetY:0},axisTicks:{show:!0,color:"#e0e0e0",height:6,offsetX:0,offsetY:0},tickAmount:void 0,tickPlacement:"on",min:void 0,max:void 0,range:void 0,floating:!1,position:"bottom",title:{text:void 0,offsetX:0,offsetY:0,style:{color:void 0,fontSize:"12px",fontWeight:900,fontFamily:void 0,cssClass:""}},crosshairs:{show:!0,width:1,position:"back",opacity:.9,stroke:{color:"#b6b6b6",width:1,dashArray:3},fill:{type:"solid",color:"#B1B9C4",gradient:{colorFrom:"#D8E3F0",colorTo:"#BED1E6",stops:[0,100],opacityFrom:.4,opacityTo:.5}},dropShadow:{enabled:!1,left:0,top:0,blur:1,opacity:.4}},tooltip:{enabled:!0,offsetY:0,formatter:void 0,style:{fontSize:"12px",fontFamily:void 0}}},yaxis:this.yAxis,theme:{mode:"light",palette:"palette1",monochrome:{enabled:!1,color:"#008FFB",shadeTo:"light",shadeIntensity:.65}}}}</span>}]),t}</span>(),</span>C=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.graphics=new p(this.ctx),this.w.globals.isBarHorizontal&amp;&amp;(this.invertAxis=!0),this.helpers=new x(this),this.xAxisAnnotations=new b(this),this.yAxisAnnotations=new v(this),this.pointsAnnotations=new y(this),this.w.globals.isBarHorizontal&amp;&amp;this.w.config.yaxis[0].reversed&amp;&amp;(this.inversedReversedAxis=!0),this.xDivision=this.w.globals.gridWidth/this.w.globals.dataPoints}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawAxesAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(t.globals.axisCharts){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.yAxisAnnotations.drawYAxisAnnotations(),</span>i=<span class="cstat-no" title="statement not covered" >this.xAxisAnnotations.drawXAxisAnnotations(),</span>a=<span class="cstat-no" title="statement not covered" >this.pointsAnnotations.drawPointAnnotations(),</span>s=<span class="cstat-no" title="statement not covered" >t.config.chart.animations.enabled,</span>r=<span class="cstat-no" title="statement not covered" >[e,i,a],</span>n=<span class="cstat-no" title="statement not covered" >[i.node,e.node,a.node],</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;3;o++)<span class="cstat-no" title="statement not covered" >t.globals.dom.elGraphical.add(r[o]),!s||t.globals.resized||t.globals.dataChanged||"scatter"!==t.config.chart.type&amp;&amp;"bubble"!==t.config.chart.type&amp;&amp;t.globals.dataPoints&gt;1&amp;&amp;n[o].classList.add("apexcharts-element-hidden"),t.globals.delayedElements.push({el:n[o],index:0});<span class="cstat-no" title="statement not covered" >t</span></span>his.helpers.annotationsBackground()}</span>}</span>},{key:"drawShapeAnnos",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.w.config.annotations.shapes.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >t.addShape(e,i)}</span>))}</span>},{key:"drawImageAnnos",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.w.config.annotations.images.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >t.addImage(e,i)}</span>))}</span>},{key:"drawTextAnnos",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.w.config.annotations.texts.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >t.addText(e,i)}</span>))}</span>},{key:"addXaxisAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.xAxisAnnotations.addXaxisAnnotation(t,e,i)}</span>},{key:"addYaxisAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.yAxisAnnotations.addYaxisAnnotation(t,e,i)}</span>},{key:"addPointAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.pointsAnnotations.addPointAnnotation(t,e,i)}</span>},{key:"addText",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=<span class="cstat-no" title="statement not covered" >t.y,</span>s=<span class="cstat-no" title="statement not covered" >t.text,</span>r=<span class="cstat-no" title="statement not covered" >t.textAnchor,</span>n=<span class="cstat-no" title="statement not covered" >t.foreColor,</span>o=<span class="cstat-no" title="statement not covered" >t.fontSize,</span>l=<span class="cstat-no" title="statement not covered" >t.fontFamily,</span>h=<span class="cstat-no" title="statement not covered" >t.fontWeight,</span>c=<span class="cstat-no" title="statement not covered" >t.cssClass,</span>d=<span class="cstat-no" title="statement not covered" >t.backgroundColor,</span>g=<span class="cstat-no" title="statement not covered" >t.borderWidth,</span>u=<span class="cstat-no" title="statement not covered" >t.strokeDashArray,</span>f=<span class="cstat-no" title="statement not covered" >t.borderRadius,</span>p=<span class="cstat-no" title="statement not covered" >t.borderColor,</span>x=<span class="cstat-no" title="statement not covered" >t.appendTo,</span>b=<span class="cstat-no" title="statement not covered" >void 0===x?".apexcharts-annotations":x,</span>m=<span class="cstat-no" title="statement not covered" >t.paddingLeft,</span>v=<span class="cstat-no" title="statement not covered" >void 0===m?4:m,</span>y=<span class="cstat-no" title="statement not covered" >t.paddingRight,</span>w=<span class="cstat-no" title="statement not covered" >void 0===y?4:y,</span>k=<span class="cstat-no" title="statement not covered" >t.paddingBottom,</span>A=<span class="cstat-no" title="statement not covered" >void 0===k?2:k,</span>S=<span class="cstat-no" title="statement not covered" >t.paddingTop,</span>C=<span class="cstat-no" title="statement not covered" >void 0===S?2:S,</span>L=<span class="cstat-no" title="statement not covered" >this.w,</span>P=<span class="cstat-no" title="statement not covered" >this.graphics.drawText({x:i,y:a,text:s,textAnchor:r||"start",fontSize:o||"12px",fontWeight:h||"regular",fontFamily:l||L.config.chart.fontFamily,foreColor:n||L.config.chart.foreColor,cssClass:c}),</span>T=<span class="cstat-no" title="statement not covered" >L.globals.dom.baseEl.querySelector(b);<span class="cstat-no" title="statement not covered" ></span>T&amp;&amp;T.appendChild(P.node);v</span>ar z=<span class="cstat-no" title="statement not covered" >P.bbox();<span class="cstat-no" title="statement not covered" ></span>if(t.draggable&amp;&amp;this.helpers.makeAnnotationDraggable(P,"texts",e),s){var I=<span class="cstat-no" title="statement not covered" >this.graphics.drawRect(z.x-v,z.y-C,z.width+v+w,z.height+A+C,f,d||"transparent",1,g,p,u);<span class="cstat-no" title="statement not covered" ></span>T.insertBefore(I.node,P.node)}</span>}</span>},{key:"addShape",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >{type:t.type,x:t.x||0,y:t.y||0,width:t.width||"100%",height:t.height||50,circleRadius:t.radius||25,backgroundColor:t.backgroundColor||"#fff",opacity:t.opacity||1,borderWidth:t.borderWidth||0,borderRadius:t.borderRadius||4,borderColor:t.borderColor||"#c2c2c2",appendTo:t.appendTo||".apexcharts-annotations"},</span>a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>String(i.width).indexOf("%")&gt;-1&amp;&amp;(i.width=parseInt(i.width,10)*parseInt(a.globals.svgWidth,10)/100);v</span>ar s=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>s="circle"===i.type?this.graphics.drawCircle(i.circleRadius,{fill:i.backgroundColor,stroke:i.borderColor,"stroke-width":i.borderWidth,opacity:i.opacity,cx:i.x,cy:i.y}):this.graphics.drawRect(i.x,i.y,i.width,i.height,i.borderRadius,i.backgroundColor,i.opacity,i.borderWidth,i.borderColor);v</span>ar r=<span class="cstat-no" title="statement not covered" >a.globals.dom.baseEl.querySelector(i.appendTo);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;r.appendChild(s.node),t.draggable&amp;&amp;(this.helpers.makeAnnotationDraggable(s,"shapes",e),s.node.classList.add("apexcharts-resizable-element"))}</span>},{key:"addImage",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >t.path,</span>s=<span class="cstat-no" title="statement not covered" >t.x,</span>r=<span class="cstat-no" title="statement not covered" >void 0===s?0:s,</span>n=<span class="cstat-no" title="statement not covered" >t.y,</span>o=<span class="cstat-no" title="statement not covered" >void 0===n?0:n,</span>l=<span class="cstat-no" title="statement not covered" >t.width,</span>h=<span class="cstat-no" title="statement not covered" >void 0===l?20:l,</span>c=<span class="cstat-no" title="statement not covered" >t.height,</span>d=<span class="cstat-no" title="statement not covered" >void 0===c?20:c,</span>g=<span class="cstat-no" title="statement not covered" >t.appendTo,</span>u=<span class="cstat-no" title="statement not covered" >void 0===g?".apexcharts-annotations":g,</span>f=<span class="cstat-no" title="statement not covered" >i.globals.dom.Paper.image(a);<span class="cstat-no" title="statement not covered" ></span>f.size(h,d).move(r,o);v</span>ar p=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(u);<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;p.appendChild(f.node),t.draggable&amp;&amp;(this.helpers.makeAnnotationDraggable(f,"images",e),f.node.classList.add("apexcharts-resizable-element"))}</span>},{key:"addXaxisAnnotationExternal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"xaxis",contextMethod:i.addXaxisAnnotation}),i}</span>},{key:"addYaxisAnnotationExternal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"yaxis",contextMethod:i.addYaxisAnnotation}),i}</span>},{key:"addPointAnnotationExternal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return void 0===this.invertAxis&amp;&amp;(this.invertAxis=i.w.globals.isBarHorizontal),this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"point",contextMethod:i.addPointAnnotation}),i}</span>},{key:"addAnnotationExternal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.params,</span>i=<span class="cstat-no" title="statement not covered" >t.pushToMemory,</span>a=<span class="cstat-no" title="statement not covered" >t.context,</span>s=<span class="cstat-no" title="statement not covered" >t.type,</span>r=<span class="cstat-no" title="statement not covered" >t.contextMethod,</span>n=<span class="cstat-no" title="statement not covered" >a,</span>o=<span class="cstat-no" title="statement not covered" >n.w,</span>l=<span class="cstat-no" title="statement not covered" >o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations")),</span>h=<span class="cstat-no" title="statement not covered" >l.childNodes.length+1,</span>c=<span class="cstat-no" title="statement not covered" >new S,</span>d=<span class="cstat-no" title="statement not covered" >Object.assign({},"xaxis"===s?c.xAxisAnnotation:"yaxis"===s?c.yAxisAnnotation:c.pointAnnotation),</span>u=<span class="cstat-no" title="statement not covered" >g.extend(d,e);<span class="cstat-no" title="statement not covered" ></span>switch(s){case"xaxis":<span class="cstat-no" title="statement not covered" >this.addXaxisAnnotation(u,l,h);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"yaxis":<span class="cstat-no" title="statement not covered" >this.addYaxisAnnotation(u,l,h);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"point":<span class="cstat-no" title="statement not covered" >this.addPointAnnotation(u,l,h)}</span>v</span>ar f=<span class="cstat-no" title="statement not covered" >o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations .apexcharts-").concat(s,"-annotation-label[rel='").concat(h,"']")),</span>p=<span class="cstat-no" title="statement not covered" >this.helpers.addBackgroundToAnno(f,u);<span class="cstat-no" title="statement not covered" ></span>return p&amp;&amp;l.insertBefore(p.node,f),i&amp;&amp;o.globals.memory.methodsToExec.push({context:n,id:u.id?u.id:g.randomId(),method:r,label:"addAnnotation",params:e}),a}</span>},{key:"clearAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");<span class="cstat-no" title="statement not covered" ></span>e.globals.memory.methodsToExec.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >"addText"!==t.label&amp;&amp;"addAnnotation"!==t.label||e.globals.memory.methodsToExec.splice(i,1)}</span>)),i=g.listToArray(i),Array.prototype.forEach.call(i,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(;t.firstChild;)<span class="cstat-no" title="statement not covered" >t.removeChild(t.firstChild)}</span></span>))}</span>},{key:"removeAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >t.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelectorAll(".".concat(e));<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(i.globals.memory.methodsToExec.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >t.id===e&amp;&amp;i.globals.memory.methodsToExec.splice(a,1)}</span>)),Array.prototype.forEach.call(a,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.parentElement.removeChild(t)}</span>)))}</span>}]),t}</span>(),</span>L=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.opts=null,this.seriesIndex=0}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"clippedImgArea",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.config,</span>a=<span class="cstat-no" title="statement not covered" >parseInt(e.globals.gridWidth,10),</span>s=<span class="cstat-no" title="statement not covered" >parseInt(e.globals.gridHeight,10),</span>r=<span class="cstat-no" title="statement not covered" >a&gt;s?a:s,</span>n=<span class="cstat-no" title="statement not covered" >t.image,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>void 0===t.width&amp;&amp;void 0===t.height?void 0!==i.fill.image.width&amp;&amp;void 0!==i.fill.image.height?(o=i.fill.image.width+1,l=i.fill.image.height):(o=r+1,l=r):(o=t.width,l=t.height);v</span>ar h=<span class="cstat-no" title="statement not covered" >document.createElementNS(e.globals.SVGNS,"pattern");<span class="cstat-no" title="statement not covered" ></span>p.setAttrs(h,{id:t.patternID,patternUnits:t.patternUnits?t.patternUnits:"userSpaceOnUse",width:o+"px",height:l+"px"});v</span>ar c=<span class="cstat-no" title="statement not covered" >document.createElementNS(e.globals.SVGNS,"image");<span class="cstat-no" title="statement not covered" ></span>h.appendChild(c),c.setAttributeNS(window.SVG.xlink,"href",n),p.setAttrs(c,{x:0,y:0,preserveAspectRatio:"none",width:o+"px",height:l+"px"}),c.style.opacity=t.opacity,e.globals.dom.elDefs.node.appendChild(h)}</span>},{key:"getSeriesIndex",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return("bar"===e.config.chart.type||"rangeBar"===e.config.chart.type)&amp;&amp;e.config.plotOptions.bar.distributed||"heatmap"===e.config.chart.type?this.seriesIndex=t.seriesNumber:this.seriesIndex=t.seriesNumber%e.globals.series.length,this.seriesIndex}</span>},{key:"fillPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.opts=t;v</span>ar i,a,s,r=<span class="cstat-no" title="statement not covered" >this.w.config;<span class="cstat-no" title="statement not covered" ></span>this.seriesIndex=this.getSeriesIndex(t);v</span>ar n=<span class="cstat-no" title="statement not covered" >this.getFillColors()[this.seriesIndex];<span class="cstat-no" title="statement not covered" ></span>"function"==typeof n&amp;&amp;(n=n({seriesIndex:this.seriesIndex,dataPointIndex:t.dataPointIndex,value:t.value,w:e}));v</span>ar o=<span class="cstat-no" title="statement not covered" >this.getFillType(this.seriesIndex),</span>l=<span class="cstat-no" title="statement not covered" >Array.isArray(r.fill.opacity)?r.fill.opacity[this.seriesIndex]:r.fill.opacity,</span>h=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(t.color&amp;&amp;(n=t.color),-1===n.indexOf("rgb")?n.length&lt;9&amp;&amp;(h=g.hexToRgba(n,l)):n.indexOf("rgba")&gt;-1&amp;&amp;(l=g.getOpacityFromRGBA(n)),t.opacity&amp;&amp;(l=t.opacity),"pattern"===o&amp;&amp;(a=this.handlePatternFill(a,n,l,h)),"gradient"===o&amp;&amp;(s=this.handleGradientFill(n,l,this.seriesIndex)),"image"===o){var c=<span class="cstat-no" title="statement not covered" >r.fill.image.src,</span>d=<span class="cstat-no" title="statement not covered" >t.patternID?t.patternID:"";<span class="cstat-no" title="statement not covered" ></span>this.clippedImgArea({opacity:l,image:Array.isArray(c)?t.seriesNumber&lt;c.length?c[t.seriesNumber]:c[0]:c,width:t.width?t.width:void 0,height:t.height?t.height:void 0,patternUnits:t.patternUnits,patternID:"pattern".concat(e.globals.cuid).concat(t.seriesNumber+1).concat(d)}),i="url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber+1).concat(d,")")}</span>else <span class="cstat-no" title="statement not covered" >i="gradient"===o?s:"pattern"===o?a:h;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.solid&amp;&amp;(i=h),i}</span>},{key:"getFillType",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(e.config.fill.type)?e.config.fill.type[t]:e.config.fill.type}</span>},{key:"getFillColors",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.config,</span>i=<span class="cstat-no" title="statement not covered" >this.opts,</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.globals.comboCharts?"line"===t.config.series[this.seriesIndex].type?t.globals.stroke.colors instanceof Array?a=t.globals.stroke.colors:a.push(t.globals.stroke.colors):t.globals.fill.colors instanceof Array?a=t.globals.fill.colors:a.push(t.globals.fill.colors):"line"===e.chart.type?t.globals.stroke.colors instanceof Array?a=t.globals.stroke.colors:a.push(t.globals.stroke.colors):t.globals.fill.colors instanceof Array?a=t.globals.fill.colors:a.push(t.globals.fill.colors),void 0!==i.fillColors&amp;&amp;(a=[],i.fillColors instanceof Array?a=i.fillColors.slice():a.push(i.fillColors)),a}</span>},{key:"handlePatternFill",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w.config,</span>r=<span class="cstat-no" title="statement not covered" >this.opts,</span>n=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>o=<span class="cstat-no" title="statement not covered" >void 0===s.fill.pattern.strokeWidth?Array.isArray(s.stroke.width)?s.stroke.width[this.seriesIndex]:s.stroke.width:Array.isArray(s.fill.pattern.strokeWidth)?s.fill.pattern.strokeWidth[this.seriesIndex]:s.fill.pattern.strokeWidth,</span>l=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>s.fill.pattern.style instanceof Array?t=void 0!==s.fill.pattern.style[r.seriesNumber]?n.drawPattern(s.fill.pattern.style[r.seriesNumber],s.fill.pattern.width,s.fill.pattern.height,l,o,i):a:t=n.drawPattern(s.fill.pattern.style,s.fill.pattern.width,s.fill.pattern.height,l,o,i);<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>},{key:"handleGradientFill",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a,s=<span class="cstat-no" title="statement not covered" >this.w.config,</span>r=<span class="cstat-no" title="statement not covered" >this.opts,</span>n=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>o=<span class="cstat-no" title="statement not covered" >new g,</span>l=<span class="cstat-no" title="statement not covered" >s.fill.gradient.type,</span>h=<span class="cstat-no" title="statement not covered" >t,</span>c=<span class="cstat-no" title="statement not covered" >void 0===s.fill.gradient.opacityFrom?e:Array.isArray(s.fill.gradient.opacityFrom)?s.fill.gradient.opacityFrom[i]:s.fill.gradient.opacityFrom;<span class="cstat-no" title="statement not covered" ></span>h.indexOf("rgba")&gt;-1&amp;&amp;(c=g.getOpacityFromRGBA(h));v</span>ar d=<span class="cstat-no" title="statement not covered" >void 0===s.fill.gradient.opacityTo?e:Array.isArray(s.fill.gradient.opacityTo)?s.fill.gradient.opacityTo[i]:s.fill.gradient.opacityTo;<span class="cstat-no" title="statement not covered" ></span>if(void 0===s.fill.gradient.gradientToColors||0===s.fill.gradient.gradientToColors.length)<span class="cstat-no" title="statement not covered" >a="dark"===s.fill.gradient.shade?o.shadeColor(-1*parseFloat(s.fill.gradient.shadeIntensity),t.indexOf("rgb")&gt;-1?g.rgb2hex(t):t):o.shadeColor(parseFloat(s.fill.gradient.shadeIntensity),t.indexOf("rgb")&gt;-1?g.rgb2hex(t):t);e</span>lse{var u=<span class="cstat-no" title="statement not covered" >s.fill.gradient.gradientToColors[r.seriesNumber];<span class="cstat-no" title="statement not covered" ></span>a=u,u.indexOf("rgba")&gt;-1&amp;&amp;(d=g.getOpacityFromRGBA(u))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.fill.gradient.inverseColors){var f=<span class="cstat-no" title="statement not covered" >h;<span class="cstat-no" title="statement not covered" ></span>h=a,a=f}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h.indexOf("rgb")&gt;-1&amp;&amp;(h=g.rgb2hex(h)),a.indexOf("rgb")&gt;-1&amp;&amp;(a=g.rgb2hex(a)),n.drawGradient(l,h,a,c,d,r.size,s.fill.gradient.stops,s.fill.gradient.colorStops,i)}</span>}]),t}</span>(),</span>P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"setGlobalMarkerSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(t.globals.markers.size=Array.isArray(t.config.markers.size)?t.config.markers.size:[t.config.markers.size],t.globals.markers.size.length&gt;0){<span class="cstat-no" title="statement not covered" >if(t.globals.markers.size.length&lt;t.globals.series.length+1)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;=t.globals.series.length;e++)<span class="cstat-no" title="statement not covered" >void 0===t.globals.markers.size[e]&amp;&amp;t.globals.markers.size.push(t.globals.markers.size[0])}</span></span></span>else <span class="cstat-no" title="statement not covered" >t.globals.markers.size=t.config.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.config.markers.size}</span>))}</span></span>},{key:"plotChartMarkers",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s,r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]&amp;&amp;arguments[4],</span>n=<span class="cstat-no" title="statement not covered" >this.w,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >t,</span>h=<span class="cstat-no" title="statement not covered" >null,</span>c=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if((n.globals.markers.size[e]&gt;0||r)&amp;&amp;(h=c.group({class:r?"":"apexcharts-series-markers"})).attr("clip-path","url(#gridRectMarkerMask".concat(n.globals.cuid,")")),l.x instanceof Array)<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;l.x.length;d++){var f=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>1===i&amp;&amp;0===d&amp;&amp;(f=0),1===i&amp;&amp;1===d&amp;&amp;(f=1);v</span>ar x=<span class="cstat-no" title="statement not covered" >"apexcharts-marker";<span class="cstat-no" title="statement not covered" ></span>"line"!==n.config.chart.type&amp;&amp;"area"!==n.config.chart.type||n.globals.comboCharts||n.config.tooltip.intersect||(x+=" no-pointer-events");v</span>ar b=<span class="cstat-no" title="statement not covered" >Array.isArray(n.config.markers.size)?n.globals.markers.size[e]&gt;0:n.config.markers.size&gt;0;<span class="cstat-no" title="statement not covered" ></span>if(b||r){<span class="cstat-no" title="statement not covered" >g.isNumber(l.y[d])?x+=" w".concat(g.randomId()):x="apexcharts-nullpoint";v</span>ar m=<span class="cstat-no" title="statement not covered" >this.getMarkerConfig(x,e,f);<span class="cstat-no" title="statement not covered" ></span>n.config.series[o].data[i]&amp;&amp;(n.config.series[o].data[i].fillColor&amp;&amp;(m.pointFillColor=n.config.series[o].data[i].fillColor),n.config.series[o].data[i].strokeColor&amp;&amp;(m.pointStrokeColor=n.config.series[o].data[i].strokeColor)),a&amp;&amp;(m.pSize=a),(s=c.drawMarker(l.x[d],l.y[d],m)).attr("rel",f),s.attr("j",f),s.attr("index",e),s.node.setAttribute("default-marker-size",m.pSize);v</span>ar v=<span class="cstat-no" title="statement not covered" >new u(this.ctx);<span class="cstat-no" title="statement not covered" ></span>v.setSelectionFilter(s,e,f),this.addEvents(s),h&amp;&amp;h.add(s)}</span>else <span class="cstat-no" title="statement not covered" >void 0===n.globals.pointsArray[e]&amp;&amp;(n.globals.pointsArray[e]=[]),n.globals.pointsArray[e].push([l.x[d],l.y[d]])}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn h}</span>},{key:"getMarkerConfig",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:null,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >this.getMarkerStyle(e),</span>r=<span class="cstat-no" title="statement not covered" >a.globals.markers.size[e],</span>n=<span class="cstat-no" title="statement not covered" >a.config.markers;<span class="cstat-no" title="statement not covered" ></span>return null!==i&amp;&amp;n.discrete.length&amp;&amp;n.discrete.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.seriesIndex===e&amp;&amp;t.dataPointIndex===i&amp;&amp;(s.pointStrokeColor=t.strokeColor,s.pointFillColor=t.fillColor,r=t.size)}</span>)),{pSize:r,pRadius:n.radius,pWidth:n.strokeWidth instanceof Array?n.strokeWidth[e]:n.strokeWidth,pointStrokeColor:s.pointStrokeColor,pointFillColor:s.pointFillColor,shape:n.shape instanceof Array?n.shape[e]:n.shape,class:t,pointStrokeOpacity:n.strokeOpacity instanceof Array?n.strokeOpacity[e]:n.strokeOpacity,pointStrokeDashArray:n.strokeDashArray instanceof Array?n.strokeDashArray[e]:n.strokeDashArray,pointFillOpacity:n.fillOpacity instanceof Array?n.fillOpacity[e]:n.fillOpacity,seriesIndex:e}}</span>},{key:"addEvents",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>t.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this.ctx,t)),t.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this.ctx,t)),t.node.addEventListener("mousedown",i.pathMouseDown.bind(this.ctx,t)),t.node.addEventListener("click",e.config.markers.onClick),t.node.addEventListener("dblclick",e.config.markers.onDblClick),t.node.addEventListener("touchstart",i.pathMouseDown.bind(this.ctx,t),{passive:!0})}</span>},{key:"getMarkerStyle",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals.markers.colors,</span>a=<span class="cstat-no" title="statement not covered" >e.config.markers.strokeColor||e.config.markers.strokeColors;<span class="cstat-no" title="statement not covered" ></span>return{pointStrokeColor:a instanceof Array?a[t]:a,pointFillColor:i instanceof Array?i[t]:i}}</span>}]),t}</span>(),</span>T=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&amp;&amp;this.w.config.chart.animations.dynamicAnimation.enabled}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >i.realIndex,</span>n=<span class="cstat-no" title="statement not covered" >i.pointsPos,</span>o=<span class="cstat-no" title="statement not covered" >i.zRatio,</span>l=<span class="cstat-no" title="statement not covered" >i.elParent,</span>h=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)});<span class="cstat-no" title="statement not covered" ></span>if(h.attr("clip-path","url(#gridRectMarkerMask".concat(a.globals.cuid,")")),n.x instanceof Array)<span class="cstat-no" title="statement not covered" >for(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;n.x.length;c++){var d=<span class="cstat-no" title="statement not covered" >e+1,</span>g=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>0===e&amp;&amp;0===c&amp;&amp;(d=0),0===e&amp;&amp;1===c&amp;&amp;(d=1);v</span>ar u=<span class="cstat-no" title="statement not covered" >0,</span>f=<span class="cstat-no" title="statement not covered" >a.globals.markers.size[r];<span class="cstat-no" title="statement not covered" ></span>if(o!==1/0){<span class="cstat-no" title="statement not covered" >f=a.globals.seriesZ[r][d]/o;v</span>ar x=<span class="cstat-no" title="statement not covered" >a.config.plotOptions.bubble;<span class="cstat-no" title="statement not covered" ></span>x.minBubbleRadius&amp;&amp;f&lt;x.minBubbleRadius&amp;&amp;(f=x.minBubbleRadius),x.maxBubbleRadius&amp;&amp;f&gt;x.maxBubbleRadius&amp;&amp;(f=x.maxBubbleRadius)}<span class="cstat-no" title="statement not covered" ></span>a</span>.config.chart.animations.enabled||(u=f);v</span>ar b=<span class="cstat-no" title="statement not covered" >n.x[c],</span>m=<span class="cstat-no" title="statement not covered" >n.y[c];<span class="cstat-no" title="statement not covered" ></span>if(u=u||0,null!==m&amp;&amp;void 0!==a.globals.series[r][d]||(g=!1),g){var v=<span class="cstat-no" title="statement not covered" >this.drawPoint(b,m,u,f,r,d,e);<span class="cstat-no" title="statement not covered" ></span>h.add(v)}<span class="cstat-no" title="statement not covered" ></span>l</span>.add(h)}</span>}</span></span>},{key:"drawPoint",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r,n){var o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >new f(this.ctx),</span>c=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>d=<span class="cstat-no" title="statement not covered" >new L(this.ctx),</span>g=<span class="cstat-no" title="statement not covered" >new P(this.ctx),</span>x=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>b=<span class="cstat-no" title="statement not covered" >g.getMarkerConfig("apexcharts-marker",l),</span>m=<span class="cstat-no" title="statement not covered" >d.fillPath({seriesNumber:s,dataPointIndex:r,patternUnits:"objectBoundingBox",value:o.globals.series[s][n]}),</span>v=<span class="cstat-no" title="statement not covered" >x.drawCircle(i);<span class="cstat-no" title="statement not covered" ></span>if(o.config.series[l].data[r]&amp;&amp;o.config.series[l].data[r].fillColor&amp;&amp;(m=o.config.series[l].data[r].fillColor),v.attr({cx:t,cy:e,fill:m,stroke:b.pointStrokeColor,"stroke-width":b.pWidth,"stroke-dasharray":b.pointStrokeDashArray,"stroke-opacity":b.pointStrokeOpacity}),o.config.chart.dropShadow.enabled){var y=<span class="cstat-no" title="statement not covered" >o.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>c.dropShadow(v,y,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.initialAnim&amp;&amp;!o.globals.dataChanged){var w=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>o.globals.resized||(w=o.config.chart.animations.speed),h.animateCircleRadius(v,0,a,w,o.globals.easing,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >window.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >h.animationCompleted(v)}</span>),100)}</span>))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.globals.dataChanged)<span class="cstat-no" title="statement not covered" >if(this.dynamicAnim){var k,A,S,C,T=<span class="cstat-no" title="statement not covered" >o.config.chart.animations.dynamicAnimation.speed;<span class="cstat-no" title="statement not covered" ></span>null!=(C=o.globals.previousPaths[s]&amp;&amp;o.globals.previousPaths[s][n])&amp;&amp;(k=C.x,A=C.y,S=void 0!==C.r?C.r:a);<span class="cstat-no" title="statement not covered" >f</span>or(var z=<span class="cstat-no" title="statement not covered" >0;</span>z&lt;o.globals.collapsedSeries.length;z++)<span class="cstat-no" title="statement not covered" >o.globals.collapsedSeries[z].index===s&amp;&amp;(T=1,a=0);<span class="cstat-no" title="statement not covered" >0</span></span>===t&amp;&amp;0===e&amp;&amp;(a=0),h.animateCircle(v,{cx:k,cy:A,r:S},{cx:t,cy:e,r:a},T,o.globals.easing)}</span>else <span class="cstat-no" title="statement not covered" >v.attr({r:a});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn v.attr({rel:r,j:r,index:s,"default-marker-size":a}),c.setSelectionFilter(v,s,r),g.addEvents(v),v.node.classList.add("apexcharts-marker"),v}</span>},{key:"centerTextInBubble",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return{y:t+=parseInt(e.config.dataLabels.style.fontSize,10)/4}}</span>}]),t}</span>(),</span>z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"dataLabelsCorrection",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r,n){var o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >!1,</span>h=<span class="cstat-no" title="statement not covered" >new p(this.ctx).getTextRects(i,n),</span>c=<span class="cstat-no" title="statement not covered" >h.width,</span>d=<span class="cstat-no" title="statement not covered" >h.height;<span class="cstat-no" title="statement not covered" ></span>void 0===o.globals.dataLabelsRects[a]&amp;&amp;(o.globals.dataLabelsRects[a]=[]),o.globals.dataLabelsRects[a].push({x:t,y:e,width:c,height:d});v</span>ar g=<span class="cstat-no" title="statement not covered" >o.globals.dataLabelsRects[a].length-2,</span>u=<span class="cstat-no" title="statement not covered" >void 0!==o.globals.lastDrawnDataLabelsIndexes[a]?o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length-1]:0;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==o.globals.dataLabelsRects[a][g]){var f=<span class="cstat-no" title="statement not covered" >o.globals.dataLabelsRects[a][u];<span class="cstat-no" title="statement not covered" ></span>(t&gt;f.x+f.width+2||e&gt;f.y+f.height+2||t+c&lt;f.x)&amp;&amp;(l=!0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn(0===s||r)&amp;&amp;(l=!0),{x:t,y:e,textRects:h,drawnextLabel:l}}</span>},{key:"drawDataLabel",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:2,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>o=<span class="cstat-no" title="statement not covered" >r.config.dataLabels,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >i,</span>d=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(!o.enabled||t.x instanceof Array!=!0)<span class="cstat-no" title="statement not covered" >return d;<span class="cstat-no" title="statement not covered" >d</span></span>=n.group({class:"apexcharts-data-labels"});<span class="cstat-no" title="statement not covered" >f</span>or(var g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;t.x.length;g++)<span class="cstat-no" title="statement not covered" >if(l=t.x[g]+o.offsetX,h=t.y[g]+o.offsetY+s,!isNaN(l)){<span class="cstat-no" title="statement not covered" >1===i&amp;&amp;0===g&amp;&amp;(c=0),1===i&amp;&amp;1===g&amp;&amp;(c=1);v</span>ar u=<span class="cstat-no" title="statement not covered" >r.globals.series[e][c],</span>f=<span class="cstat-no" title="statement not covered" >"",</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.config.dataLabels.formatter(t,{ctx:a.ctx,seriesIndex:e,dataPointIndex:c,w:r})}</span>;<span class="cstat-no" title="statement not covered" ></span>if("bubble"===r.config.chart.type){<span class="cstat-no" title="statement not covered" >f=x(u=r.globals.seriesZ[e][c]),h=t.y[g];v</span>ar b=<span class="cstat-no" title="statement not covered" >new T(this.ctx),</span>m=<span class="cstat-no" title="statement not covered" >b.centerTextInBubble(h,e,c);<span class="cstat-no" title="statement not covered" ></span>h=m.y}</span>else <span class="cstat-no" title="statement not covered" >void 0!==u&amp;&amp;(f=x(u));<span class="cstat-no" title="statement not covered" >t</span></span>his.plotDataLabelsText({x:l,y:h,text:f,i:e,j:c,parent:d,offsetCorrection:!0,dataLabelsConfig:r.config.dataLabels})}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn d}</span>},{key:"plotDataLabelsText",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >t.x,</span>s=<span class="cstat-no" title="statement not covered" >t.y,</span>r=<span class="cstat-no" title="statement not covered" >t.i,</span>n=<span class="cstat-no" title="statement not covered" >t.j,</span>o=<span class="cstat-no" title="statement not covered" >t.text,</span>l=<span class="cstat-no" title="statement not covered" >t.textAnchor,</span>h=<span class="cstat-no" title="statement not covered" >t.parent,</span>c=<span class="cstat-no" title="statement not covered" >t.dataLabelsConfig,</span>d=<span class="cstat-no" title="statement not covered" >t.color,</span>g=<span class="cstat-no" title="statement not covered" >t.alwaysDrawDataLabel,</span>f=<span class="cstat-no" title="statement not covered" >t.offsetCorrection;<span class="cstat-no" title="statement not covered" ></span>if(!(Array.isArray(e.config.dataLabels.enabledOnSeries)&amp;&amp;e.config.dataLabels.enabledOnSeries.indexOf(r)&lt;0)){var x=<span class="cstat-no" title="statement not covered" >{x:a,y:s,drawnextLabel:!0};<span class="cstat-no" title="statement not covered" ></span>f&amp;&amp;(x=this.dataLabelsCorrection(a,s,o,r,n,g,parseInt(c.style.fontSize,10))),e.globals.zoomed||(a=x.x,s=x.y),x.textRects&amp;&amp;(a+x.textRects.width&lt;-20||a&gt;e.globals.gridWidth+20)&amp;&amp;(o="");v</span>ar b=<span class="cstat-no" title="statement not covered" >e.globals.dataLabels.style.colors[r];<span class="cstat-no" title="statement not covered" ></span>(("bar"===e.config.chart.type||"rangeBar"===e.config.chart.type)&amp;&amp;e.config.plotOptions.bar.distributed||e.config.dataLabels.distributed)&amp;&amp;(b=e.globals.dataLabels.style.colors[n]),d&amp;&amp;(b=d);v</span>ar m=<span class="cstat-no" title="statement not covered" >c.offsetX,</span>v=<span class="cstat-no" title="statement not covered" >c.offsetY;<span class="cstat-no" title="statement not covered" ></span>if("bar"!==e.config.chart.type&amp;&amp;"rangeBar"!==e.config.chart.type||(m=0,v=0),x.drawnextLabel){var y=<span class="cstat-no" title="statement not covered" >i.drawText({width:100,height:parseInt(c.style.fontSize,10),x:a+m,y:s+v,foreColor:b,textAnchor:l||c.textAnchor,text:o,fontSize:c.style.fontSize,fontFamily:c.style.fontFamily,fontWeight:c.style.fontWeight||"normal"});<span class="cstat-no" title="statement not covered" ></span>if(y.attr({class:"apexcharts-datalabel",cx:a,cy:s}),c.dropShadow.enabled){var w=<span class="cstat-no" title="statement not covered" >c.dropShadow;<span class="cstat-no" title="statement not covered" ></span>new u(this.ctx).dropShadow(y,w)}<span class="cstat-no" title="statement not covered" ></span>h</span>.add(y),void 0===e.globals.lastDrawnDataLabelsIndexes[r]&amp;&amp;(e.globals.lastDrawnDataLabelsIndexes[r]=[]),e.globals.lastDrawnDataLabelsIndexes[r].push(n)}</span>}</span>}</span>},{key:"addBackgroundToDataLabel",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.config.dataLabels.background,</span>s=<span class="cstat-no" title="statement not covered" >a.padding,</span>r=<span class="cstat-no" title="statement not covered" >a.padding/2,</span>n=<span class="cstat-no" title="statement not covered" >e.width,</span>o=<span class="cstat-no" title="statement not covered" >e.height,</span>l=<span class="cstat-no" title="statement not covered" >new p(this.ctx).drawRect(e.x-s,e.y-r/2,n+2*s,o+r,a.borderRadius,"transparent"===i.config.chart.background?"#fff":i.config.chart.background,a.opacity,a.borderWidth,a.borderColor);<span class="cstat-no" title="statement not covered" ></span>a.dropShadow.enabled&amp;&amp;new u(this.ctx).dropShadow(l,a.dropShadow);<span class="cstat-no" title="statement not covered" >r</span>eturn l}</span>},{key:"dataLabelsBackground",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if("bubble"!==t.config.chart.type)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++){var a=<span class="cstat-no" title="statement not covered" >e[i],</span>s=<span class="cstat-no" title="statement not covered" >a.getBBox(),</span>r=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(s.width&amp;&amp;s.height&amp;&amp;(r=this.addBackgroundToDataLabel(a,s)),r){<span class="cstat-no" title="statement not covered" >a.parentNode.insertBefore(r.node,a);v</span>ar n=<span class="cstat-no" title="statement not covered" >a.getAttribute("fill");<span class="cstat-no" title="statement not covered" ></span>t.config.chart.animations.enabled&amp;&amp;!t.globals.resized&amp;&amp;!t.globals.dataChanged?r.animate().attr({fill:n}):r.attr({fill:n}),a.setAttribute("fill",t.config.dataLabels.background.foreColor)}</span>}</span>}</span></span>},{key:"bringForward",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.getElementsByClassName("apexcharts-datalabels"),</span>i=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"),</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;e.length;a++)<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.insertBefore(e[a],i.nextSibling)}</span></span>}]),t}</span>(),</span>I=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.barCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"handleBarDataLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.x,</span>i=<span class="cstat-no" title="statement not covered" >t.y,</span>a=<span class="cstat-no" title="statement not covered" >t.y1,</span>s=<span class="cstat-no" title="statement not covered" >t.y2,</span>r=<span class="cstat-no" title="statement not covered" >t.i,</span>n=<span class="cstat-no" title="statement not covered" >t.j,</span>o=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>l=<span class="cstat-no" title="statement not covered" >t.series,</span>h=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>c=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>d=<span class="cstat-no" title="statement not covered" >t.barYPosition,</span>g=<span class="cstat-no" title="statement not covered" >t.visibleSeries,</span>u=<span class="cstat-no" title="statement not covered" >t.renderedPath,</span>f=<span class="cstat-no" title="statement not covered" >this.w,</span>x=<span class="cstat-no" title="statement not covered" >new p(this.barCtx.ctx),</span>b=<span class="cstat-no" title="statement not covered" >Array.isArray(this.barCtx.strokeWidth)?this.barCtx.strokeWidth[o]:this.barCtx.strokeWidth,</span>m=<span class="cstat-no" title="statement not covered" >e+parseFloat(c*g),</span>v=<span class="cstat-no" title="statement not covered" >i+parseFloat(h*g);<span class="cstat-no" title="statement not covered" ></span>f.globals.isXNumeric&amp;&amp;!f.globals.isBarHorizontal&amp;&amp;(m=e+parseFloat(c*(g+1)),v=i+parseFloat(h*(g+1))-b);v</span>ar y=<span class="cstat-no" title="statement not covered" >e,</span>w=<span class="cstat-no" title="statement not covered" >i,</span>k=<span class="cstat-no" title="statement not covered" >{},</span>A=<span class="cstat-no" title="statement not covered" >f.config.dataLabels,</span>S=<span class="cstat-no" title="statement not covered" >this.barCtx.barOptions.dataLabels;<span class="cstat-no" title="statement not covered" ></span>void 0!==d&amp;&amp;this.barCtx.isTimelineBar&amp;&amp;(v=d,w=d);v</span>ar C=<span class="cstat-no" title="statement not covered" >A.offsetX,</span>L=<span class="cstat-no" title="statement not covered" >A.offsetY,</span>P=<span class="cstat-no" title="statement not covered" >{width:0,height:0};<span class="cstat-no" title="statement not covered" ></span>if(f.config.dataLabels.enabled){var T=<span class="cstat-no" title="statement not covered" >String(f.globals.minY).length&gt;String(f.globals.maxY).length?f.globals.minY:f.globals.maxY;<span class="cstat-no" title="statement not covered" ></span>P=x.getTextRects(f.globals.yLabelFormatters[0](T),parseFloat(A.style.fontSize))}</span>v</span>ar z=<span class="cstat-no" title="statement not covered" >{x:e,y:i,i:r,j:n,renderedPath:u,bcx:m,bcy:v,barHeight:h,barWidth:c,textRects:P,strokeWidth:b,dataLabelsX:y,dataLabelsY:w,barDataLabelsConfig:S,offX:C,offY:L};<span class="cstat-no" title="statement not covered" ></span>return k=this.barCtx.isHorizontal?this.calculateBarsDataLabelsPosition(z):this.calculateColumnsDataLabelsPosition(z),u.attr({cy:k.bcy,cx:k.bcx,j:n,val:l[r][n],barHeight:h,barWidth:c}),this.drawCalculatedDataLabels({x:k.dataLabelsX,y:k.dataLabelsY,val:this.barCtx.isTimelineBar?[a,s]:l[r][n],i:o,j:n,barWidth:c,barHeight:h,textRects:P,dataLabelsConfig:A})}</span>},{key:"calculateColumnsDataLabelsPosition",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >t.i,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >t.y,</span>n=<span class="cstat-no" title="statement not covered" >t.bcx,</span>o=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>l=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>h=<span class="cstat-no" title="statement not covered" >t.textRects,</span>c=<span class="cstat-no" title="statement not covered" >t.dataLabelsY,</span>d=<span class="cstat-no" title="statement not covered" >t.barDataLabelsConfig,</span>g=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>u=<span class="cstat-no" title="statement not covered" >t.offX,</span>f=<span class="cstat-no" title="statement not covered" >t.offY;<span class="cstat-no" title="statement not covered" ></span>l=Math.abs(l);v</span>ar p=<span class="cstat-no" title="statement not covered" >"vertical"===i.config.plotOptions.bar.dataLabels.orientation;<span class="cstat-no" title="statement not covered" ></span>n-=g/2;v</span>ar x=<span class="cstat-no" title="statement not covered" >i.globals.gridWidth/i.globals.dataPoints;<span class="cstat-no" title="statement not covered" ></span>if(e=i.globals.isXNumeric?n-o/2+u:n-x+o/2+u,p){<span class="cstat-no" title="statement not covered" >e=e+h.height/2-g/2-2}</span>v</span>ar b=<span class="cstat-no" title="statement not covered" >this.barCtx.series[a][s]&lt;0,</span>m=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>switch(this.barCtx.isReversed&amp;&amp;(m=r-l+(b?2*l:0),r-=l),d.position){case"center":<span class="cstat-no" title="statement not covered" >c=p?b?m+l/2+f:m+l/2-f:b?m-l/2+h.height/2+f:m+l/2+h.height/2-f;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bottom":<span class="cstat-no" title="statement not covered" >c=p?b?m+l+f:m+l-f:b?m-l+h.height+g+f:m+l-h.height/2+g-f;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"top":<span class="cstat-no" title="statement not covered" >c=p?b?m+f:m-f:b?m-h.height/2-f:m+h.height+f}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.config.chart.stacked||(c&lt;0?c=0+g:c+h.height/3&gt;i.globals.gridHeight&amp;&amp;(c=i.globals.gridHeight-g)),{bcx:n,bcy:r,dataLabelsX:e,dataLabelsY:c}}</span>},{key:"calculateBarsDataLabelsPosition",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=<span class="cstat-no" title="statement not covered" >t.i,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >t.bcy,</span>n=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>o=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>l=<span class="cstat-no" title="statement not covered" >t.textRects,</span>h=<span class="cstat-no" title="statement not covered" >t.dataLabelsX,</span>c=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>d=<span class="cstat-no" title="statement not covered" >t.barDataLabelsConfig,</span>g=<span class="cstat-no" title="statement not covered" >t.offX,</span>u=<span class="cstat-no" title="statement not covered" >t.offY,</span>f=<span class="cstat-no" title="statement not covered" >e.globals.gridHeight/e.globals.dataPoints;<span class="cstat-no" title="statement not covered" ></span>o=Math.abs(o);v</span>ar p=<span class="cstat-no" title="statement not covered" >r-(this.barCtx.isTimelineBar?0:f)+n/2+l.height/2+u-3,</span>x=<span class="cstat-no" title="statement not covered" >this.barCtx.series[a][s]&lt;0,</span>b=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>switch(this.barCtx.isReversed&amp;&amp;(b=i+o-(x?2*o:0),i=e.globals.gridWidth-o),d.position){case"center":<span class="cstat-no" title="statement not covered" >h=x?b+o/2-g:b-o/2+g;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bottom":<span class="cstat-no" title="statement not covered" >h=x?b+o-c-Math.round(l.width/2)-g:b-o+c+Math.round(l.width/2)+g;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"top":<span class="cstat-no" title="statement not covered" >h=x?b-c+Math.round(l.width/2)-g:b-c-Math.round(l.width/2)+g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.config.chart.stacked||(h&lt;0?h=h+l.width+c:h+l.width/2&gt;e.globals.gridWidth&amp;&amp;(h=e.globals.gridWidth-l.width-c)),{bcx:i,bcy:r,dataLabelsX:h,dataLabelsY:p}}</span>},{key:"drawCalculatedDataLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.x,</span>i=<span class="cstat-no" title="statement not covered" >t.y,</span>a=<span class="cstat-no" title="statement not covered" >t.val,</span>s=<span class="cstat-no" title="statement not covered" >t.i,</span>r=<span class="cstat-no" title="statement not covered" >t.j,</span>o=<span class="cstat-no" title="statement not covered" >t.textRects,</span>l=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>h=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>c=<span class="cstat-no" title="statement not covered" >t.dataLabelsConfig,</span>d=<span class="cstat-no" title="statement not covered" >this.w,</span>g=<span class="cstat-no" title="statement not covered" >"rotate(0)";<span class="cstat-no" title="statement not covered" ></span>"vertical"===d.config.plotOptions.bar.dataLabels.orientation&amp;&amp;(g="rotate(-90, ".concat(e,", ").concat(i,")"));v</span>ar u=<span class="cstat-no" title="statement not covered" >new z(this.barCtx.ctx),</span>f=<span class="cstat-no" title="statement not covered" >new p(this.barCtx.ctx),</span>x=<span class="cstat-no" title="statement not covered" >c.formatter,</span>b=<span class="cstat-no" title="statement not covered" >null,</span>m=<span class="cstat-no" title="statement not covered" >d.globals.collapsedSeriesIndices.indexOf(s)&gt;-1;<span class="cstat-no" title="statement not covered" ></span>if(c.enabled&amp;&amp;!m){<span class="cstat-no" title="statement not covered" >b=f.group({class:"apexcharts-data-labels",transform:g});v</span>ar v=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>void 0!==a&amp;&amp;(v=x(a,{seriesIndex:s,dataPointIndex:r,w:d})),0===a&amp;&amp;d.config.chart.stacked&amp;&amp;(v="");v</span>ar y=<span class="cstat-no" title="statement not covered" >d.globals.series[s][r]&lt;=0,</span>w=<span class="cstat-no" title="statement not covered" >d.config.plotOptions.bar.dataLabels.position;<span class="cstat-no" title="statement not covered" ></span>if("vertical"===d.config.plotOptions.bar.dataLabels.orientation&amp;&amp;("top"===w&amp;&amp;(c.textAnchor=y?"end":"start"),"center"===w&amp;&amp;(c.textAnchor="middle"),"bottom"===w&amp;&amp;(c.textAnchor=y?"end":"start")),this.barCtx.isTimelineBar&amp;&amp;this.barCtx.barOptions.dataLabels.hideOverflowingLabels)<span class="cstat-no" title="statement not covered" >h&lt;f.getTextRects(v,parseFloat(c.style.fontSize)).width&amp;&amp;(v="");<span class="cstat-no" title="statement not covered" >d</span></span>.config.chart.stacked&amp;&amp;this.barCtx.barOptions.dataLabels.hideOverflowingLabels&amp;&amp;(this.barCtx.isHorizontal?((h=Math.abs(d.globals.series[s][r])/this.barCtx.invertedYRatio[this.barCtx.yaxisIndex])&gt;0&amp;&amp;o.width/1.6&gt;h||h&lt;0&amp;&amp;o.width/1.6&lt;h)&amp;&amp;(v=""):(l=Math.abs(d.globals.series[s][r])/this.barCtx.yRatio[this.barCtx.yaxisIndex],o.height/1.6&gt;l&amp;&amp;(v="")));v</span>ar k=<span class="cstat-no" title="statement not covered" >n({},c);<span class="cstat-no" title="statement not covered" ></span>this.barCtx.isHorizontal&amp;&amp;a&lt;0&amp;&amp;("start"===c.textAnchor?k.textAnchor="end":"end"===c.textAnchor&amp;&amp;(k.textAnchor="start")),u.plotDataLabelsText({x:e,y:i,text:v,i:s,j:r,parent:b,dataLabelsConfig:k,alwaysDrawDataLabel:!0,offsetCorrection:!0})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b}</span>}]),t}</span>(),</span>M=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.legendInactiveClass="legend-mouseover-inactive"}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getAllSeriesEls",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")}</span>},{key:"getSeriesByName",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.querySelector("[seriesName='".concat(g.escapeString(t),"']"))}</span>},{key:"isSeriesHidden",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.getSeriesByName(t),</span>i=<span class="cstat-no" title="statement not covered" >parseInt(e.getAttribute("data:realIndex"),10);<span class="cstat-no" title="statement not covered" ></span>return{isHidden:e.classList.contains("apexcharts-series-collapsed"),realIndex:i}}</span>},{key:"addCollapsedClassToSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;</span>function <span class="fstat-no" title="function not covered" >a(</span>i){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++)<span class="cstat-no" title="statement not covered" >i[a].index===e&amp;&amp;t.node.classList.add("apexcharts-series-collapsed")}<span class="cstat-no" title="statement not covered" ></span></span>a(i.globals.collapsedSeries),a(i.globals.ancillaryCollapsedSeries)}</span>},{key:"toggleSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.isSeriesHidden(t);<span class="cstat-no" title="statement not covered" ></span>return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,e.isHidden),e.isHidden}</span>},{key:"showSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.isSeriesHidden(t);<span class="cstat-no" title="statement not covered" ></span>e.isHidden&amp;&amp;this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,!0)}</span>},{key:"hideSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.isSeriesHidden(t);<span class="cstat-no" title="statement not covered" ></span>e.isHidden||this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,!1)}</span>},{key:"resetSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;0&amp;&amp;void 0!==arguments[0])||arguments[0],</span>e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;2&amp;&amp;void 0!==arguments[2])||arguments[2],</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >g.clone(a.globals.initialSeries);<span class="cstat-no" title="statement not covered" ></span>a.globals.previousPaths=[],i?(a.globals.collapsedSeries=[],a.globals.ancillaryCollapsedSeries=[],a.globals.collapsedSeriesIndices=[],a.globals.ancillaryCollapsedSeriesIndices=[]):s=this.emptyCollapsedSeries(s),a.config.series=s,t&amp;&amp;(e&amp;&amp;(a.globals.zoomed=!1,this.ctx.updateHelpers.revertDefaultAxisMinMax()),this.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled))}</span>},{key:"emptyCollapsedSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >e.globals.collapsedSeriesIndices.indexOf(i)&gt;-1&amp;&amp;(t[i].data=[]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>},{key:"toggleSeriesOnHover",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===t.type){var s=<span class="cstat-no" title="statement not covered" >parseInt(e.getAttribute("rel"),10)-1,</span>r=<span class="cstat-no" title="statement not covered" >null,</span>n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>i.globals.axisCharts||"radialBar"===i.config.chart.type?i.globals.axisCharts?(r=i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s,"']")),n=i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s,"']"))):r=i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s+1,"']")):r=i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s+1,"'] path"));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;a.length;o++)<span class="cstat-no" title="statement not covered" >a[o].classList.add(this.legendInactiveClass);<span class="cstat-no" title="statement not covered" >n</span></span>ull!==r&amp;&amp;(i.globals.axisCharts||r.parentNode.classList.remove(this.legendInactiveClass),r.classList.remove(this.legendInactiveClass),null!==n&amp;&amp;n.classList.remove(this.legendInactiveClass))}</span>else <span class="cstat-no" title="statement not covered" >if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >for(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;a.length;l++)<span class="cstat-no" title="statement not covered" >a[l].classList.remove(this.legendInactiveClass)}</span></span></span></span>},{key:"highlightRangeInSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;s.length;e++)<span class="cstat-no" title="statement not covered" >s[e].classList[t](i.legendInactiveClass)}</span></span>;<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===t.type){var n=<span class="cstat-no" title="statement not covered" >parseInt(e.getAttribute("rel"),10)-1;<span class="cstat-no" title="statement not covered" ></span>r("add"),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;s.length;e++){var a=<span class="cstat-no" title="statement not covered" >parseInt(s[e].getAttribute("val"),10);<span class="cstat-no" title="statement not covered" ></span>a&gt;=t.from&amp;&amp;a&lt;=t.to&amp;&amp;s[e].classList.remove(i.legendInactiveClass)}</span>}</span>(a.config.plotOptions.heatmap.colorScale.ranges[n])}</span>else<span class="cstat-no" title="statement not covered" >"mouseout"===t.type&amp;&amp;r("remove")}</span></span>},{key:"getActiveConfigSeriesIndex",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]&amp;&amp;arguments[0],</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e.config.series.length&gt;1)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >e.config.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){var s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(s="bar"===e.config.series[a].type||"column"===e.config.series[a].type),i.data&amp;&amp;i.data.length&gt;0&amp;&amp;!s?a:-1}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s++)<span class="cstat-no" title="statement not covered" >if(-1!==a[s]){<span class="cstat-no" title="statement not covered" >i=a[s];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn i}</span>},{key:"getPreviousPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;</span>function <span class="fstat-no" title="function not covered" >e(</span>e,i,a){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >e[i].childNodes,</span>r=<span class="cstat-no" title="statement not covered" >{type:a,paths:[],realIndex:e[i].getAttribute("data:realIndex")},</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++)<span class="cstat-no" title="statement not covered" >if(s[n].hasAttribute("pathTo")){var o=<span class="cstat-no" title="statement not covered" >s[n].getAttribute("pathTo");<span class="cstat-no" title="statement not covered" ></span>r.paths.push({d:o})}<span class="cstat-no" title="statement not covered" ></span>t</span></span>.globals.previousPaths.push(r)}<span class="cstat-no" title="statement not covered" ></span>t.globals.previousPaths=[];<span class="cstat-no" title="statement not covered" >[</span>"line","area","bar","candlestick","radar"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >for(var a,s=(<span class="cstat-no" title="statement not covered" >a=i,t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a,"-series .apexcharts-series")))</span>,r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;s.length;r++)<span class="cstat-no" title="statement not covered" >e(s,r,i)}</span></span>)),this.handlePrevBubbleScatterPaths("bubble"),this.handlePrevBubbleScatterPaths("scatter");v</span>ar i=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series");<span class="cstat-no" title="statement not covered" ></span>if(i.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(a,"'] rect")),</span>r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++)<span class="cstat-no" title="statement not covered" >r.push({color:s[n].getAttribute("color")});<span class="cstat-no" title="statement not covered" >t</span></span>.globals.previousPaths.push(r)}<span class="cstat-no" title="statement not covered" ></span>t</span></span>.globals.axisCharts||(t.globals.previousPaths=t.globals.series)}</span>},{key:"handlePrevBubbleScatterPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t,"-series .apexcharts-series"));<span class="cstat-no" title="statement not covered" ></span>if(i.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t,"-series .apexcharts-series[data\\:realIndex='").concat(a,"'] circle")),</span>r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++)<span class="cstat-no" title="statement not covered" >r.push({x:s[n].getAttribute("cx"),y:s[n].getAttribute("cy"),r:s[n].getAttribute("r")});<span class="cstat-no" title="statement not covered" >e</span></span>.globals.previousPaths.push(r)}</span>}</span></span>},{key:"clearPreviousPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>t.globals.previousPaths=[],t.globals.allSeriesCollapsed=!1}</span>},{key:"handleNoData",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.config.noData,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >t.globals.svgWidth/2,</span>s=<span class="cstat-no" title="statement not covered" >t.globals.svgHeight/2,</span>r=<span class="cstat-no" title="statement not covered" >"middle";<span class="cstat-no" title="statement not covered" ></span>if(t.globals.noData=!0,t.globals.animationEnded=!0,"left"===e.align?(a=10,r="start"):"right"===e.align&amp;&amp;(a=t.globals.svgWidth-10,r="end"),"top"===e.verticalAlign?s=50:"bottom"===e.verticalAlign&amp;&amp;(s=t.globals.svgHeight-50),a+=e.offsetX,s=s+parseInt(e.style.fontSize,10)+2+e.offsetY,void 0!==e.text&amp;&amp;""!==e.text){var n=<span class="cstat-no" title="statement not covered" >i.drawText({x:a,y:s,text:e.text,textAnchor:r,fontSize:e.style.fontSize,fontFamily:e.style.fontFamily,foreColor:e.style.color,opacity:1,class:"apexcharts-text-nodata"});<span class="cstat-no" title="statement not covered" ></span>t.globals.dom.Paper.add(n)}</span>}</span>},{key:"setNullSeriesToZeroValues",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >if(0===t[i].length)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t[e.globals.maxValsInArrayIndex].length;a++)<span class="cstat-no" title="statement not covered" >t[i].push(0);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn t}</span>},{key:"hasAllSeriesEqualX",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >!0,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.filteredSeriesX(),</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length-1;a++)<span class="cstat-no" title="statement not covered" >if(i[a][0]!==i[a+1][0]){<span class="cstat-no" title="statement not covered" >t=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e.globals.allSeriesHasEqualX=t,t}</span>},{key:"filteredSeriesX",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals.seriesX.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.length&gt;0?t:[]}</span>));<span class="cstat-no" title="statement not covered" ></span>return t}</span>}]),t}</span>(),</span>E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.barCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"initVariables",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.barCtx.series=t,this.barCtx.totalItems=0,this.barCtx.seriesLen=0,this.barCtx.visibleI=-1,this.barCtx.visibleItems=1;<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >if(t[i].length&gt;0&amp;&amp;(this.barCtx.seriesLen=this.barCtx.seriesLen+1,this.barCtx.totalItems+=t[i].length),e.globals.isXNumeric)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t[i].length;a++)<span class="cstat-no" title="statement not covered" >e.globals.seriesX[i][a]&gt;e.globals.minX&amp;&amp;e.globals.seriesX[i][a]&lt;e.globals.maxX&amp;&amp;this.barCtx.visibleItems++;e</span></span>lse <span class="cstat-no" title="statement not covered" >this.barCtx.visibleItems=e.globals.dataPoints;<span class="cstat-no" title="statement not covered" >0</span></span></span>===this.barCtx.seriesLen&amp;&amp;(this.barCtx.seriesLen=1)}</span>},{key:"initialPositions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e,i,a,s,r,n,o,l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >l.globals.dataPoints;<span class="cstat-no" title="statement not covered" ></span>if(this.barCtx.isTimelineBar&amp;&amp;(h=l.globals.labels.length),this.barCtx.isHorizontal)<span class="cstat-no" title="statement not covered" >s=(i=l.globals.gridHeight/h)/this.barCtx.seriesLen,l.globals.isXNumeric&amp;&amp;(s=(i=l.globals.gridHeight/this.barCtx.totalItems)/this.barCtx.seriesLen),s=s*parseInt(this.barCtx.barOptions.barHeight,10)/100,o=this.barCtx.baseLineInvertedY+l.globals.padHorizontal+(this.barCtx.isReversed?l.globals.gridWidth:0)-(this.barCtx.isReversed?2*this.barCtx.baseLineInvertedY:0),e=(i-s*this.barCtx.seriesLen)/2;e</span>lse{<span class="cstat-no" title="statement not covered" >if(a=l.globals.gridWidth/this.barCtx.visibleItems,l.config.xaxis.convertedCatToNumeric&amp;&amp;(a=l.globals.gridWidth/l.globals.dataPoints),r=a/this.barCtx.seriesLen*parseInt(this.barCtx.barOptions.columnWidth,10)/100,l.globals.isXNumeric){var c=<span class="cstat-no" title="statement not covered" >this.barCtx.xRatio;<span class="cstat-no" title="statement not covered" ></span>l.config.xaxis.convertedCatToNumeric&amp;&amp;(c=this.barCtx.initialXRatio),l.globals.minXDiff&amp;&amp;.5!==l.globals.minXDiff&amp;&amp;l.globals.minXDiff/c&gt;0&amp;&amp;(a=l.globals.minXDiff/c),(r=a/this.barCtx.seriesLen*parseInt(this.barCtx.barOptions.columnWidth,10)/100)&lt;1&amp;&amp;(r=1)}<span class="cstat-no" title="statement not covered" ></span>n</span>=l.globals.gridHeight-this.barCtx.baseLineY[this.barCtx.yaxisIndex]-(this.barCtx.isReversed?l.globals.gridHeight:0)+(this.barCtx.isReversed?2*this.barCtx.baseLineY[this.barCtx.yaxisIndex]:0),t=l.globals.padHorizontal+(a-r*this.barCtx.seriesLen)/2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:t,y:e,yDivision:i,xDivision:a,barHeight:s,barWidth:r,zeroH:n,zeroW:o}}</span>},{key:"getPathFillColor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >new L(this.barCtx.ctx),</span>n=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >this.barCtx.barOptions.distributed?i:e;<span class="cstat-no" title="statement not covered" ></span>this.barCtx.barOptions.colors.ranges.length&gt;0&amp;&amp;this.barCtx.barOptions.colors.ranges.map((<span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >t[e][i]&gt;=a.from&amp;&amp;t[e][i]&lt;=a.to&amp;&amp;(n=a.color)}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn s.config.series[e].data[i]&amp;&amp;s.config.series[e].data[i].fillColor&amp;&amp;(n=s.config.series[e].data[i].fillColor),r.fillPath({seriesNumber:this.barCtx.barOptions.distributed?o:a,dataPointIndex:i,color:n,value:t[e][i]})}</span>},{key:"getStrokeWidth",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return void 0===this.barCtx.series[t][e]||null===this.barCtx.series[t][e]?this.barCtx.isNullValue=!0:this.barCtx.isNullValue=!1,s.config.stroke.show&amp;&amp;(this.barCtx.isNullValue||(a=Array.isArray(this.barCtx.strokeWidth)?this.barCtx.strokeWidth[i]:this.barCtx.strokeWidth)),a}</span>},{key:"barBackground",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.bc,</span>i=<span class="cstat-no" title="statement not covered" >t.i,</span>a=<span class="cstat-no" title="statement not covered" >t.x1,</span>s=<span class="cstat-no" title="statement not covered" >t.x2,</span>r=<span class="cstat-no" title="statement not covered" >t.y1,</span>n=<span class="cstat-no" title="statement not covered" >t.y2,</span>o=<span class="cstat-no" title="statement not covered" >t.elSeries,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >new p(this.barCtx.ctx),</span>c=<span class="cstat-no" title="statement not covered" >new M(this.barCtx.ctx).getActiveConfigSeriesIndex();<span class="cstat-no" title="statement not covered" ></span>if(this.barCtx.barOptions.colors.backgroundBarColors.length&gt;0&amp;&amp;c===i){<span class="cstat-no" title="statement not covered" >e&gt;=this.barCtx.barOptions.colors.backgroundBarColors.length&amp;&amp;(e=0);v</span>ar d=<span class="cstat-no" title="statement not covered" >this.barCtx.barOptions.colors.backgroundBarColors[e],</span>g=<span class="cstat-no" title="statement not covered" >h.drawRect(void 0!==a?a:0,void 0!==r?r:0,void 0!==s?s:l.globals.gridWidth,void 0!==n?n:l.globals.gridHeight,this.barCtx.barOptions.colors.backgroundBarRadius,d,this.barCtx.barOptions.colors.backgroundBarOpacity);<span class="cstat-no" title="statement not covered" ></span>o.add(g),g.node.classList.add("apexcharts-backgroundBar")}</span>}</span>},{key:"getColumnPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>i=<span class="cstat-no" title="statement not covered" >t.barXPosition,</span>a=<span class="cstat-no" title="statement not covered" >t.yRatio,</span>s=<span class="cstat-no" title="statement not covered" >t.y1,</span>r=<span class="cstat-no" title="statement not covered" >t.y2,</span>n=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>o=<span class="cstat-no" title="statement not covered" >t.series,</span>l=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>h=<span class="cstat-no" title="statement not covered" >t.i,</span>c=<span class="cstat-no" title="statement not covered" >t.j,</span>d=<span class="cstat-no" title="statement not covered" >t.w,</span>g=<span class="cstat-no" title="statement not covered" >new p(this.barCtx.ctx);<span class="cstat-no" title="statement not covered" ></span>(n=Array.isArray(n)?n[l]:n)||(n=0);v</span>ar u=<span class="cstat-no" title="statement not covered" >{barWidth:e,strokeWidth:n,yRatio:a,barXPosition:i,y1:s,y2:r},</span>f=<span class="cstat-no" title="statement not covered" >this.getRoundedBars(d,u,o,h,c),</span>x=<span class="cstat-no" title="statement not covered" >i,</span>b=<span class="cstat-no" title="statement not covered" >i+e,</span>m=<span class="cstat-no" title="statement not covered" >g.move(x,f.y1),</span>v=<span class="cstat-no" title="statement not covered" >g.move(x,f.y1);<span class="cstat-no" title="statement not covered" ></span>return d.globals.previousPaths.length&gt;0&amp;&amp;(v=this.barCtx.getPreviousPath(l,c,!1)),{pathTo:m=m+g.line(x,f.y2)+f.endingPath+g.line(b-n,f.y2)+g.line(b-n,f.y1)+f.startingPath+"z",pathFrom:v=v+g.line(x,s)+g.line(b-n,s)+g.line(b-n,s)+g.line(b-n,s)+g.line(x,s)}}</span>},{key:"getBarpaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.barYPosition,</span>i=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>a=<span class="cstat-no" title="statement not covered" >t.x1,</span>s=<span class="cstat-no" title="statement not covered" >t.x2,</span>r=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>n=<span class="cstat-no" title="statement not covered" >t.series,</span>o=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>l=<span class="cstat-no" title="statement not covered" >t.i,</span>h=<span class="cstat-no" title="statement not covered" >t.j,</span>c=<span class="cstat-no" title="statement not covered" >t.w,</span>d=<span class="cstat-no" title="statement not covered" >new p(this.barCtx.ctx);<span class="cstat-no" title="statement not covered" ></span>(r=Array.isArray(r)?r[o]:r)||(r=0);v</span>ar g=<span class="cstat-no" title="statement not covered" >{barHeight:i,strokeWidth:r,barYPosition:e,x2:s,x1:a},</span>u=<span class="cstat-no" title="statement not covered" >this.getRoundedBars(c,g,n,l,h),</span>f=<span class="cstat-no" title="statement not covered" >d.move(u.x1,e),</span>x=<span class="cstat-no" title="statement not covered" >d.move(u.x1,e);<span class="cstat-no" title="statement not covered" ></span>c.globals.previousPaths.length&gt;0&amp;&amp;(x=this.barCtx.getPreviousPath(o,h,!1));v</span>ar b=<span class="cstat-no" title="statement not covered" >e,</span>m=<span class="cstat-no" title="statement not covered" >e+i;<span class="cstat-no" title="statement not covered" ></span>return{pathTo:f=f+d.line(u.x2,b)+u.endingPath+d.line(u.x2,m-r)+d.line(u.x1,m-r)+u.startingPath+"z",pathFrom:x=x+d.line(a,b)+d.line(a,m-r)+d.line(a,m-r)+d.line(a,m-r)+d.line(a,b)}}</span>},{key:"getRoundedBars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){var r=<span class="cstat-no" title="statement not covered" >new p(this.barCtx.ctx),</span>n=<span class="cstat-no" title="statement not covered" >Array.isArray(e.strokeWidth)?e.strokeWidth[a]:e.strokeWidth;<span class="cstat-no" title="statement not covered" ></span>if(n||(n=0),this.barCtx.isHorizontal){var o=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >"",</span>h=<span class="cstat-no" title="statement not covered" >e.x2,</span>c=<span class="cstat-no" title="statement not covered" >e.x1;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i[a][s]||null!==i[a][s]){var d=<span class="cstat-no" title="statement not covered" >i[a][s]&lt;0,</span>g=<span class="cstat-no" title="statement not covered" >e.barHeight/2-n;<span class="cstat-no" title="statement not covered" ></span>switch(d&amp;&amp;(g=-e.barHeight/2-n),g&gt;Math.abs(h-c)&amp;&amp;(g=Math.abs(h-c)),"rounded"===this.barCtx.barOptions.endingShape&amp;&amp;(h=e.x2-g/2),"rounded"===this.barCtx.barOptions.startingShape&amp;&amp;(c=e.x1+g/2),this.barCtx.barOptions.endingShape){case"flat":<span class="cstat-no" title="statement not covered" >o=r.line(h,e.barYPosition+e.barHeight-n);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rounded":<span class="cstat-no" title="statement not covered" >o=r.quadraticCurve(h+g,e.barYPosition+(e.barHeight-n)/2,h,e.barYPosition+e.barHeight-n)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(this.barCtx.barOptions.startingShape){case"flat":<span class="cstat-no" title="statement not covered" >l=r.line(c,e.barYPosition+e.barHeight-n);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rounded":<span class="cstat-no" title="statement not covered" >l=r.quadraticCurve(c-g,e.barYPosition+e.barHeight/2,c,e.barYPosition)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{endingPath:o,startingPath:l,x2:h,x1:c}}</span>v</span>ar u=<span class="cstat-no" title="statement not covered" >null,</span>f=<span class="cstat-no" title="statement not covered" >"",</span>x=<span class="cstat-no" title="statement not covered" >e.y2,</span>b=<span class="cstat-no" title="statement not covered" >e.y1;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i[a][s]||null!==i[a][s]){var m=<span class="cstat-no" title="statement not covered" >i[a][s]&lt;0,</span>v=<span class="cstat-no" title="statement not covered" >e.barWidth/2-n;<span class="cstat-no" title="statement not covered" ></span>switch(m&amp;&amp;(v=-e.barWidth/2-n),v&gt;Math.abs(x-b)&amp;&amp;(v=Math.abs(x-b)),"rounded"===this.barCtx.barOptions.endingShape&amp;&amp;(x+=v/2),"rounded"===this.barCtx.barOptions.startingShape&amp;&amp;(b-=v/2),this.barCtx.barOptions.endingShape){case"flat":<span class="cstat-no" title="statement not covered" >u=r.line(e.barXPosition+e.barWidth-n,x);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rounded":<span class="cstat-no" title="statement not covered" >u=r.quadraticCurve(e.barXPosition+(e.barWidth-n)/2,x-v,e.barXPosition+e.barWidth-n,x)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(this.barCtx.barOptions.startingShape){case"flat":<span class="cstat-no" title="statement not covered" >f=r.line(e.barXPosition+e.barWidth-n,b);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rounded":<span class="cstat-no" title="statement not covered" >f=r.quadraticCurve(e.barXPosition+(e.barWidth-n)/2,b+v,e.barXPosition,b)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{endingPath:u,startingPath:f,y2:x,y1:b}}</span>}]),t}</span>(),</span>X=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w;v</span>ar s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.barOptions=s.config.plotOptions.bar,this.isHorizontal=this.barOptions.horizontal,this.strokeWidth=s.config.stroke.width,this.isNullValue=!1,this.isTimelineBar="datetime"===s.config.xaxis.type&amp;&amp;s.globals.seriesRangeBarTimeline.length,this.xyRatios=a,null!==this.xyRatios&amp;&amp;(this.xRatio=a.xRatio,this.initialXRatio=a.initialXRatio,this.yRatio=a.yRatio,this.invertedXRatio=a.invertedXRatio,this.invertedYRatio=a.invertedYRatio,this.baseLineY=a.baseLineY,this.baseLineInvertedY=a.baseLineInvertedY),this.yaxisIndex=0,this.seriesLen=0,this.barHelpers=new E(this)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >new m(this.ctx,i);<span class="cstat-no" title="statement not covered" ></span>t=s.getLogSeries(t),this.series=t,this.yRatio=s.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t);v</span>ar r=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-bar-series apexcharts-plot-series"});<span class="cstat-no" title="statement not covered" ></span>i.config.dataLabels.enabled&amp;&amp;this.totalItems&gt;this.barOptions.dataLabels.maxItems&amp;&amp;console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.length;o++,l++){var h,c,d,u,f=<span class="cstat-no" title="statement not covered" >void 0,</span>x=<span class="cstat-no" title="statement not covered" >void 0,</span>b=<span class="cstat-no" title="statement not covered" >[],</span>v=<span class="cstat-no" title="statement not covered" >[],</span>y=<span class="cstat-no" title="statement not covered" >i.globals.comboCharts?e[o]:o,</span>w=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-series",rel:o+1,seriesName:g.escapeString(i.globals.seriesNames[y]),"data:realIndex":y});<span class="cstat-no" title="statement not covered" ></span>this.ctx.series.addCollapsedClassToSeries(w,y),t[o].length&gt;0&amp;&amp;(this.visibleI=this.visibleI+1);v</span>ar k=<span class="cstat-no" title="statement not covered" >0,</span>A=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.yRatio.length&gt;1&amp;&amp;(this.yaxisIndex=y),this.isReversed=i.config.yaxis[this.yaxisIndex]&amp;&amp;i.config.yaxis[this.yaxisIndex].reversed;v</span>ar S=<span class="cstat-no" title="statement not covered" >this.barHelpers.initialPositions();<span class="cstat-no" title="statement not covered" ></span>x=S.y,k=S.barHeight,c=S.yDivision,u=S.zeroW,f=S.x,A=S.barWidth,h=S.xDivision,d=S.zeroH,this.horizontal||v.push(f+A/2);<span class="cstat-no" title="statement not covered" >f</span>or(var C=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-datalabels","data:realIndex":y}),</span>L=<span class="cstat-no" title="statement not covered" >0;</span>L&lt;i.globals.dataPoints;L++){var P=<span class="cstat-no" title="statement not covered" >this.barHelpers.getStrokeWidth(o,L,y),</span>T=<span class="cstat-no" title="statement not covered" >null,</span>z=<span class="cstat-no" title="statement not covered" >{indexes:{i:o,j:L,realIndex:y,bc:l},x:f,y:x,strokeWidth:P,elSeries:w};<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal?(T=this.drawBarPaths(n({},z,{barHeight:k,zeroW:u,yDivision:c})),A=this.series[o][L]/this.invertedYRatio):(T=this.drawColumnPaths(n({},z,{xDivision:h,barWidth:A,zeroH:d})),k=this.series[o][L]/this.yRatio[this.yaxisIndex]),x=T.y,f=T.x,L&gt;0&amp;&amp;v.push(f+A/2),b.push(x);v</span>ar I=<span class="cstat-no" title="statement not covered" >this.barHelpers.getPathFillColor(t,o,L,y);<span class="cstat-no" title="statement not covered" ></span>this.renderSeries({realIndex:y,pathFill:I,j:L,i:o,pathFrom:T.pathFrom,pathTo:T.pathTo,strokeWidth:P,elSeries:w,x:f,y:x,series:t,barHeight:k,barWidth:A,elDataLabelsWrap:C,visibleSeries:this.visibleI,type:"bar"})}<span class="cstat-no" title="statement not covered" ></span>i</span>.globals.seriesXvalues[y]=v,i.globals.seriesYvalues[y]=b,r.add(w)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>},{key:"renderSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>i=<span class="cstat-no" title="statement not covered" >t.pathFill,</span>a=<span class="cstat-no" title="statement not covered" >t.lineFill,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >t.i,</span>n=<span class="cstat-no" title="statement not covered" >t.pathFrom,</span>o=<span class="cstat-no" title="statement not covered" >t.pathTo,</span>l=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>h=<span class="cstat-no" title="statement not covered" >t.elSeries,</span>c=<span class="cstat-no" title="statement not covered" >t.x,</span>d=<span class="cstat-no" title="statement not covered" >t.y,</span>g=<span class="cstat-no" title="statement not covered" >t.y1,</span>f=<span class="cstat-no" title="statement not covered" >t.y2,</span>x=<span class="cstat-no" title="statement not covered" >t.series,</span>b=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>m=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>v=<span class="cstat-no" title="statement not covered" >t.barYPosition,</span>y=<span class="cstat-no" title="statement not covered" >t.elDataLabelsWrap,</span>w=<span class="cstat-no" title="statement not covered" >t.visibleSeries,</span>k=<span class="cstat-no" title="statement not covered" >t.type,</span>A=<span class="cstat-no" title="statement not covered" >this.w,</span>S=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>a||(a=this.barOptions.distributed?A.globals.stroke.colors[s]:A.globals.stroke.colors[e]),A.config.series[r].data[s]&amp;&amp;A.config.series[r].data[s].strokeColor&amp;&amp;(a=A.config.series[r].data[s].strokeColor),this.isNullValue&amp;&amp;(i="none");v</span>ar C=<span class="cstat-no" title="statement not covered" >s/A.config.chart.animations.animateGradually.delay*(A.config.chart.animations.speed/A.globals.dataPoints)/2.4,</span>L=<span class="cstat-no" title="statement not covered" >S.renderPaths({i:r,j:s,realIndex:e,pathFrom:n,pathTo:o,stroke:a,strokeWidth:l,strokeLineCap:A.config.stroke.lineCap,fill:i,animationDelay:C,initialSpeed:A.config.chart.animations.speed,dataChangeSpeed:A.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-".concat(k,"-area")});<span class="cstat-no" title="statement not covered" ></span>L.attr("clip-path","url(#gridRectMask".concat(A.globals.cuid,")")),void 0!==g&amp;&amp;void 0!==f&amp;&amp;(L.attr("data-range-y1",g),L.attr("data-range-y2",f)),new u(this.ctx).setSelectionFilter(L,e,s),h.add(L);v</span>ar P=<span class="cstat-no" title="statement not covered" >new I(this).handleBarDataLabels({x:c,y:d,y1:g,y2:f,i:r,j:s,series:x,realIndex:e,barHeight:b,barWidth:m,barYPosition:v,renderedPath:L,visibleSeries:w});<span class="cstat-no" title="statement not covered" ></span>return null!==P&amp;&amp;y.add(P),h.add(y),h}</span>},{key:"drawBarPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.indexes,</span>i=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>a=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>s=<span class="cstat-no" title="statement not covered" >t.zeroW,</span>r=<span class="cstat-no" title="statement not covered" >t.x,</span>n=<span class="cstat-no" title="statement not covered" >t.y,</span>o=<span class="cstat-no" title="statement not covered" >t.yDivision,</span>l=<span class="cstat-no" title="statement not covered" >t.elSeries,</span>h=<span class="cstat-no" title="statement not covered" >this.w,</span>c=<span class="cstat-no" title="statement not covered" >e.i,</span>d=<span class="cstat-no" title="statement not covered" >e.j,</span>g=<span class="cstat-no" title="statement not covered" >e.bc;<span class="cstat-no" title="statement not covered" ></span>h.globals.isXNumeric&amp;&amp;(n=(h.globals.seriesX[c][d]-h.globals.minX)/this.invertedXRatio-i);v</span>ar u=<span class="cstat-no" title="statement not covered" >n+i*this.visibleI;<span class="cstat-no" title="statement not covered" ></span>r=void 0===this.series[c][d]||null===this.series[c][d]?s:s+this.series[c][d]/this.invertedYRatio-2*(this.isReversed?this.series[c][d]/this.invertedYRatio:0);v</span>ar f=<span class="cstat-no" title="statement not covered" >this.barHelpers.getBarpaths({barYPosition:u,barHeight:i,x1:s,x2:r,strokeWidth:a,series:this.series,realIndex:e.realIndex,i:c,j:d,w:h});<span class="cstat-no" title="statement not covered" ></span>return h.globals.isXNumeric||(n+=o),this.barHelpers.barBackground({bc:g,i:c,y1:u-i*this.visibleI,y2:i*this.seriesLen,elSeries:l}),{pathTo:f.pathTo,pathFrom:f.pathFrom,x:r,y:n,barYPosition:u}}</span>},{key:"drawColumnPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.indexes,</span>i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=<span class="cstat-no" title="statement not covered" >t.y,</span>s=<span class="cstat-no" title="statement not covered" >t.xDivision,</span>r=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>n=<span class="cstat-no" title="statement not covered" >t.zeroH,</span>o=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>l=<span class="cstat-no" title="statement not covered" >t.elSeries,</span>h=<span class="cstat-no" title="statement not covered" >this.w,</span>c=<span class="cstat-no" title="statement not covered" >e.i,</span>d=<span class="cstat-no" title="statement not covered" >e.j,</span>g=<span class="cstat-no" title="statement not covered" >e.bc;<span class="cstat-no" title="statement not covered" ></span>if(h.globals.isXNumeric){var u=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>h.globals.seriesX[c].length||(u=h.globals.maxValsInArrayIndex),i=(h.globals.seriesX[u][d]-h.globals.minX)/this.xRatio-r*this.seriesLen/2}</span>v</span>ar f=<span class="cstat-no" title="statement not covered" >i+r*this.visibleI;<span class="cstat-no" title="statement not covered" ></span>a=void 0===this.series[c][d]||null===this.series[c][d]?n:n-this.series[c][d]/this.yRatio[this.yaxisIndex]+2*(this.isReversed?this.series[c][d]/this.yRatio[this.yaxisIndex]:0);v</span>ar p=<span class="cstat-no" title="statement not covered" >this.barHelpers.getColumnPaths({barXPosition:f,barWidth:r,y1:n,y2:a,strokeWidth:o,series:this.series,realIndex:e.realIndex,i:c,j:d,w:h});<span class="cstat-no" title="statement not covered" ></span>return h.globals.isXNumeric||(i+=s),this.barHelpers.barBackground({bc:g,i:c,x1:f-o/2-r*this.visibleI,x2:r*this.seriesLen+o/2,elSeries:l}),{pathTo:p.pathTo,pathFrom:p.pathFrom,x:i,y:a,barXPosition:f}}</span>},{key:"getPreviousPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i,a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.globals.previousPaths.length;s++){var r=<span class="cstat-no" title="statement not covered" >a.globals.previousPaths[s];<span class="cstat-no" title="statement not covered" ></span>r.paths&amp;&amp;r.paths.length&gt;0&amp;&amp;parseInt(r.realIndex,10)===parseInt(t,10)&amp;&amp;void 0!==a.globals.previousPaths[s].paths[e]&amp;&amp;(i=a.globals.previousPaths[s].paths[e].d)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}]),t}</span>(),</span>Y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.months31=[1,3,5,7,8,10,12],this.months30=[2,4,6,9,11],this.daysCntOfYear=[0,31,59,90,120,151,181,212,243,273,304,334]}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"isValidDate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!isNaN(this.parseDate(t))}</span>},{key:"getTimeStamp",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Date.parse(t)?this.w.config.xaxis.labels.datetimeUTC?new Date(new Date(t).toISOString().substr(0,25)).getTime():new Date(t).getTime():t}</span>},{key:"getDate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.w.config.xaxis.labels.datetimeUTC?new Date(new Date(t).toUTCString()):new Date(t)}</span>},{key:"parseDate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Date.parse(t);<span class="cstat-no" title="statement not covered" ></span>if(!isNaN(e))<span class="cstat-no" title="statement not covered" >return this.getTimeStamp(t);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Date.parse(t.replace(/-/g,"/").replace(/[a-z]+/gi," "));<span class="cstat-no" title="statement not covered" ></span>return i=this.getTimeStamp(i)}</span>},{key:"formatDate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w.globals.locale,</span>a=<span class="cstat-no" title="statement not covered" >this.w.config.xaxis.labels.datetimeUTC,</span>s=<span class="cstat-no" title="statement not covered" >["\0"].concat(d(i.months)),</span>r=<span class="cstat-no" title="statement not covered" >["\x01"].concat(d(i.shortMonths)),</span>n=<span class="cstat-no" title="statement not covered" >["\x02"].concat(d(i.days)),</span>o=<span class="cstat-no" title="statement not covered" >["\x03"].concat(d(i.shortDays));</span>function <span class="fstat-no" title="function not covered" >l(</span>t,e){var i=<span class="cstat-no" title="statement not covered" >t+"";<span class="cstat-no" title="statement not covered" ></span>for(e=e||2;i.length&lt;e;)<span class="cstat-no" title="statement not covered" >i="0"+i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>var h=<span class="cstat-no" title="statement not covered" >a?t.getUTCFullYear():t.getFullYear();<span class="cstat-no" title="statement not covered" ></span>e=(e=(e=e.replace(/(^|[^\\])yyyy+/g,"$1"+h)).replace(/(^|[^\\])yy/g,"$1"+h.toString().substr(2,2))).replace(/(^|[^\\])y/g,"$1"+h);v</span>ar c=<span class="cstat-no" title="statement not covered" >(a?t.getUTCMonth():t.getMonth())+1;<span class="cstat-no" title="statement not covered" ></span>e=(e=(e=(e=e.replace(/(^|[^\\])MMMM+/g,"$1"+s[0])).replace(/(^|[^\\])MMM/g,"$1"+r[0])).replace(/(^|[^\\])MM/g,"$1"+l(c))).replace(/(^|[^\\])M/g,"$1"+c);v</span>ar g=<span class="cstat-no" title="statement not covered" >a?t.getUTCDate():t.getDate();<span class="cstat-no" title="statement not covered" ></span>e=(e=(e=(e=e.replace(/(^|[^\\])dddd+/g,"$1"+n[0])).replace(/(^|[^\\])ddd/g,"$1"+o[0])).replace(/(^|[^\\])dd/g,"$1"+l(g))).replace(/(^|[^\\])d/g,"$1"+g);v</span>ar u=<span class="cstat-no" title="statement not covered" >a?t.getUTCHours():t.getHours(),</span>f=<span class="cstat-no" title="statement not covered" >u&gt;12?u-12:0===u?12:u;<span class="cstat-no" title="statement not covered" ></span>e=(e=(e=(e=e.replace(/(^|[^\\])HH+/g,"$1"+l(u))).replace(/(^|[^\\])H/g,"$1"+u)).replace(/(^|[^\\])hh+/g,"$1"+l(f))).replace(/(^|[^\\])h/g,"$1"+f);v</span>ar p=<span class="cstat-no" title="statement not covered" >a?t.getUTCMinutes():t.getMinutes();<span class="cstat-no" title="statement not covered" ></span>e=(e=e.replace(/(^|[^\\])mm+/g,"$1"+l(p))).replace(/(^|[^\\])m/g,"$1"+p);v</span>ar x=<span class="cstat-no" title="statement not covered" >a?t.getUTCSeconds():t.getSeconds();<span class="cstat-no" title="statement not covered" ></span>e=(e=e.replace(/(^|[^\\])ss+/g,"$1"+l(x))).replace(/(^|[^\\])s/g,"$1"+x);v</span>ar b=<span class="cstat-no" title="statement not covered" >a?t.getUTCMilliseconds():t.getMilliseconds();<span class="cstat-no" title="statement not covered" ></span>e=e.replace(/(^|[^\\])fff+/g,"$1"+l(b,3)),b=Math.round(b/10),e=e.replace(/(^|[^\\])ff/g,"$1"+l(b)),b=Math.round(b/10);v</span>ar m=<span class="cstat-no" title="statement not covered" >u&lt;12?"AM":"PM";<span class="cstat-no" title="statement not covered" ></span>e=(e=(e=e.replace(/(^|[^\\])f/g,"$1"+b)).replace(/(^|[^\\])TT+/g,"$1"+m)).replace(/(^|[^\\])T/g,"$1"+m.charAt(0));v</span>ar v=<span class="cstat-no" title="statement not covered" >m.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>e=(e=e.replace(/(^|[^\\])tt+/g,"$1"+v)).replace(/(^|[^\\])t/g,"$1"+v.charAt(0));v</span>ar y=<span class="cstat-no" title="statement not covered" >-t.getTimezoneOffset(),</span>w=<span class="cstat-no" title="statement not covered" >a||!y?"Z":y&gt;0?"+":"-";<span class="cstat-no" title="statement not covered" ></span>if(!a){var k=<span class="cstat-no" title="statement not covered" >(y=Math.abs(y))%60;<span class="cstat-no" title="statement not covered" ></span>w+=l(Math.floor(y/60))+":"+l(k)}<span class="cstat-no" title="statement not covered" ></span>e</span>=e.replace(/(^|[^\\])K/g,"$1"+w);v</span>ar A=<span class="cstat-no" title="statement not covered" >(a?t.getUTCDay():t.getDay())+1;<span class="cstat-no" title="statement not covered" ></span>return e=(e=(e=(e=(e=e.replace(new RegExp(n[0],"g"),n[A])).replace(new RegExp(o[0],"g"),o[A])).replace(new RegExp(s[0],"g"),s[c])).replace(new RegExp(r[0],"g"),r[c])).replace(/\\(.)/g,"$1")}</span>},{key:"getTimeUnitsfromTimestamp",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>void 0!==a.config.xaxis.min&amp;&amp;(t=a.config.xaxis.min),void 0!==a.config.xaxis.max&amp;&amp;(e=a.config.xaxis.max);v</span>ar s=<span class="cstat-no" title="statement not covered" >this.getDate(t),</span>r=<span class="cstat-no" title="statement not covered" >this.getDate(e),</span>n=<span class="cstat-no" title="statement not covered" >this.formatDate(s,"yyyy MM dd HH mm").split(" "),</span>o=<span class="cstat-no" title="statement not covered" >this.formatDate(r,"yyyy MM dd HH mm").split(" ");<span class="cstat-no" title="statement not covered" ></span>return{minMinute:parseInt(n[4],10),maxMinute:parseInt(o[4],10),minHour:parseInt(n[3],10),maxHour:parseInt(o[3],10),minDate:parseInt(n[2],10),maxDate:parseInt(o[2],10),minMonth:parseInt(n[1],10)-1,maxMonth:parseInt(o[1],10)-1,minYear:parseInt(n[0],10),maxYear:parseInt(o[0],10)}}</span>},{key:"isLeapYear",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t%4==0&amp;&amp;t%100!=0||t%400==0}</span>},{key:"calculcateLastDaysOfMonth",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.determineDaysOfMonths(t,e)-i}</span>},{key:"determineDaysOfYear",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >365;<span class="cstat-no" title="statement not covered" ></span>return this.isLeapYear(t)&amp;&amp;(e=366),e}</span>},{key:"determineRemainingDaysOfYear",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.daysCntOfYear[e]+i;<span class="cstat-no" title="statement not covered" ></span>return e&gt;1&amp;&amp;this.isLeapYear()&amp;&amp;a++,a}</span>},{key:"determineDaysOfMonths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >30;<span class="cstat-no" title="statement not covered" ></span>switch(t=g.monthMod(t),!0){case this.months30.indexOf(t)&gt;-1:<span class="cstat-no" title="statement not covered" >2===t&amp;&amp;(i=this.isLeapYear(e)?29:28);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase this.months31.indexOf(t)&gt;-1:default:<span class="cstat-no" title="statement not covered" >i=31}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}]),t}</span>(),</span>F=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >i(</span>){<span class="cstat-no" title="statement not covered" >return e(this,i),c(this,l(i).apply(this,arguments))}<span class="cstat-no" title="statement not covered" ></span>return o(i,t),a(i,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.rangeBarOptions=this.w.config.plotOptions.rangeBar,this.series=t,this.seriesRangeStart=i.globals.seriesRangeStart,this.seriesRangeEnd=i.globals.seriesRangeEnd,this.barHelpers.initVariables(t);<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-rangebar-series apexcharts-plot-series"}),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++){var o,l,h,c=<span class="cstat-no" title="statement not covered" >void 0,</span>d=<span class="cstat-no" title="statement not covered" >void 0,</span>u=<span class="cstat-no" title="statement not covered" >void 0,</span>f=<span class="cstat-no" title="statement not covered" >i.globals.comboCharts?e[r]:r,</span>x=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-series",seriesName:g.escapeString(i.globals.seriesNames[f]),rel:r+1,"data:realIndex":f});<span class="cstat-no" title="statement not covered" ></span>t[r].length&gt;0&amp;&amp;(this.visibleI=this.visibleI+1);v</span>ar b=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.yRatio.length&gt;1&amp;&amp;(this.yaxisIndex=f);v</span>ar v=<span class="cstat-no" title="statement not covered" >this.barHelpers.initialPositions();<span class="cstat-no" title="statement not covered" ></span>d=v.y,h=v.zeroW,c=v.x,m=v.barWidth,o=v.xDivision,l=v.zeroH;<span class="cstat-no" title="statement not covered" >f</span>or(var y=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-datalabels","data:realIndex":f}),</span>w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;i.globals.dataPoints;w++){var k=<span class="cstat-no" title="statement not covered" >this.barHelpers.getStrokeWidth(r,w,f),</span>A=<span class="cstat-no" title="statement not covered" >this.seriesRangeStart[r][w],</span>S=<span class="cstat-no" title="statement not covered" >this.seriesRangeEnd[r][w],</span>C=<span class="cstat-no" title="statement not covered" >null,</span>L=<span class="cstat-no" title="statement not covered" >null,</span>P=<span class="cstat-no" title="statement not covered" >{x:c,y:d,strokeWidth:k,elSeries:x};<span class="cstat-no" title="statement not covered" ></span>if(u=v.yDivision,b=v.barHeight,this.isHorizontal){<span class="cstat-no" title="statement not covered" >L=d+b*this.visibleI;v</span>ar T=<span class="cstat-no" title="statement not covered" >(u-b*this.seriesLen)/2;<span class="cstat-no" title="statement not covered" ></span>if(void 0===i.config.series[r].data[w])<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.isTimelineBar&amp;&amp;i.config.series[r].data[w].x){var z=<span class="cstat-no" title="statement not covered" >this.detectOverlappingBars({i:r,j:w,barYPosition:L,srty:T,barHeight:b,yDivision:u,initPositions:v});<span class="cstat-no" title="statement not covered" ></span>b=z.barHeight,L=z.barYPosition}<span class="cstat-no" title="statement not covered" ></span>m</span>=(C=this.drawRangeBarPaths(n({indexes:{i:r,j:w,realIndex:f},barHeight:b,barYPosition:L,zeroW:h,yDivision:u,y1:A,y2:S},P))).barWidth}</span>else <span class="cstat-no" title="statement not covered" >b=(C=this.drawRangeColumnPaths(n({indexes:{i:r,j:w,realIndex:f},zeroH:l,barWidth:m,xDivision:o},P))).barHeight;<span class="cstat-no" title="statement not covered" >d</span></span>=C.y,c=C.x;v</span>ar I=<span class="cstat-no" title="statement not covered" >this.barHelpers.getPathFillColor(t,r,w,f),</span>M=<span class="cstat-no" title="statement not covered" >i.globals.stroke.colors[f];<span class="cstat-no" title="statement not covered" ></span>this.renderSeries({realIndex:f,pathFill:I,lineFill:M,j:w,i:r,x:c,y:d,y1:A,y2:S,pathFrom:C.pathFrom,pathTo:C.pathTo,strokeWidth:k,elSeries:x,series:t,barHeight:b,barYPosition:L,barWidth:m,elDataLabelsWrap:y,visibleSeries:this.visibleI,type:"rangebar"})}<span class="cstat-no" title="statement not covered" ></span>s</span>.add(x)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>},{key:"detectOverlappingBars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.i,</span>i=<span class="cstat-no" title="statement not covered" >t.j,</span>a=<span class="cstat-no" title="statement not covered" >t.barYPosition,</span>s=<span class="cstat-no" title="statement not covered" >t.srty,</span>r=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>n=<span class="cstat-no" title="statement not covered" >t.yDivision,</span>o=<span class="cstat-no" title="statement not covered" >t.initPositions,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >l.config.series[e].data[i].rangeName,</span>d=<span class="cstat-no" title="statement not covered" >l.config.series[e].data[i].x,</span>g=<span class="cstat-no" title="statement not covered" >l.globals.labels.indexOf(d),</span>u=<span class="cstat-no" title="statement not covered" >l.globals.seriesRangeBarTimeline[e].findIndex((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.x===d&amp;&amp;t.overlaps.length&gt;0}</span>));<span class="cstat-no" title="statement not covered" ></span>return a=s+r*this.visibleI+n*g,u&gt;-1&amp;&amp;!l.config.plotOptions.bar.rangeBarOverlap&amp;&amp;(h=l.globals.seriesRangeBarTimeline[e][u].overlaps).indexOf(c)&gt;-1&amp;&amp;(a=(r=o.barHeight/h.length)*this.visibleI+n*(100-parseInt(this.barOptions.barHeight,10))/100/2+r*(this.visibleI+h.indexOf(c))+n*g),{barYPosition:a,barHeight:r}}</span>},{key:"drawRangeColumnPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.indexes,</span>i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=(<span class="cstat-no" title="statement not covered" >t.strokeWidth,t.xDivision)</span>,s=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>r=<span class="cstat-no" title="statement not covered" >t.zeroH,</span>n=<span class="cstat-no" title="statement not covered" >this.w,</span>o=<span class="cstat-no" title="statement not covered" >e.i,</span>l=<span class="cstat-no" title="statement not covered" >e.j,</span>h=<span class="cstat-no" title="statement not covered" >this.yRatio[this.yaxisIndex],</span>c=<span class="cstat-no" title="statement not covered" >e.realIndex,</span>d=<span class="cstat-no" title="statement not covered" >this.getRangeValue(c,l),</span>g=<span class="cstat-no" title="statement not covered" >Math.min(d.start,d.end),</span>u=<span class="cstat-no" title="statement not covered" >Math.max(d.start,d.end);<span class="cstat-no" title="statement not covered" ></span>n.globals.isXNumeric&amp;&amp;(i=(n.globals.seriesX[o][l]-n.globals.minX)/this.xRatio-s/2);v</span>ar f=<span class="cstat-no" title="statement not covered" >i+s*this.visibleI;<span class="cstat-no" title="statement not covered" ></span>void 0===this.series[o][l]||null===this.series[o][l]?g=r:(g=r-g/h,u=r-u/h);v</span>ar p=<span class="cstat-no" title="statement not covered" >Math.abs(u-g),</span>x=<span class="cstat-no" title="statement not covered" >this.barHelpers.getColumnPaths({barXPosition:f,barWidth:s,y1:g,y2:u,strokeWidth:this.strokeWidth,series:this.seriesRangeEnd,i:c,j:l,w:n});<span class="cstat-no" title="statement not covered" ></span>return n.globals.isXNumeric||(i+=a),{pathTo:x.pathTo,pathFrom:x.pathFrom,barHeight:p,x:i,y:u,barXPosition:f}}</span>},{key:"drawRangeBarPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.indexes,</span>i=<span class="cstat-no" title="statement not covered" >t.y,</span>a=<span class="cstat-no" title="statement not covered" >t.y1,</span>s=<span class="cstat-no" title="statement not covered" >t.y2,</span>r=<span class="cstat-no" title="statement not covered" >t.yDivision,</span>n=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>o=<span class="cstat-no" title="statement not covered" >t.barYPosition,</span>l=<span class="cstat-no" title="statement not covered" >t.zeroW,</span>h=<span class="cstat-no" title="statement not covered" >this.w,</span>c=<span class="cstat-no" title="statement not covered" >l+a/this.invertedYRatio,</span>d=<span class="cstat-no" title="statement not covered" >l+s/this.invertedYRatio,</span>g=<span class="cstat-no" title="statement not covered" >Math.abs(d-c),</span>u=<span class="cstat-no" title="statement not covered" >this.barHelpers.getBarpaths({barYPosition:o,barHeight:n,x1:c,x2:d,strokeWidth:this.strokeWidth,series:this.seriesRangeEnd,i:e.realIndex,j:e.j,w:h});<span class="cstat-no" title="statement not covered" ></span>return h.globals.isXNumeric||(i+=r),{pathTo:u.pathTo,pathFrom:u.pathFrom,barWidth:g,x:d,y:i}}</span>},{key:"getRangeValue",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return{start:i.globals.seriesRangeStart[t][e],end:i.globals.seriesRangeEnd[t][e]}}</span>},{key:"getTooltipValues",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.ctx,</span>i=<span class="cstat-no" title="statement not covered" >t.seriesIndex,</span>a=<span class="cstat-no" title="statement not covered" >t.dataPointIndex,</span>s=<span class="cstat-no" title="statement not covered" >t.y1,</span>r=<span class="cstat-no" title="statement not covered" >t.y2,</span>n=<span class="cstat-no" title="statement not covered" >t.w,</span>o=<span class="cstat-no" title="statement not covered" >n.globals.seriesRangeStart[i][a],</span>l=<span class="cstat-no" title="statement not covered" >n.globals.seriesRangeEnd[i][a],</span>h=<span class="cstat-no" title="statement not covered" >n.globals.labels[a],</span>c=<span class="cstat-no" title="statement not covered" >n.config.series[i].name,</span>d=<span class="cstat-no" title="statement not covered" >n.config.tooltip.y.formatter,</span>g=<span class="cstat-no" title="statement not covered" >n.config.tooltip.y.title.formatter,</span>u=<span class="cstat-no" title="statement not covered" >{w:n,seriesIndex:i,dataPointIndex:a};<span class="cstat-no" title="statement not covered" ></span>"function"==typeof g&amp;&amp;(c=g(c,u)),s&amp;&amp;r&amp;&amp;(o=s,l=r,n.config.series[i].data[a].x&amp;&amp;(h=n.config.series[i].data[a].x+":"),"function"==typeof d&amp;&amp;(h=d(h,u)));v</span>ar f=<span class="cstat-no" title="statement not covered" >"",</span>p=<span class="cstat-no" title="statement not covered" >"",</span>x=<span class="cstat-no" title="statement not covered" >n.globals.colors[i];<span class="cstat-no" title="statement not covered" ></span>if(void 0===n.config.tooltip.x.formatter)<span class="cstat-no" title="statement not covered" >if("datetime"===n.config.xaxis.type){var b=<span class="cstat-no" title="statement not covered" >new Y(e);<span class="cstat-no" title="statement not covered" ></span>f=b.formatDate(b.getDate(o),n.config.tooltip.x.format),p=b.formatDate(b.getDate(l),n.config.tooltip.x.format)}</span>else <span class="cstat-no" title="statement not covered" >f=o,p=l;e</span></span>lse <span class="cstat-no" title="statement not covered" >f=n.config.tooltip.x.formatter(o),p=n.config.tooltip.x.formatter(l);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{start:o,end:l,startVal:f,endVal:p,ylabel:h,color:x,seriesName:c}}</span>},{key:"buildCustomTooltipHTML",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.color,</span>i=<span class="cstat-no" title="statement not covered" >t.seriesName;<span class="cstat-no" title="statement not covered" ></span>return'&lt;div class="apexcharts-tooltip-rangebar"&gt;&lt;div&gt; &lt;span class="series-name" style="color: '+e+'"&gt;'+(i||"")+'&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span class="category"&gt;'+t.ylabel+' &lt;/span&gt; &lt;span class="value start-value"&gt;'+t.start+'&lt;/span&gt; &lt;span class="separator"&gt;-&lt;/span&gt; &lt;span class="value end-value"&gt;'+t.end+"&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;"}</span>}]),i}</span>(X),</span>R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.opts=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"line",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{chart:{animations:{easing:"swing"}},dataLabels:{enabled:!1},stroke:{width:5,curve:"straight"},markers:{size:0,hover:{sizeOffset:6}},xaxis:{crosshairs:{width:1}}}}</span>},{key:"sparkline",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.opts.yaxis[0].show=!1,this.opts.yaxis[0].title.text="",this.opts.yaxis[0].axisBorder.show=!1,this.opts.yaxis[0].axisTicks.show=!1,this.opts.yaxis[0].floating=!0;<span class="cstat-no" title="statement not covered" >r</span>eturn g.extend(t,{grid:{show:!1,padding:{left:0,right:0,top:0,bottom:0}},legend:{show:!1},xaxis:{labels:{show:!1},tooltip:{enabled:!1},axisBorder:{show:!1},axisTicks:{show:!1}},chart:{toolbar:{show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!1}})}</span>},{key:"bar",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{chart:{stacked:!1,animations:{easing:"swing"}},plotOptions:{bar:{dataLabels:{position:"center"}}},dataLabels:{style:{colors:["#fff"]},background:{enabled:!1}},stroke:{width:0,lineCap:"square"},fill:{opacity:.85},legend:{markers:{shape:"square",radius:2,size:8}},tooltip:{shared:!1},xaxis:{tooltip:{enabled:!1},tickPlacement:"between",crosshairs:{width:"barWidth",position:"back",fill:{type:"gradient"},dropShadow:{enabled:!1},stroke:{width:0}}}}}</span>},{key:"candlestick",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stroke:{width:1,colors:["#333"]},fill:{opacity:1},dataLabels:{enabled:!1},tooltip:{shared:!0,custom:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.seriesIndex,</span>i=<span class="cstat-no" title="statement not covered" >t.dataPointIndex,</span>a=<span class="cstat-no" title="statement not covered" >t.w;<span class="cstat-no" title="statement not covered" ></span>return'&lt;div class="apexcharts-tooltip-candlestick"&gt;&lt;div&gt;Open: &lt;span class="value"&gt;'+a.globals.seriesCandleO[e][i]+'&lt;/span&gt;&lt;/div&gt;&lt;div&gt;High: &lt;span class="value"&gt;'+a.globals.seriesCandleH[e][i]+'&lt;/span&gt;&lt;/div&gt;&lt;div&gt;Low: &lt;span class="value"&gt;'+a.globals.seriesCandleL[e][i]+'&lt;/span&gt;&lt;/div&gt;&lt;div&gt;Close: &lt;span class="value"&gt;'+a.globals.seriesCandleC[e][i]+"&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;"}</span>},states:{active:{filter:{type:"none"}}},xaxis:{crosshairs:{width:1}}}}</span>},{key:"rangeBar",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stroke:{width:0,lineCap:"square"},plotOptions:{bar:{dataLabels:{position:"center"}}},dataLabels:{enabled:!1,formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e.ctx;v</span>ar i=<span class="cstat-no" title="statement not covered" >e.seriesIndex,</span>a=<span class="cstat-no" title="statement not covered" >e.dataPointIndex,</span>s=<span class="cstat-no" title="statement not covered" >e.w,</span>r=<span class="cstat-no" title="statement not covered" >s.globals.seriesRangeStart[i][a];<span class="cstat-no" title="statement not covered" ></span>return s.globals.seriesRangeEnd[i][a]-r}</span>,background:{enabled:!1},style:{colors:["#fff"]}},tooltip:{shared:!1,followCursor:!0,custom:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.w.config.plotOptions&amp;&amp;t.w.config.plotOptions.bar&amp;&amp;t.w.config.plotOptions.bar.horizontal?<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new F(t.ctx,null),</span>i=<span class="cstat-no" title="statement not covered" >e.getTooltipValues(t),</span>a=<span class="cstat-no" title="statement not covered" >i.color,</span>s=<span class="cstat-no" title="statement not covered" >i.seriesName,</span>r=<span class="cstat-no" title="statement not covered" >i.ylabel,</span>n=<span class="cstat-no" title="statement not covered" >i.startVal,</span>o=<span class="cstat-no" title="statement not covered" >i.endVal;<span class="cstat-no" title="statement not covered" ></span>return e.buildCustomTooltipHTML({color:a,seriesName:s,ylabel:r,start:n,end:o})}</span>(t):<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new F(t.ctx,null),</span>i=<span class="cstat-no" title="statement not covered" >e.getTooltipValues(t),</span>a=<span class="cstat-no" title="statement not covered" >i.color,</span>s=<span class="cstat-no" title="statement not covered" >i.seriesName,</span>r=<span class="cstat-no" title="statement not covered" >i.ylabel,</span>n=<span class="cstat-no" title="statement not covered" >i.start,</span>o=<span class="cstat-no" title="statement not covered" >i.end;<span class="cstat-no" title="statement not covered" ></span>return e.buildCustomTooltipHTML({color:a,seriesName:s,ylabel:r,start:n,end:o})}</span>(t)}</span>},xaxis:{tickPlacement:"between",tooltip:{enabled:!1},crosshairs:{stroke:{width:0}}}}}</span>},{key:"area",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stroke:{width:4},fill:{type:"gradient",gradient:{inverseColors:!1,shade:"light",type:"vertical",opacityFrom:.65,opacityTo:.5,stops:[0,100,100]}},markers:{size:0,hover:{sizeOffset:6}},tooltip:{followCursor:!1}}}</span>},{key:"brush",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return g.extend(t,{chart:{toolbar:{autoSelected:"selection",show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!1},stroke:{width:1},tooltip:{enabled:!1},xaxis:{tooltip:{enabled:!1}}})}</span>},{key:"stacked100",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.dataLabels=t.dataLabels||{},t.dataLabels.formatter=t.dataLabels.formatter||void 0;v</span>ar e=<span class="cstat-no" title="statement not covered" >t.dataLabels.formatter;<span class="cstat-no" title="statement not covered" ></span>return t.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >t.yaxis[i].min=0,t.yaxis[i].max=100}</span>)),"bar"===t.chart.type&amp;&amp;(t.dataLabels.formatter=e||<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"number"==typeof t&amp;&amp;t?t.toFixed(0)+"%":t}</span>),t}</span>},{key:"convertCatToNumeric",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.xaxis.convertedCatToNumeric=!0,t}</span>},{key:"convertCatToNumericXaxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t.xaxis.type="numeric",t.xaxis.labels=t.xaxis.labels||{},t.xaxis.labels.formatter=t.xaxis.labels.formatter||<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return g.isNumber(t)?Math.floor(t):t}</span>;v</span>ar a=<span class="cstat-no" title="statement not covered" >t.xaxis.labels.formatter,</span>s=<span class="cstat-no" title="statement not covered" >t.xaxis.categories&amp;&amp;t.xaxis.categories.length?t.xaxis.categories:t.labels;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;i.length&amp;&amp;(s=i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toString()}</span>))),s&amp;&amp;s.length&amp;&amp;(t.xaxis.labels.formatter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return g.isNumber(t)?a(s[Math.floor(t)-1]):a(t)}</span>),t.xaxis.categories=[],t.labels=[],t.xaxis.tickAmount=t.xaxis.tickAmount||"dataPoints",t}</span>},{key:"bubble",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{dataLabels:{style:{colors:["#fff"]}},tooltip:{shared:!1,intersect:!0},xaxis:{crosshairs:{width:0}},fill:{type:"solid",gradient:{shade:"light",inverse:!0,shadeIntensity:.55,opacityFrom:.4,opacityTo:.8}}}}</span>},{key:"scatter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{dataLabels:{enabled:!1},tooltip:{shared:!1,intersect:!0},markers:{size:6,strokeWidth:1,hover:{sizeOffset:2}}}}</span>},{key:"heatmap",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{chart:{stacked:!1},fill:{opacity:1},dataLabels:{style:{colors:["#fff"]}},stroke:{colors:["#fff"]},tooltip:{followCursor:!0,marker:{show:!1},x:{show:!1}},legend:{position:"top",markers:{shape:"square",size:10,offsetY:2}},grid:{padding:{right:20}}}}</span>},{key:"pie",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{chart:{toolbar:{show:!1}},plotOptions:{pie:{donut:{labels:{show:!1}}}},dataLabels:{formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toFixed(1)+"%"}</span>,style:{colors:["#fff"]},dropShadow:{enabled:!0}},stroke:{colors:["#fff"]},fill:{opacity:1,gradient:{shade:"light",stops:[0,100]}},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"}}}</span>},{key:"donut",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{chart:{toolbar:{show:!1}},dataLabels:{formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toFixed(1)+"%"}</span>,style:{colors:["#fff"]},dropShadow:{enabled:!0}},stroke:{colors:["#fff"]},fill:{opacity:1,gradient:{shade:"light",shadeIntensity:.35,stops:[80,100],opacityFrom:1,opacityTo:1}},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"}}}</span>},{key:"polarArea",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.opts.yaxis[0].tickAmount=this.opts.yaxis[0].tickAmount?this.opts.yaxis[0].tickAmount:6,{chart:{toolbar:{show:!1}},dataLabels:{formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toFixed(1)+"%"}</span>,enabled:!1},stroke:{show:!0,width:2},fill:{opacity:.7},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"}}}</span>},{key:"radar",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.opts.yaxis[0].labels.offsetY=this.opts.yaxis[0].labels.offsetY?this.opts.yaxis[0].labels.offsetY:6,{dataLabels:{enabled:!1,style:{fontSize:"11px"}},stroke:{width:2},markers:{size:3,strokeWidth:1,strokeOpacity:1},fill:{opacity:.2},tooltip:{shared:!1,intersect:!0,followCursor:!0},grid:{show:!1},xaxis:{labels:{formatter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>,style:{colors:["#a8a8a8"],fontSize:"11px"}},tooltip:{enabled:!1},crosshairs:{show:!1}}}}</span>},{key:"radialBar",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{chart:{animations:{dynamicAnimation:{enabled:!0,speed:800}},toolbar:{show:!1}},fill:{gradient:{shade:"dark",shadeIntensity:.4,inverseColors:!1,type:"diagonal2",opacityFrom:1,opacityTo:1,stops:[70,98,100]}},legend:{show:!1,position:"right"},tooltip:{enabled:!1,fillSeriesColor:!0}}}</span>}]),t}</span>(),</span>D=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >i(</span>t){<span class="cstat-no" title="statement not covered" >e(this,i),this.opts=t}<span class="cstat-no" title="statement not covered" ></span>return a(i,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >e.responsiveOverride,</span>a=<span class="cstat-no" title="statement not covered" >this.opts,</span>s=<span class="cstat-no" title="statement not covered" >new S,</span>r=<span class="cstat-no" title="statement not covered" >new R(a);<span class="cstat-no" title="statement not covered" ></span>this.chartType=a.chart.type,"histogram"===this.chartType&amp;&amp;(a.chart.type="bar",a=g.extend({plotOptions:{bar:{columnWidth:"99.99%"}}},a)),a=this.extendYAxis(a),a=this.extendAnnotations(a);v</span>ar n=<span class="cstat-no" title="statement not covered" >s.init(),</span>o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;"object"===t(a)){var l=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>l=-1!==["line","area","bar","candlestick","rangeBar","histogram","bubble","scatter","heatmap","pie","polarArea","donut","radar","radialBar"].indexOf(a.chart.type)?r[a.chart.type]():r.line(),a.chart.brush&amp;&amp;a.chart.brush.enabled&amp;&amp;(l=r.brush(l)),a.chart.stacked&amp;&amp;"100%"===a.chart.stackType&amp;&amp;(a=r.stacked100(a)),this.checkForDarkTheme(window.Apex),this.checkForDarkTheme(a),a.xaxis=a.xaxis||window.Apex.xaxis||{},i||(a.xaxis.convertedCatToNumeric=!1),((a=this.checkForCatToNumericXAxis(this.chartType,l,a)).chart.sparkline&amp;&amp;a.chart.sparkline.enabled||window.Apex.chart&amp;&amp;window.Apex.chart.sparkline&amp;&amp;window.Apex.chart.sparkline.enabled)&amp;&amp;(l=r.sparkline(l)),o=g.extend(n,l)}</span>v</span>ar h=<span class="cstat-no" title="statement not covered" >g.extend(o,window.Apex);<span class="cstat-no" title="statement not covered" ></span>return n=g.extend(h,a),n=this.handleUserInputErrors(n)}</span>},{key:"checkForCatToNumericXAxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >new R(i),</span>s=<span class="cstat-no" title="statement not covered" >"bar"===t&amp;&amp;i.plotOptions&amp;&amp;i.plotOptions.bar&amp;&amp;i.plotOptions.bar.horizontal,</span>r=<span class="cstat-no" title="statement not covered" >"pie"===t||"polarArea"===t||"donut"===t||"radar"===t||"radialBar"===t||"heatmap"===t,</span>n=<span class="cstat-no" title="statement not covered" >"datetime"!==i.xaxis.type&amp;&amp;"numeric"!==i.xaxis.type,</span>o=<span class="cstat-no" title="statement not covered" >i.xaxis.tickPlacement?i.xaxis.tickPlacement:e.xaxis&amp;&amp;e.xaxis.tickPlacement;<span class="cstat-no" title="statement not covered" ></span>return s||r||!n||"between"===o||(i=a.convertCatToNumeric(i)),i}</span>},{key:"extendYAxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >new S;<span class="cstat-no" title="statement not covered" ></span>(void 0===t.yaxis||!t.yaxis||Array.isArray(t.yaxis)&amp;&amp;0===t.yaxis.length)&amp;&amp;(t.yaxis={}),t.yaxis.constructor!==Array&amp;&amp;window.Apex.yaxis&amp;&amp;window.Apex.yaxis.constructor!==Array&amp;&amp;(t.yaxis=g.extend(t.yaxis,window.Apex.yaxis)),t.yaxis.constructor!==Array?t.yaxis=[g.extend(i.yAxis,t.yaxis)]:t.yaxis=g.extendArray(t.yaxis,i.yAxis);v</span>ar a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.logarithmic&amp;&amp;(a=!0)}</span>));v</span>ar s=<span class="cstat-no" title="statement not covered" >t.series;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;!s&amp;&amp;(s=e.config.series),a&amp;&amp;s.length!==t.yaxis.length&amp;&amp;s.length&amp;&amp;(t.yaxis=s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >if(e.name||(s[a].name="series-".concat(a+1)),t.yaxis[a])<span class="cstat-no" title="statement not covered" >return t.yaxis[a].seriesName=s[a].name,t.yaxis[a];v</span></span>ar r=<span class="cstat-no" title="statement not covered" >g.extend(i.yAxis,t.yaxis[0]);<span class="cstat-no" title="statement not covered" ></span>return r.show=!1,r}</span>))),a&amp;&amp;s.length&gt;1&amp;&amp;s.length!==t.yaxis.length&amp;&amp;console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."),t}</span>},{key:"extendAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0===t.annotations&amp;&amp;(t.annotations={},t.annotations.yaxis=[],t.annotations.xaxis=[],t.annotations.points=[]),t=this.extendYAxisAnnotations(t),t=this.extendXAxisAnnotations(t),t=this.extendPointAnnotations(t)}</span>},{key:"extendYAxisAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new S;<span class="cstat-no" title="statement not covered" ></span>return t.annotations.yaxis=g.extendArray(void 0!==t.annotations.yaxis?t.annotations.yaxis:[],e.yAxisAnnotation),t}</span>},{key:"extendXAxisAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new S;<span class="cstat-no" title="statement not covered" ></span>return t.annotations.xaxis=g.extendArray(void 0!==t.annotations.xaxis?t.annotations.xaxis:[],e.xAxisAnnotation),t}</span>},{key:"extendPointAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new S;<span class="cstat-no" title="statement not covered" ></span>return t.annotations.points=g.extendArray(void 0!==t.annotations.points?t.annotations.points:[],e.pointAnnotation),t}</span>},{key:"checkForDarkTheme",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.theme&amp;&amp;"dark"===t.theme.mode&amp;&amp;(t.tooltip||(t.tooltip={}),"light"!==t.tooltip.theme&amp;&amp;(t.tooltip.theme="dark"),t.chart.foreColor||(t.chart.foreColor="#f6f7f8"),t.theme.palette||(t.theme.palette="palette4"))}</span>},{key:"handleUserInputErrors",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(e.tooltip.shared&amp;&amp;e.tooltip.intersect)<span class="cstat-no" title="statement not covered" >throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");<span class="cstat-no" title="statement not covered" >i</span></span>f(("bar"===e.chart.type||"rangeBar"===e.chart.type)&amp;&amp;e.plotOptions.bar.horizontal){<span class="cstat-no" title="statement not covered" >if(e.yaxis.length&gt;1)<span class="cstat-no" title="statement not covered" >throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");<span class="cstat-no" title="statement not covered" >e</span></span>.yaxis[0].reversed&amp;&amp;(e.yaxis[0].opposite=!0),e.xaxis.tooltip.enabled=!1,e.yaxis[0].tooltip.enabled=!1,e.chart.zoom.enabled=!1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"bar"!==e.chart.type&amp;&amp;"rangeBar"!==e.chart.type||e.tooltip.shared&amp;&amp;("barWidth"===e.xaxis.crosshairs.width&amp;&amp;e.series.length&gt;1&amp;&amp;(console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'),e.xaxis.crosshairs.width="tickWidth"),e.plotOptions.bar.horizontal&amp;&amp;(e.states.hover.type="none",e.tooltip.shared=!1),e.tooltip.followCursor||(console.warn("followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true","color: blue;"),e.tooltip.followCursor=!0)),"candlestick"===e.chart.type&amp;&amp;e.yaxis[0].reversed&amp;&amp;(console.warn("Reversed y-axis in candlestick chart is not supported."),e.yaxis[0].reversed=!1),e.chart.group&amp;&amp;0===e.yaxis[0].labels.minWidth&amp;&amp;console.warn("It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour."),Array.isArray(e.stroke.width)&amp;&amp;"line"!==e.chart.type&amp;&amp;"area"!==e.chart.type&amp;&amp;(console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"),e.stroke.width=e.stroke.width[0]),e}</span>}]),i}</span>(),</span>H=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >e(this,t)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"initGlobalVars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.series=[],t.seriesCandleO=[],t.seriesCandleH=[],t.seriesCandleL=[],t.seriesCandleC=[],t.seriesRangeStart=[],t.seriesRangeEnd=[],t.seriesRangeBarTimeline=[],t.seriesPercent=[],t.seriesX=[],t.seriesZ=[],t.seriesNames=[],t.seriesTotals=[],t.seriesLog=[],t.stackedSeriesTotals=[],t.seriesXvalues=[],t.seriesYvalues=[],t.labels=[],t.categoryLabels=[],t.timescaleLabels=[],t.noLabelsProvided=!1,t.resizeTimer=null,t.selectionResizeTimer=null,t.delayedElements=[],t.pointsArray=[],t.dataLabelsRects=[],t.isXNumeric=!1,t.xaxisLabelsCount=0,t.skipLastTimelinelabel=!1,t.skipFirstTimelinelabel=!1,t.isDataXYZ=!1,t.isMultiLineX=!1,t.isMultipleYAxis=!1,t.maxY=-Number.MAX_VALUE,t.minY=Number.MIN_VALUE,t.minYArr=[],t.maxYArr=[],t.maxX=-Number.MAX_VALUE,t.minX=Number.MAX_VALUE,t.initialMaxX=-Number.MAX_VALUE,t.initialMinX=Number.MAX_VALUE,t.maxDate=0,t.minDate=Number.MAX_VALUE,t.minZ=Number.MAX_VALUE,t.maxZ=-Number.MAX_VALUE,t.minXDiff=Number.MAX_VALUE,t.yAxisScale=[],t.xAxisScale=null,t.xAxisTicksPositions=[],t.yLabelsCoords=[],t.yTitleCoords=[],t.barPadForNumericAxis=0,t.padHorizontal=0,t.xRange=0,t.yRange=[],t.zRange=0,t.dataPoints=0,t.xTickAmount=0}</span>},{key:"globalVars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{chartID:null,cuid:null,events:{beforeMount:[],mounted:[],updated:[],clicked:[],selection:[],dataPointSelection:[],zoomed:[],scrolled:[]},colors:[],clientX:null,clientY:null,fill:{colors:[]},stroke:{colors:[]},dataLabels:{style:{colors:[]}},radarPolygons:{fill:{colors:[]}},markers:{colors:[],size:t.markers.size,largestSize:0},animationEnded:!1,isTouchDevice:"ontouchstart"in window||navigator.msMaxTouchPoints,isDirty:!1,isExecCalled:!1,initialConfig:null,initialSeries:[],lastXAxis:[],lastYAxis:[],columnSeries:null,labels:[],timescaleLabels:[],noLabelsProvided:!1,allSeriesCollapsed:!1,collapsedSeries:[],collapsedSeriesIndices:[],ancillaryCollapsedSeries:[],ancillaryCollapsedSeriesIndices:[],risingSeries:[],dataFormatXNumeric:!1,capturedSeriesIndex:-1,capturedDataPointIndex:-1,selectedDataPoints:[],goldenPadding:35,invalidLogScale:!1,ignoreYAxisIndexes:[],yAxisSameScaleIndices:[],maxValsInArrayIndex:0,radialSize:0,selection:void 0,zoomEnabled:"zoom"===t.chart.toolbar.autoSelected&amp;&amp;t.chart.toolbar.tools.zoom&amp;&amp;t.chart.zoom.enabled,panEnabled:"pan"===t.chart.toolbar.autoSelected&amp;&amp;t.chart.toolbar.tools.pan,selectionEnabled:"selection"===t.chart.toolbar.autoSelected&amp;&amp;t.chart.toolbar.tools.selection,yaxis:null,mousedown:!1,lastClientPosition:{},visibleXRange:void 0,yValueDecimal:0,total:0,SVGNS:"http://www.w3.org/2000/svg",svgWidth:0,svgHeight:0,noData:!1,locale:{},dom:{},memory:{methodsToExec:[]},shouldAnimate:!0,skipLastTimelinelabel:!1,skipFirstTimelinelabel:!1,delayedElements:[],axisCharts:!0,isDataXYZ:!1,resized:!1,resizeTimer:null,comboCharts:!1,dataChanged:!1,previousPaths:[],allSeriesHasEqualX:!0,pointsArray:[],dataLabelsRects:[],lastDrawnDataLabelsIndexes:[],hasNullValues:!1,easing:null,zoomed:!1,gridWidth:0,gridHeight:0,rotateXLabels:!1,defaultLabels:!1,xLabelFormatter:void 0,yLabelFormatters:[],xaxisTooltipFormatter:void 0,ttKeyFormatter:void 0,ttVal:void 0,ttZFormatter:void 0,LINE_HEIGHT_RATIO:1.618,xAxisLabelsHeight:0,yAxisLabelsWidth:0,scaleX:1,scaleY:1,translateX:0,translateY:0,translateYAxisX:[],yAxisWidths:[],translateXAxisY:0,translateXAxisX:0,tooltip:null}}</span>},{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.globalVars(t);<span class="cstat-no" title="statement not covered" ></span>return this.initGlobalVars(e),e.initialConfig=g.extend({},t),e.initialSeries=g.clone(t.series),e.lastXAxis=JSON.parse(JSON.stringify(e.initialConfig.xaxis)),e.lastYAxis=JSON.parse(JSON.stringify(e.initialConfig.yaxis)),e}</span>}]),t}</span>(),</span>N=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.opts=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >new D(this.opts).init({responsiveOverride:!1});<span class="cstat-no" title="statement not covered" ></span>return{config:t,globals:(new H).init(t)}}</span>}]),t}</span>(),</span>O=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.twoDSeries=[],this.threeDSeries=[],this.twoDSeriesX=[],this.coreUtils=new m(this.ctx)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"isMultiFormat",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isFormatXY()||this.isFormat2DArray()}</span>},{key:"isFormatXY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.config.series.slice(),</span>e=<span class="cstat-no" title="statement not covered" >new M(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(this.activeSeriesIndex=e.getActiveConfigSeriesIndex(),void 0!==t[this.activeSeriesIndex].data&amp;&amp;t[this.activeSeriesIndex].data.length&gt;0&amp;&amp;null!==t[this.activeSeriesIndex].data[0]&amp;&amp;void 0!==t[this.activeSeriesIndex].data[0].x&amp;&amp;null!==t[this.activeSeriesIndex].data[0])<span class="cstat-no" title="statement not covered" >return!0}</span></span>},{key:"isFormat2DArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.config.series.slice(),</span>e=<span class="cstat-no" title="statement not covered" >new M(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(this.activeSeriesIndex=e.getActiveConfigSeriesIndex(),void 0!==t[this.activeSeriesIndex].data&amp;&amp;t[this.activeSeriesIndex].data.length&gt;0&amp;&amp;void 0!==t[this.activeSeriesIndex].data[0]&amp;&amp;null!==t[this.activeSeriesIndex].data[0]&amp;&amp;t[this.activeSeriesIndex].data[0].constructor===Array)<span class="cstat-no" title="statement not covered" >return!0}</span></span>},{key:"handleFormat2DArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w.config,</span>a=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>i.xaxis.sorted&amp;&amp;("datetime"===i.xaxis.type?t[e].data.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new Date(t[0]).getTime()-new Date(e[0]).getTime()}</span>)):"numeric"===i.xaxis.type&amp;&amp;t[e].data.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t[0]-e[0]}</span>)));<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t[e].data.length;s++)<span class="cstat-no" title="statement not covered" >if(void 0!==t[e].data[s][1]&amp;&amp;(Array.isArray(t[e].data[s][1])&amp;&amp;4===t[e].data[s][1].length?this.twoDSeries.push(g.parseNumber(t[e].data[s][1][3])):5===t[e].data[s].length?this.twoDSeries.push(g.parseNumber(t[e].data[s][4])):this.twoDSeries.push(g.parseNumber(t[e].data[s][1])),a.dataFormatXNumeric=!0),"datetime"===i.xaxis.type){var r=<span class="cstat-no" title="statement not covered" >new Date(t[e].data[s][0]);<span class="cstat-no" title="statement not covered" ></span>r=new Date(r).getTime(),this.twoDSeriesX.push(r)}</span>else <span class="cstat-no" title="statement not covered" >this.twoDSeriesX.push(t[e].data[s][0]);<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t[e].data.length;n++)<span class="cstat-no" title="statement not covered" >void 0!==t[e].data[n][2]&amp;&amp;(this.threeDSeries.push(t[e].data[n][2]),a.isDataXYZ=!0)}</span></span>},{key:"handleFormatXY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w.config,</span>a=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>s=<span class="cstat-no" title="statement not covered" >new Y(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>a.collapsedSeriesIndices.indexOf(e)&gt;-1&amp;&amp;(r=this.activeSeriesIndex),i.xaxis.sorted&amp;&amp;("datetime"===i.xaxis.type?t[e].data.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new Date(t.x).getTime()-new Date(e.x).getTime()}</span>)):"numeric"===i.xaxis.type&amp;&amp;t[e].data.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.x-e.x}</span>)));<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t[e].data.length;n++)<span class="cstat-no" title="statement not covered" >void 0!==t[e].data[n].y&amp;&amp;(Array.isArray(t[e].data[n].y)?this.twoDSeries.push(g.parseNumber(t[e].data[n].y[t[e].data[n].y.length-1])):this.twoDSeries.push(g.parseNumber(t[e].data[n].y)));<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t[r].data.length;o++){var l=<span class="cstat-no" title="statement not covered" >"string"==typeof t[r].data[o].x,</span>h=<span class="cstat-no" title="statement not covered" >Array.isArray(t[r].data[o].x),</span>c=<span class="cstat-no" title="statement not covered" >!h&amp;&amp;!!s.isValidDate(t[r].data[o].x.toString());<span class="cstat-no" title="statement not covered" ></span>if(l||c)<span class="cstat-no" title="statement not covered" >if(l||i.xaxis.convertedCatToNumeric){var d=<span class="cstat-no" title="statement not covered" >a.isBarHorizontal&amp;&amp;a.isRangeData;<span class="cstat-no" title="statement not covered" ></span>"datetime"!==i.xaxis.type||d?(this.fallbackToCategory=!0,this.twoDSeriesX.push(t[r].data[o].x)):this.twoDSeriesX.push(s.parseDate(t[r].data[o].x))}</span>else<span class="cstat-no" title="statement not covered" >"datetime"===i.xaxis.type?this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())):(a.dataFormatXNumeric=!0,a.isXNumeric=!0,this.twoDSeriesX.push(parseFloat(t[r].data[o].x)));e</span></span>lse <span class="cstat-no" title="statement not covered" >h?(this.fallbackToCategory=!0,this.twoDSeriesX.push(t[r].data[o].x)):(a.isXNumeric=!0,a.dataFormatXNumeric=!0,this.twoDSeriesX.push(t[r].data[o].x))}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(t[e].data[0]&amp;&amp;void 0!==t[e].data[0].z){<span class="cstat-no" title="statement not covered" >for(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;t[e].data.length;u++)<span class="cstat-no" title="statement not covered" >this.threeDSeries.push(t[e].data[u].z);<span class="cstat-no" title="statement not covered" >a</span></span>.isDataXYZ=!0}</span>}</span>},{key:"handleRangeData",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w.config,</span>a=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return this.isFormat2DArray()?s=this.handleRangeDataFormat("array",t,e):this.isFormatXY()&amp;&amp;(s=this.handleRangeDataFormat("xy",t,e)),a.seriesRangeStart.push(s.start),a.seriesRangeEnd.push(s.end),"datetime"===i.xaxis.type&amp;&amp;a.seriesRangeBarTimeline.push(s.rangeUniques),a.seriesRangeBarTimeline.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.y.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.y.length;a++)<span class="cstat-no" title="statement not covered" >if(i!==a){var s=<span class="cstat-no" title="statement not covered" >e.y1,</span>r=<span class="cstat-no" title="statement not covered" >e.y2,</span>n=<span class="cstat-no" title="statement not covered" >t.y[a].y1;<span class="cstat-no" title="statement not covered" ></span>s&lt;=t.y[a].y2&amp;&amp;n&lt;=r&amp;&amp;(t.overlaps.indexOf(e.rangeName)&lt;0&amp;&amp;t.overlaps.push(e.rangeName),t.overlaps.indexOf(t.y[a].rangeName)&lt;0&amp;&amp;t.overlaps.push(t.y[a].rangeName))}</span>}</span></span>))}</span>))}</span>)),s}</span>},{key:"handleCandleStickData",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>a=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return this.isFormat2DArray()?a=this.handleCandleStickDataFormat("array",t,e):this.isFormatXY()&amp;&amp;(a=this.handleCandleStickDataFormat("xy",t,e)),i.seriesCandleO[e]=a.o,i.seriesCandleH[e]=a.h,i.seriesCandleL[e]=a.l,i.seriesCandleC[e]=a.c,a}</span>},{key:"handleRangeDataFormat",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >e[i].data.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return e===i.findIndex((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.x===t.x}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return{x:t.x,overlaps:[],y:[]}}</span>)),</span>n=<span class="cstat-no" title="statement not covered" >"Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts",</span>o=<span class="cstat-no" title="statement not covered" >new M(this.ctx).getActiveConfigSeriesIndex();<span class="cstat-no" title="statement not covered" ></span>if("array"===t){<span class="cstat-no" title="statement not covered" >if(2!==e[o].data[0][1].length)<span class="cstat-no" title="statement not covered" >throw new Error(n);<span class="cstat-no" title="statement not covered" >f</span></span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;e[i].data.length;l++)<span class="cstat-no" title="statement not covered" >a.push(e[i].data[l][1][0]),s.push(e[i].data[l][1][1])}</span></span>else <span class="cstat-no" title="statement not covered" >if("xy"===t){<span class="cstat-no" title="statement not covered" >if(2!==e[o].data[0].y.length)<span class="cstat-no" title="statement not covered" >throw new Error(n);<span class="cstat-no" title="statement not covered" >f</span></span>or(var h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >g.randomId(),</span>o=<span class="cstat-no" title="statement not covered" >e[i].data[t].x,</span>l=<span class="cstat-no" title="statement not covered" >{y1:e[i].data[t].y[0],y2:e[i].data[t].y[1],rangeName:n};<span class="cstat-no" title="statement not covered" ></span>e[i].data[t].rangeName=n;v</span>ar h=<span class="cstat-no" title="statement not covered" >r.findIndex((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.x===o}</span>));<span class="cstat-no" title="statement not covered" ></span>r[h].y.push(l),a.push(l.y1),s.push(l.y2)}</span>,</span>c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;e[i].data.length;c++)<span class="cstat-no" title="statement not covered" >h(c)}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn{start:a,end:s,rangeUniques:r}}</span>},{key:"handleCandleStickDataFormat",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >"Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick";<span class="cstat-no" title="statement not covered" ></span>if("array"===t){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e[i].data[0][1])&amp;&amp;5!==e[i].data[0].length||Array.isArray(e[i].data[0][1])&amp;&amp;4!==e[i].data[0][1].length)<span class="cstat-no" title="statement not covered" >throw new Error(o);<span class="cstat-no" title="statement not covered" >i</span></span>f(5===e[i].data[0].length)<span class="cstat-no" title="statement not covered" >for(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;e[i].data.length;l++)<span class="cstat-no" title="statement not covered" >a.push(e[i].data[l][1]),s.push(e[i].data[l][2]),r.push(e[i].data[l][3]),n.push(e[i].data[l][4]);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;e[i].data.length;h++)<span class="cstat-no" title="statement not covered" >a.push(e[i].data[h][1][0]),s.push(e[i].data[h][1][1]),r.push(e[i].data[h][1][2]),n.push(e[i].data[h][1][3])}</span></span></span>else <span class="cstat-no" title="statement not covered" >if("xy"===t){<span class="cstat-no" title="statement not covered" >if(4!==e[i].data[0].y.length)<span class="cstat-no" title="statement not covered" >throw new Error(o);<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;e[i].data.length;c++)<span class="cstat-no" title="statement not covered" >a.push(e[i].data[c].y[0]),s.push(e[i].data[c].y[1]),r.push(e[i].data[c].y[2]),n.push(e[i].data[c].y[3])}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn{o:a,h:s,l:r,c:n}}</span>},{key:"parseDataAxisCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:this.ctx,</span>a=<span class="cstat-no" title="statement not covered" >this.w.config,</span>s=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>r=<span class="cstat-no" title="statement not covered" >new Y(i),</span>n=<span class="cstat-no" title="statement not covered" >a.labels.length&gt;0?a.labels.slice():a.xaxis.categories.slice(),</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++)<span class="cstat-no" title="statement not covered" >if("string"==typeof n[t]){<span class="cstat-no" title="statement not covered" >if(!r.isValidDate(n[t]))<span class="cstat-no" title="statement not covered" >throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");<span class="cstat-no" title="statement not covered" >e</span></span>.twoDSeriesX.push(r.parseDate(n[t]))}</span>else{<span class="cstat-no" title="statement not covered" >if(13!==String(n[t]).length)<span class="cstat-no" title="statement not covered" >throw new Error("Please provide a valid JavaScript timestamp");<span class="cstat-no" title="statement not covered" >e</span></span>.twoDSeriesX.push(n[t])}</span>}</span></span>,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;t.length;l++){<span class="cstat-no" title="statement not covered" >if(this.twoDSeries=[],this.twoDSeriesX=[],this.threeDSeries=[],void 0===t[l].data)<span class="cstat-no" title="statement not covered" >return void console.error("It is a possibility that you may have not included 'data' property in series.");<span class="cstat-no" title="statement not covered" >i</span></span>f("rangeBar"!==a.chart.type&amp;&amp;"rangeArea"!==a.chart.type&amp;&amp;"rangeBar"!==t[l].type&amp;&amp;"rangeArea"!==t[l].type||(s.isRangeData=!0,this.handleRangeData(t,l)),this.isMultiFormat())<span class="cstat-no" title="statement not covered" >this.isFormat2DArray()?this.handleFormat2DArray(t,l):this.isFormatXY()&amp;&amp;this.handleFormatXY(t,l),"candlestick"!==a.chart.type&amp;&amp;"candlestick"!==t[l].type||this.handleCandleStickData(t,l),s.series.push(this.twoDSeries),s.labels.push(this.twoDSeriesX),s.seriesX.push(this.twoDSeriesX),l!==this.activeSeriesIndex||this.fallbackToCategory||(s.isXNumeric=!0);e</span>lse{<span class="cstat-no" title="statement not covered" >"datetime"===a.xaxis.type?(s.isXNumeric=!0,o(),s.seriesX.push(this.twoDSeriesX)):"numeric"===a.xaxis.type&amp;&amp;(s.isXNumeric=!0,n.length&gt;0&amp;&amp;(this.twoDSeriesX=n,s.seriesX.push(this.twoDSeriesX))),s.labels.push(this.twoDSeriesX);v</span>ar h=<span class="cstat-no" title="statement not covered" >t[l].data.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return g.parseNumber(t)}</span>));<span class="cstat-no" title="statement not covered" ></span>s.series.push(h)}<span class="cstat-no" title="statement not covered" ></span>s</span>.seriesZ.push(this.threeDSeries),void 0!==t[l].name?s.seriesNames.push(t[l].name):s.seriesNames.push("series-"+parseInt(l+1,10))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.w}</span>},{key:"parseDataNonAxisCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>i=<span class="cstat-no" title="statement not covered" >this.w.config;<span class="cstat-no" title="statement not covered" ></span>e.series=t.slice(),e.seriesNames=i.labels.slice();<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;e.series.length;a++)<span class="cstat-no" title="statement not covered" >void 0===e.seriesNames[a]&amp;&amp;e.seriesNames.push("series-"+(a+1));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.w}</span>},{key:"handleExternalLabelsData",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w.config,</span>i=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>if(e.xaxis.categories.length&gt;0)<span class="cstat-no" title="statement not covered" >i.labels=e.xaxis.categories;e</span>lse <span class="cstat-no" title="statement not covered" >if(e.labels.length&gt;0)<span class="cstat-no" title="statement not covered" >i.labels=e.labels.slice();e</span>lse <span class="cstat-no" title="statement not covered" >if(this.fallbackToCategory){<span class="cstat-no" title="statement not covered" >if(i.labels=i.labels[0],i.seriesRangeBarTimeline.length&amp;&amp;(i.seriesRangeBarTimeline.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.labels.indexOf(t.x)&lt;0&amp;&amp;t.x&amp;&amp;i.labels.push(t.x)}</span>))}</span>)),i.labels=i.labels.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return i.indexOf(t)===e}</span>))),e.xaxis.convertedCatToNumeric)<span class="cstat-no" title="statement not covered" >new R(e).convertCatToNumericXaxis(e,this.ctx,i.seriesX[0]),this._generateExternalLabels(t)}</span></span>else <span class="cstat-no" title="statement not covered" >this._generateExternalLabels(t)}</span></span></span></span>},{key:"_generateExternalLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>i=<span class="cstat-no" title="statement not covered" >this.w.config,</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e.axisCharts){<span class="cstat-no" title="statement not covered" >if(e.series.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e.series[e.maxValsInArrayIndex].length;s++)<span class="cstat-no" title="statement not covered" >a.push(s+1);<span class="cstat-no" title="statement not covered" >e</span></span></span>.seriesX=[];<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >e.seriesX.push(a);<span class="cstat-no" title="statement not covered" >e</span></span>.isXNumeric=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===a.length){<span class="cstat-no" title="statement not covered" >a=e.axisCharts?[]:e.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e+1}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >e.seriesX.push(a)}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.labels=a,i.xaxis.convertedCatToNumeric&amp;&amp;(e.categoryLabels=a.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return i.xaxis.labels.formatter(t)}</span>))),e.noLabelsProvided=!0}</span>},{key:"parseData",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.config,</span>a=<span class="cstat-no" title="statement not covered" >e.globals;<span class="cstat-no" title="statement not covered" ></span>if(this.excludeCollapsedSeriesInYAxis(),this.fallbackToCategory=!1,this.ctx.core.resetGlobals(),this.ctx.core.isMultipleY(),a.axisCharts?this.parseDataAxisCharts(t):this.parseDataNonAxisCharts(t),this.coreUtils.getLargestSeries(),"bar"===i.chart.type&amp;&amp;i.chart.stacked){var s=<span class="cstat-no" title="statement not covered" >new M(this.ctx);<span class="cstat-no" title="statement not covered" ></span>a.series=s.setNullSeriesToZeroValues(a.series)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.coreUtils.getSeriesTotals(),a.axisCharts&amp;&amp;this.coreUtils.getStackedSeriesTotals(),this.coreUtils.getPercentSeries(),a.dataFormatXNumeric||a.isXNumeric&amp;&amp;("numeric"!==i.xaxis.type||0!==i.labels.length||0!==i.xaxis.categories.length)||this.handleExternalLabelsData(t);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this.coreUtils.getCategoryLabels(a.labels),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;r.length;n++)<span class="cstat-no" title="statement not covered" >if(Array.isArray(r[n])){<span class="cstat-no" title="statement not covered" >a.isMultiLineX=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>},{key:"excludeCollapsedSeriesInYAxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>e.globals.ignoreYAxisIndexes=e.globals.collapsedSeries.map((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){<span class="cstat-no" title="statement not covered" >if(t.w.globals.isMultipleYAxis&amp;&amp;!e.config.chart.stacked)<span class="cstat-no" title="statement not covered" >return i.index}</span></span>))}</span>}]),t}</span>(),</span>W=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.tooltipKeyFormat="dd MMM"}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"xLabelFormat",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if("datetime"===a.config.xaxis.type&amp;&amp;void 0===a.config.xaxis.labels.formatter&amp;&amp;void 0===a.config.tooltip.x.formatter){var s=<span class="cstat-no" title="statement not covered" >new Y(this.ctx);<span class="cstat-no" title="statement not covered" ></span>return s.formatDate(s.getDate(e),a.config.tooltip.x.format)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t(e,i)}</span>},{key:"defaultGeneralFormatter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Array.isArray(t)?t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>)):t}</span>},{key:"defaultYFormatter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return g.isNumber(t)&amp;&amp;(t=0!==a.globals.yValueDecimal?t.toFixed(void 0!==e.decimalsInFloat?e.decimalsInFloat:a.globals.yValueDecimal):a.globals.maxYArr[i]-a.globals.minYArr[i]&lt;10?t.toFixed(1):t.toFixed(0)),t}</span>},{key:"setLabelFormatters",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return e.globals.xLabelFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.defaultGeneralFormatter(e)}</span>,e.globals.xaxisTooltipFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.defaultGeneralFormatter(e)}</span>,e.globals.ttKeyFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.defaultGeneralFormatter(e)}</span>,e.globals.ttZFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>,e.globals.legendFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.defaultGeneralFormatter(e)}</span>,void 0!==e.config.xaxis.labels.formatter?e.globals.xLabelFormatter=e.config.xaxis.labels.formatter:e.globals.xLabelFormatter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(g.isNumber(t)){<span class="cstat-no" title="statement not covered" >if(!e.config.xaxis.convertedCatToNumeric&amp;&amp;"numeric"===e.config.xaxis.type&amp;&amp;e.globals.dataPoints&lt;50)<span class="cstat-no" title="statement not covered" >return t.toFixed(1);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.globals.isBarHorizontal)<span class="cstat-no" title="statement not covered" >if(e.globals.maxY-e.globals.minYArr&lt;4)<span class="cstat-no" title="statement not covered" >return t.toFixed(1);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.toFixed(0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,"function"==typeof e.config.tooltip.x.formatter?e.globals.ttKeyFormatter=e.config.tooltip.x.formatter:e.globals.ttKeyFormatter=e.globals.xLabelFormatter,"function"==typeof e.config.xaxis.tooltip.formatter&amp;&amp;(e.globals.xaxisTooltipFormatter=e.config.xaxis.tooltip.formatter),Array.isArray(e.config.tooltip.y)?e.globals.ttVal=e.config.tooltip.y:void 0!==e.config.tooltip.y.formatter&amp;&amp;(e.globals.ttVal=e.config.tooltip.y),void 0!==e.config.tooltip.z.formatter&amp;&amp;(e.globals.ttZFormatter=e.config.tooltip.z.formatter),void 0!==e.config.legend.formatter&amp;&amp;(e.globals.legendFormatter=e.config.legend.formatter),e.config.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){<span class="cstat-no" title="statement not covered" >void 0!==i.labels.formatter?e.globals.yLabelFormatters[a]=i.labels.formatter:e.globals.yLabelFormatters[a]=<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return e.globals.xyCharts?Array.isArray(s)?s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.defaultYFormatter(e,i,a)}</span>)):t.defaultYFormatter(s,i,a):s}</span>}</span>)),e.globals}</span>},{key:"heatmapLabelFormatters",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if("heatmap"===t.config.chart.type){<span class="cstat-no" title="statement not covered" >t.globals.yAxisScale[0].result=t.globals.seriesNames.slice();v</span>ar e=<span class="cstat-no" title="statement not covered" >t.globals.seriesNames.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.length&gt;e.length?t:e}</span>),0);<span class="cstat-no" title="statement not covered" ></span>t.globals.yAxisScale[0].niceMax=e,t.globals.yAxisScale[0].niceMin=e}</span>}</span>}]),t}</span>(),</span>B=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getLabel",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:[],</span>r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;5&amp;&amp;void 0!==arguments[5]?arguments[5]:"12px",</span>n=<span class="cstat-no" title="statement not covered" >this.w,</span>o=<span class="cstat-no" title="statement not covered" >void 0===t[a]?"":t[a],</span>l=<span class="cstat-no" title="statement not covered" >o,</span>h=<span class="cstat-no" title="statement not covered" >n.globals.xLabelFormatter,</span>c=<span class="cstat-no" title="statement not covered" >n.config.xaxis.labels.formatter,</span>d=<span class="cstat-no" title="statement not covered" >!1,</span>g=<span class="cstat-no" title="statement not covered" >new W(this.ctx),</span>u=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>l=g.xLabelFormat(h,o,u),void 0!==c&amp;&amp;(l=c(o,t[a],a));v</span>ar f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"month"===t.unit?i="year":"day"===t.unit?i="month":"hour"===t.unit?i="day":"minute"===t.unit&amp;&amp;(i="hour")}</span>)),i===t}</span>;<span class="cstat-no" title="statement not covered" ></span>e.length&gt;0?(d=f(e[a].unit),i=e[a].position,l=e[a].value):"datetime"===n.config.xaxis.type&amp;&amp;void 0===c&amp;&amp;(l=""),void 0===l&amp;&amp;(l=""),l=Array.isArray(l)?l:l.toString();v</span>ar x=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>b=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return b=n.globals.rotateXLabels?x.getTextRects(l,parseInt(r,10),null,"rotate(".concat(n.config.xaxis.labels.rotate," 0 0)"),!1):x.getTextRects(l,parseInt(r,10)),!Array.isArray(l)&amp;&amp;(0===l.indexOf("NaN")||0===l.toLowerCase().indexOf("invalid")||l.toLowerCase().indexOf("infinity")&gt;=0||s.indexOf(l)&gt;=0&amp;&amp;!n.config.xaxis.labels.showDuplicates)&amp;&amp;(l=""),{x:i,text:l,textRect:b,isBold:d}}</span>},{key:"checkForOverflowingLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){var r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(0===t&amp;&amp;r.globals.skipFirstTimelinelabel&amp;&amp;(e.text=""),t===i-1&amp;&amp;r.globals.skipLastTimelinelabel&amp;&amp;(e.text=""),r.config.xaxis.labels.hideOverlappingLabels&amp;&amp;a.length&gt;0){var n=<span class="cstat-no" title="statement not covered" >s[s.length-1];<span class="cstat-no" title="statement not covered" ></span>e.x&lt;n.textRect.width/(r.globals.rotateXLabels?Math.abs(r.config.xaxis.labels.rotate)/12:1.01)+n.x&amp;&amp;(e.text="")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>},{key:"checkForReversedLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return i.config.yaxis[t]&amp;&amp;i.config.yaxis[t].reversed&amp;&amp;e.reverse(),e}</span>},{key:"isYAxisHidden",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new m(this.ctx);<span class="cstat-no" title="statement not covered" ></span>return!e.config.yaxis[t].show||!e.config.yaxis[t].showForNullSeries&amp;&amp;i.isSeriesNull(t)&amp;&amp;-1===e.globals.collapsedSeriesIndices.indexOf(t)}</span>},{key:"drawYAxisTicks",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r,n){var o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>h=<span class="cstat-no" title="statement not covered" >o.globals.translateY;<span class="cstat-no" title="statement not covered" ></span>if(a.show&amp;&amp;e&gt;0){<span class="cstat-no" title="statement not covered" >!0===o.config.yaxis[s].opposite&amp;&amp;(t+=a.width);<span class="cstat-no" title="statement not covered" >f</span>or(var c=<span class="cstat-no" title="statement not covered" >e;</span>c&gt;=0;c--){var d=<span class="cstat-no" title="statement not covered" >h+e/10+o.config.yaxis[s].labels.offsetY-1;<span class="cstat-no" title="statement not covered" ></span>o.globals.isBarHorizontal&amp;&amp;(d=r*c),"heatmap"===o.config.chart.type&amp;&amp;(d+=r/2);v</span>ar g=<span class="cstat-no" title="statement not covered" >l.drawLine(t+i.offsetX-a.width+a.offsetX,d+a.offsetY,t+i.offsetX+a.offsetX,d+a.offsetY,a.color);<span class="cstat-no" title="statement not covered" ></span>n.add(g),h+=r}</span>}</span>}</span>}]),t}</span>(),</span>V=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"fixSvgStringForIe11",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!g.isIE11())<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 2===++e?'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"':t}</span>));<span class="cstat-no" title="statement not covered" ></span>return i=(i=i.replace(/xmlns:NS\d+=""/g,"")).replace(/NS\d+:(\w+:\w+=")/g,"$1")}</span>},{key:"getSvgString",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals.dom.Paper.svg();<span class="cstat-no" title="statement not covered" ></span>return this.fixSvgStringForIe11(t)}</span>},{key:"cleanup",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),</span>i=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),</span>a=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");<span class="cstat-no" title="statement not covered" ></span>Array.prototype.forEach.call(a,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.setAttribute("width",0)}</span>)),e&amp;&amp;e[0]&amp;&amp;(e[0].setAttribute("x",-500),e[0].setAttribute("x1",-500),e[0].setAttribute("x2",-500)),i&amp;&amp;i[0]&amp;&amp;(i[0].setAttribute("y",-100),i[0].setAttribute("y1",-100),i[0].setAttribute("y2",-100))}</span>},{key:"svgUrl",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.cleanup();v</span>ar t=<span class="cstat-no" title="statement not covered" >this.getSvgString(),</span>e=<span class="cstat-no" title="statement not covered" >new Blob([t],{type:"image/svg+xml;charset=utf-8"});<span class="cstat-no" title="statement not covered" ></span>return URL.createObjectURL(e)}</span>},{key:"dataURI",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >t.w;<span class="cstat-no" title="statement not covered" ></span>t.cleanup();v</span>ar a=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>a.width=i.globals.svgWidth,a.height=parseInt(i.globals.dom.elWrap.style.height,10);v</span>ar s=<span class="cstat-no" title="statement not covered" >"transparent"===i.config.chart.background?"#fff":i.config.chart.background,</span>r=<span class="cstat-no" title="statement not covered" >a.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>r.fillStyle=s,r.fillRect(0,0,a.width,a.height);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.getSvgString();<span class="cstat-no" title="statement not covered" ></span>if(window.canvg&amp;&amp;g.isIE11()){var o=<span class="cstat-no" title="statement not covered" >window.canvg.Canvg.fromString(r,n,{ignoreClear:!0,ignoreDimensions:!0});<span class="cstat-no" title="statement not covered" ></span>o.start();v</span>ar l=<span class="cstat-no" title="statement not covered" >a.msToBlob();<span class="cstat-no" title="statement not covered" ></span>o.stop(),e({blob:l})}</span>else{var h=<span class="cstat-no" title="statement not covered" >"data:image/svg+xml,"+encodeURIComponent(n),</span>c=<span class="cstat-no" title="statement not covered" >new Image;<span class="cstat-no" title="statement not covered" ></span>c.crossOrigin="anonymous",c.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(r.drawImage(c,0,0),a.msToBlob){var t=<span class="cstat-no" title="statement not covered" >a.msToBlob();<span class="cstat-no" title="statement not covered" ></span>e({blob:t})}</span>else{var i=<span class="cstat-no" title="statement not covered" >a.toDataURL("image/png");<span class="cstat-no" title="statement not covered" ></span>e({imgURI:i})}</span>}</span>,c.src=h}</span>}</span>))}</span>},{key:"exportToSVG",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.triggerDownload(this.svgUrl(),".svg")}</span>},{key:"exportToPng",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.dataURI().then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >e.imgURI,</span>a=<span class="cstat-no" title="statement not covered" >e.blob;<span class="cstat-no" title="statement not covered" ></span>a?navigator.msSaveOrOpenBlob(a,t.w.globals.chartID+".png"):t.triggerDownload(i,".png")}</span>))}</span>},{key:"exportToCSV",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >t.series,</span>a=<span class="cstat-no" title="statement not covered" >t.columnDelimiter,</span>s=<span class="cstat-no" title="statement not covered" >void 0===a?",":a,</span>r=<span class="cstat-no" title="statement not covered" >t.lineDelimiter,</span>n=<span class="cstat-no" title="statement not covered" >void 0===r?"\n":r,</span>o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >"data:text/csv;charset=utf-8,",</span>d=<span class="cstat-no" title="statement not covered" >new O(this.ctx),</span>g=<span class="cstat-no" title="statement not covered" >new B(this.ctx),</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(o.globals.axisCharts){<span class="cstat-no" title="statement not covered" >if("category"===o.config.xaxis.type||o.config.xaxis.convertedCatToNumeric)<span class="cstat-no" title="statement not covered" >if(o.globals.isBarHorizontal){var a=<span class="cstat-no" title="statement not covered" >o.globals.yLabelFormatters[0],</span>s=<span class="cstat-no" title="statement not covered" >new M(e.ctx).getActiveConfigSeriesIndex();<span class="cstat-no" title="statement not covered" ></span>i=a(o.globals.labels[t],{seriesIndex:s,dataPointIndex:t,w:o})}</span>else <span class="cstat-no" title="statement not covered" >i=g.getLabel(o.globals.labels,o.globals.timescaleLabels,0,t).text;<span class="cstat-no" title="statement not covered" >"</span></span></span>datetime"===o.config.xaxis.type&amp;&amp;(o.config.xaxis.categories.length?i=o.config.xaxis.categories[t]:o.config.labels.length&amp;&amp;(i=o.config.labels[t]))}</span>else <span class="cstat-no" title="statement not covered" >i=o.config.labels[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>;<span class="cstat-no" title="statement not covered" ></span>l.push("category"),i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >o.globals.axisCharts&amp;&amp;l.push(t.name?t.name:"series-".concat(e))}</span>)),o.globals.axisCharts||(l.push("value"),h.push(l.join(s))),i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >o.globals.axisCharts?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(l.length&amp;&amp;0===e&amp;&amp;h.push(l.join(s)),t.data&amp;&amp;t.data.length)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.data.length;a++){<span class="cstat-no" title="statement not covered" >l=[];v</span>ar r=<span class="cstat-no" title="statement not covered" >u(a);<span class="cstat-no" title="statement not covered" ></span>if(r||(d.isFormatXY()?r=i[e].data[a].x:d.isFormat2DArray()&amp;&amp;(r=i[e].data[a]?i[e].data[a][0]:"")),0===e){<span class="cstat-no" title="statement not covered" >l.push(r);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;o.globals.series.length;n++)<span class="cstat-no" title="statement not covered" >l.push(o.globals.series[n][a])}<span class="cstat-no" title="statement not covered" ></span></span>(</span>"candlestick"===o.config.chart.type||t.type&amp;&amp;"candlestick"===t.type)&amp;&amp;(l.pop(),l.push(o.globals.seriesCandleO[e][a]),l.push(o.globals.seriesCandleH[e][a]),l.push(o.globals.seriesCandleL[e][a]),l.push(o.globals.seriesCandleC[e][a])),"rangeBar"===o.config.chart.type&amp;&amp;(l.pop(),l.push(o.globals.seriesRangeStart[e][a]),l.push(o.globals.seriesRangeEnd[e][a])),l.length&amp;&amp;h.push(l.join(s))}</span>}</span></span>(t,e):((l=[]).push(o.globals.labels[e]),l.push(o.globals.series[e]),h.push(l.join(s)))}</span>)),c+=h.join(n),this.triggerDownload(encodeURI(c),".csv")}</span>},{key:"triggerDownload",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>i.href=t,i.download=this.w.globals.chartID+e,document.body.appendChild(i),i.click(),document.body.removeChild(i)}</span>}]),t}</span>(),</span>G=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.axesUtils=new B(i),this.xaxisLabels=a.globals.labels.slice(),a.globals.timescaleLabels.length&gt;0&amp;&amp;!a.globals.isBarHorizontal&amp;&amp;(this.xaxisLabels=a.globals.timescaleLabels.slice()),this.drawnLabels=[],this.drawnLabelsRects=[],"top"===a.config.xaxis.position?this.offY=0:this.offY=a.globals.gridHeight+1,this.offY=this.offY+a.config.xaxis.axisBorder.offsetY,this.isCategoryBarHorizontal="bar"===a.config.chart.type&amp;&amp;a.config.plotOptions.bar.horizontal,this.xaxisFontSize=a.config.xaxis.labels.style.fontSize,this.xaxisFontFamily=a.config.xaxis.labels.style.fontFamily,this.xaxisForeColors=a.config.xaxis.labels.style.colors,this.xaxisBorderWidth=a.config.xaxis.axisBorder.width,this.isCategoryBarHorizontal&amp;&amp;(this.xaxisBorderWidth=a.config.yaxis[0].axisBorder.width.toString()),this.xaxisBorderWidth.indexOf("%")&gt;-1?this.xaxisBorderWidth=a.globals.gridWidth*parseInt(this.xaxisBorderWidth,10)/100:this.xaxisBorderWidth=parseInt(this.xaxisBorderWidth,10),this.xaxisBorderHeight=a.config.xaxis.axisBorder.height,this.yaxis=a.config.yaxis[0]}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawXaxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-xaxis",transform:"translate(".concat(i.config.xaxis.offsetX,", ").concat(i.config.xaxis.offsetY,")")}),</span>r=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-xaxis-texts-g",transform:"translate(".concat(i.globals.translateXAxisX,", ").concat(i.globals.translateXAxisY,")")});<span class="cstat-no" title="statement not covered" ></span>s.add(r);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >i.globals.padHorizontal,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;this.xaxisLabels.length;l++)<span class="cstat-no" title="statement not covered" >o.push(this.xaxisLabels[l]);v</span></span>ar h=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>if(i.globals.isXNumeric){var c=<span class="cstat-no" title="statement not covered" >h&gt;1?h-1:h;<span class="cstat-no" title="statement not covered" ></span>t=i.globals.gridWidth/c,n=n+t/2+i.config.xaxis.labels.offsetX}</span>else <span class="cstat-no" title="statement not covered" >t=i.globals.gridWidth/o.length,n=n+t+i.config.xaxis.labels.offsetX;<span class="cstat-no" title="statement not covered" >i</span></span>f(i.config.xaxis.labels.show)<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(s){var l=<span class="cstat-no" title="statement not covered" >n-t/2+i.config.xaxis.labels.offsetX;<span class="cstat-no" title="statement not covered" ></span>0===s&amp;&amp;1===h&amp;&amp;t/2===n&amp;&amp;1===i.globals.dataPoints&amp;&amp;(l=i.globals.gridWidth/2);v</span>ar c=<span class="cstat-no" title="statement not covered" >e.axesUtils.getLabel(o,i.globals.timescaleLabels,l,s,e.drawnLabels,e.xaxisFontSize),</span>d=<span class="cstat-no" title="statement not covered" >28;<span class="cstat-no" title="statement not covered" ></span>i.globals.rotateXLabels&amp;&amp;(d=22);<span class="cstat-no" title="statement not covered" >(</span>c=e.axesUtils.checkForOverflowingLabels(s,c,h,e.drawnLabels,e.drawnLabelsRects)).text&amp;&amp;i.globals.xaxisLabelsCount++;v</span>ar g=<span class="cstat-no" title="statement not covered" >a.drawText({x:c.x,y:e.offY+i.config.xaxis.labels.offsetY+d-("top"===i.config.xaxis.position?i.globals.xAxisHeight+i.config.xaxis.axisTicks.height-2:0),text:c.text,textAnchor:"middle",fontWeight:c.isBold?600:i.config.xaxis.labels.style.fontWeight,fontSize:e.xaxisFontSize,fontFamily:e.xaxisFontFamily,foreColor:Array.isArray(e.xaxisForeColors)?i.config.xaxis.convertedCatToNumeric?e.xaxisForeColors[i.globals.minX+s-1]:e.xaxisForeColors[s]:e.xaxisForeColors,isPlainText:!1,cssClass:"apexcharts-xaxis-label "+i.config.xaxis.labels.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>r.add(g);v</span>ar u=<span class="cstat-no" title="statement not covered" >document.createElementNS(i.globals.SVGNS,"title");<span class="cstat-no" title="statement not covered" ></span>u.textContent=c.text,g.node.appendChild(u),""!==c.text&amp;&amp;(e.drawnLabels.push(c.text),e.drawnLabelsRects.push(c)),n+=t}</span>,</span>g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;=h-1;g++)<span class="cstat-no" title="statement not covered" >d(g);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(void 0!==i.config.xaxis.title.text){var u=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-xaxis-title"}),</span>f=<span class="cstat-no" title="statement not covered" >a.drawText({x:i.globals.gridWidth/2+i.config.xaxis.title.offsetX,y:this.offY-parseFloat(this.xaxisFontSize)+i.globals.xAxisLabelsHeight+i.config.xaxis.title.offsetY,text:i.config.xaxis.title.text,textAnchor:"middle",fontSize:i.config.xaxis.title.style.fontSize,fontFamily:i.config.xaxis.title.style.fontFamily,fontWeight:i.config.xaxis.title.style.fontWeight,foreColor:i.config.xaxis.title.style.color,cssClass:"apexcharts-xaxis-title-text "+i.config.xaxis.title.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>u.add(f),s.add(u)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i.config.xaxis.axisBorder.show){var x=<span class="cstat-no" title="statement not covered" >i.globals.barPadForNumericAxis,</span>b=<span class="cstat-no" title="statement not covered" >a.drawLine(i.globals.padHorizontal+i.config.xaxis.axisBorder.offsetX-x,this.offY,this.xaxisBorderWidth+x,this.offY,i.config.xaxis.axisBorder.color,0,this.xaxisBorderHeight);<span class="cstat-no" title="statement not covered" ></span>s.add(b)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>},{key:"drawXaxisInversed",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i,a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >a.config.yaxis[0].opposite?a.globals.translateYAxisX[t]:0,</span>n=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-yaxis apexcharts-xaxis-inversed",rel:t}),</span>o=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",transform:"translate("+r+", 0)"});<span class="cstat-no" title="statement not covered" ></span>n.add(o);v</span>ar l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(a.config.yaxis[t].show)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;this.xaxisLabels.length;h++)<span class="cstat-no" title="statement not covered" >l.push(this.xaxisLabels[h]);<span class="cstat-no" title="statement not covered" >i</span></span></span>=-(e=a.globals.gridHeight/l.length)/2.2;v</span>ar c=<span class="cstat-no" title="statement not covered" >a.globals.yLabelFormatters[0],</span>d=<span class="cstat-no" title="statement not covered" >a.config.yaxis[0].labels;<span class="cstat-no" title="statement not covered" ></span>if(d.show)<span class="cstat-no" title="statement not covered" >for(var g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;=l.length-1;g++){var u=<span class="cstat-no" title="statement not covered" >void 0===l[g]?"":l[g];<span class="cstat-no" title="statement not covered" ></span>u=c(u,{seriesIndex:t,dataPointIndex:g,w:a});v</span>ar f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>Array.isArray(u)&amp;&amp;(f=u.length/2*parseInt(d.style.fontSize,10));v</span>ar x=<span class="cstat-no" title="statement not covered" >s.drawText({x:d.offsetX-15,y:i+e+d.offsetY-f,text:u,textAnchor:this.yaxis.opposite?"start":"end",foreColor:Array.isArray(d.style.colors)?d.style.colors[g]:d.style.colors,fontSize:d.style.fontSize,fontFamily:d.style.fontFamily,fontWeight:d.style.fontWeight,isPlainText:!1,cssClass:"apexcharts-yaxis-label "+d.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>o.add(x);v</span>ar b=<span class="cstat-no" title="statement not covered" >document.createElementNS(a.globals.SVGNS,"title");<span class="cstat-no" title="statement not covered" ></span>if(b.textContent=u.text,x.node.appendChild(b),0!==a.config.yaxis[t].labels.rotate){var m=<span class="cstat-no" title="statement not covered" >s.rotateAroundCenter(x.node);<span class="cstat-no" title="statement not covered" ></span>x.node.setAttribute("transform","rotate(".concat(a.config.yaxis[t].labels.rotate," 0 ").concat(m.y,")"))}<span class="cstat-no" title="statement not covered" ></span>i</span>+=e}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(void 0!==a.config.yaxis[0].title.text){var v=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-yaxis-title apexcharts-xaxis-title-inversed",transform:"translate("+r+", 0)"}),</span>y=<span class="cstat-no" title="statement not covered" >s.drawText({x:0,y:a.globals.gridHeight/2,text:a.config.yaxis[0].title.text,textAnchor:"middle",foreColor:a.config.yaxis[0].title.style.color,fontSize:a.config.yaxis[0].title.style.fontSize,fontWeight:a.config.yaxis[0].title.style.fontWeight,fontFamily:a.config.yaxis[0].title.style.fontFamily,cssClass:"apexcharts-yaxis-title-text "+a.config.yaxis[0].title.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>v.add(y),n.add(v)}</span>v</span>ar w=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.isCategoryBarHorizontal&amp;&amp;a.config.yaxis[0].opposite&amp;&amp;(w=a.globals.gridWidth);v</span>ar k=<span class="cstat-no" title="statement not covered" >a.config.xaxis.axisBorder;<span class="cstat-no" title="statement not covered" ></span>if(k.show){var A=<span class="cstat-no" title="statement not covered" >s.drawLine(a.globals.padHorizontal+k.offsetX+w,1+k.offsetY,a.globals.padHorizontal+k.offsetX+w,a.globals.gridHeight+k.offsetY,k.color,0);<span class="cstat-no" title="statement not covered" ></span>n.add(A)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.config.yaxis[0].axisTicks.show&amp;&amp;this.axesUtils.drawYAxisTicks(w,l.length,a.config.yaxis[0].axisBorder,a.config.yaxis[0].axisTicks,0,e,n),n}</span>},{key:"drawXaxisTicks",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(!(t&lt;0||t-2&gt;i.globals.gridWidth)){var s=<span class="cstat-no" title="statement not covered" >this.offY+i.config.xaxis.axisTicks.offsetY,</span>r=<span class="cstat-no" title="statement not covered" >s+i.config.xaxis.axisTicks.height;<span class="cstat-no" title="statement not covered" ></span>if("top"===i.config.xaxis.position&amp;&amp;(r=s-i.config.xaxis.axisTicks.height),i.config.xaxis.axisTicks.show){var n=<span class="cstat-no" title="statement not covered" >new p(this.ctx).drawLine(t+i.config.xaxis.axisTicks.offsetX,s+i.config.xaxis.offsetY,a+i.config.xaxis.axisTicks.offsetX,r+i.config.xaxis.offsetY,i.config.xaxis.axisTicks.color);<span class="cstat-no" title="statement not covered" ></span>e.add(n),n.node.classList.add("apexcharts-xaxis-tick")}</span>}</span>}</span>},{key:"getXAxisTicksPositions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >this.xaxisLabels.length,</span>a=<span class="cstat-no" title="statement not covered" >t.globals.padHorizontal;<span class="cstat-no" title="statement not covered" ></span>if(t.globals.timescaleLabels.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i;s++)<span class="cstat-no" title="statement not covered" >a=this.xaxisLabels[s].position,e.push(a);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >i,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;r;n++){var o=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>t.globals.isXNumeric&amp;&amp;"bar"!==t.config.chart.type&amp;&amp;(o-=1),a+=t.globals.gridWidth/o,e.push(a)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>},{key:"xAxisLabelCorrections",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>i=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),</span>a=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text"),</span>s=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),</span>r=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");<span class="cstat-no" title="statement not covered" ></span>if(t.globals.rotateXLabels||t.config.xaxis.labels.rotateAlways)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;a.length;n++){var o=<span class="cstat-no" title="statement not covered" >e.rotateAroundCenter(a[n]);<span class="cstat-no" title="statement not covered" ></span>o.y=o.y-1,o.x=o.x+1,a[n].setAttribute("transform","rotate(".concat(t.config.xaxis.labels.rotate," ").concat(o.x," ").concat(o.y,")")),a[n].setAttribute("text-anchor","end");<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("transform","translate(0, ".concat(-10,")"));v</span>ar l=<span class="cstat-no" title="statement not covered" >a[n].childNodes;<span class="cstat-no" title="statement not covered" ></span>t.config.xaxis.labels.trim&amp;&amp;Array.prototype.forEach.call(l,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >e.placeTextWithEllipsis(i,i.textContent,t.config.xaxis.labels.maxHeight-("bottom"===t.config.legend.position?20:10))}</span>))}</span>e</span>lse<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >t.globals.gridWidth/(t.globals.labels.length+1),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s++){var r=<span class="cstat-no" title="statement not covered" >a[s].childNodes;<span class="cstat-no" title="statement not covered" ></span>t.config.xaxis.labels.trim&amp;&amp;"datetime"!==t.config.xaxis.type&amp;&amp;Array.prototype.forEach.call(r,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.placeTextWithEllipsis(t,t.textContent,i)}</span>))}</span>}</span>();<span class="cstat-no" title="statement not covered" >i</span></span>f(s.length&gt;0){var h=<span class="cstat-no" title="statement not covered" >s[s.length-1].getBBox(),</span>c=<span class="cstat-no" title="statement not covered" >s[0].getBBox();<span class="cstat-no" title="statement not covered" ></span>h.x&lt;-20&amp;&amp;s[s.length-1].parentNode.removeChild(s[s.length-1]),c.x+c.width&gt;t.globals.gridWidth&amp;&amp;!t.globals.isBarHorizontal&amp;&amp;s[0].parentNode.removeChild(s[0]);<span class="cstat-no" title="statement not covered" >f</span>or(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;r.length;d++)<span class="cstat-no" title="statement not covered" >e.placeTextWithEllipsis(r[d],r[d].textContent,t.config.yaxis[0].labels.maxWidth-2*parseFloat(t.config.yaxis[0].title.style.fontSize)-20)}</span></span>}</span>}]),t}</span>(),</span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.xaxisLabels=a.globals.labels.slice(),this.axesUtils=new B(i),this.isTimelineBar="datetime"===a.config.xaxis.type&amp;&amp;a.globals.seriesRangeBarTimeline.length,a.globals.timescaleLabels.length&gt;0&amp;&amp;(this.xaxisLabels=a.globals.timescaleLabels.slice())}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawGridArea",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:null,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>null===t&amp;&amp;(t=i.group({class:"apexcharts-grid"}));v</span>ar a=<span class="cstat-no" title="statement not covered" >i.drawLine(e.globals.padHorizontal,1,e.globals.padHorizontal,e.globals.gridHeight,"transparent"),</span>s=<span class="cstat-no" title="statement not covered" >i.drawLine(e.globals.padHorizontal,e.globals.gridHeight,e.globals.gridWidth,e.globals.gridHeight,"transparent");<span class="cstat-no" title="statement not covered" ></span>return t.add(s),t.add(a),t}</span>},{key:"drawGrid",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this.w.globals.axisCharts&amp;&amp;(t=this.renderGrid(),this.drawGridArea(t.el)),t}</span>},{key:"createGridMask",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >Array.isArray(t.config.stroke.width)?0:t.config.stroke.width;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(t.config.stroke.width)){var s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.config.stroke.width.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >s=Math.max(s,t)}</span>)),a=s}<span class="cstat-no" title="statement not covered" ></span>e</span>.dom.elGridRectMask=document.createElementNS(e.SVGNS,"clipPath"),e.dom.elGridRectMask.setAttribute("id","gridRectMask".concat(e.cuid)),e.dom.elGridRectMarkerMask=document.createElementNS(e.SVGNS,"clipPath"),e.dom.elGridRectMarkerMask.setAttribute("id","gridRectMarkerMask".concat(e.cuid));v</span>ar r=<span class="cstat-no" title="statement not covered" >t.config.chart.type,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>("bar"===r||"rangeBar"===r||t.globals.comboBarCount&gt;0)&amp;&amp;t.globals.isXNumeric&amp;&amp;!t.globals.isBarHorizontal&amp;&amp;(n=t.config.grid.padding.left,o=t.config.grid.padding.right,e.barPadForNumericAxis&gt;n&amp;&amp;(n=e.barPadForNumericAxis,o=e.barPadForNumericAxis)),e.dom.elGridRect=i.drawRect(-a/2-n-2,-a/2,e.gridWidth+a+o+n+4,e.gridHeight+a,0,"#fff"),new m(this).getLargestMarkerSize();v</span>ar l=<span class="cstat-no" title="statement not covered" >t.globals.markers.largestSize+1;<span class="cstat-no" title="statement not covered" ></span>e.dom.elGridRectMarker=i.drawRect(2*-l,2*-l,e.gridWidth+4*l,e.gridHeight+4*l,0,"#fff"),e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node),e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);v</span>ar h=<span class="cstat-no" title="statement not covered" >e.dom.baseEl.querySelector("defs");<span class="cstat-no" title="statement not covered" ></span>h.appendChild(e.dom.elGridRectMask),h.appendChild(e.dom.elGridRectMarkerMask)}</span>},{key:"_drawGridLines",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.i,</span>i=<span class="cstat-no" title="statement not covered" >t.x1,</span>a=<span class="cstat-no" title="statement not covered" >t.y1,</span>s=<span class="cstat-no" title="statement not covered" >t.x2,</span>r=<span class="cstat-no" title="statement not covered" >t.y2,</span>n=<span class="cstat-no" title="statement not covered" >t.xCount,</span>o=<span class="cstat-no" title="statement not covered" >t.parent,</span>l=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>0===e&amp;&amp;l.globals.skipFirstTimelinelabel||e===n-1&amp;&amp;l.globals.skipLastTimelinelabel||"radar"===l.config.chart.type||(l.config.grid.xaxis.lines.show&amp;&amp;this._drawGridLine({x1:i,y1:a,x2:s,y2:r,parent:o}),new G(this.ctx).drawXaxisTicks(i,this.elg))}</span>},{key:"_drawGridLine",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.x1,</span>i=<span class="cstat-no" title="statement not covered" >t.y1,</span>a=<span class="cstat-no" title="statement not covered" >t.x2,</span>s=<span class="cstat-no" title="statement not covered" >t.y2,</span>r=<span class="cstat-no" title="statement not covered" >t.parent,</span>n=<span class="cstat-no" title="statement not covered" >this.w,</span>o=<span class="cstat-no" title="statement not covered" >r.node.classList.contains("apexcharts-gridlines-horizontal"),</span>l=<span class="cstat-no" title="statement not covered" >n.config.grid.strokeDashArray,</span>h=<span class="cstat-no" title="statement not covered" >n.globals.barPadForNumericAxis,</span>c=<span class="cstat-no" title="statement not covered" >new p(this).drawLine(e-(o?h:0),i,a+(o?h:0),s,n.config.grid.borderColor,l);<span class="cstat-no" title="statement not covered" ></span>c.node.classList.add("apexcharts-gridline"),r.add(c)}</span>},{key:"_drawGridBandRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.c,</span>i=<span class="cstat-no" title="statement not covered" >t.x1,</span>a=<span class="cstat-no" title="statement not covered" >t.y1,</span>s=<span class="cstat-no" title="statement not covered" >t.x2,</span>r=<span class="cstat-no" title="statement not covered" >t.y2,</span>n=<span class="cstat-no" title="statement not covered" >t.type,</span>o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>h=<span class="cstat-no" title="statement not covered" >o.globals.barPadForNumericAxis;<span class="cstat-no" title="statement not covered" ></span>if("column"!==n||"datetime"!==o.config.xaxis.type){var c=<span class="cstat-no" title="statement not covered" >o.config.grid[n].colors[e],</span>d=<span class="cstat-no" title="statement not covered" >l.drawRect(i-("row"===n?h:0),a,s+("row"===n?2*h:0),r,0,c,o.config.grid[n].opacity);<span class="cstat-no" title="statement not covered" ></span>this.elg.add(d),d.attr("clip-path","url(#gridRectMask".concat(o.globals.cuid,")")),d.node.classList.add("apexcharts-grid-".concat(n))}</span>}</span>},{key:"_drawXYLines",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >t.xCount,</span>a=<span class="cstat-no" title="statement not covered" >t.tickAmount,</span>s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(s.config.grid.xaxis.lines.show||s.config.xaxis.axisTicks.show){var r=<span class="cstat-no" title="statement not covered" >s.globals.padHorizontal,</span>n=<span class="cstat-no" title="statement not covered" >s.globals.gridHeight;<span class="cstat-no" title="statement not covered" ></span>s.globals.timescaleLabels.length?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >t.xC,</span>s=<span class="cstat-no" title="statement not covered" >t.x1,</span>r=<span class="cstat-no" title="statement not covered" >t.y1,</span>n=<span class="cstat-no" title="statement not covered" >t.x2,</span>o=<span class="cstat-no" title="statement not covered" >t.y2,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;a;l++)<span class="cstat-no" title="statement not covered" >s=e.xaxisLabels[l].position,n=e.xaxisLabels[l].position,e._drawGridLines({i:l,x1:s,y1:r,x2:n,y2:o,xCount:i,parent:e.elgridLinesV})}</span></span>({xC:i,x1:r,y1:0,x2:void 0,y2:n}):(s.globals.isXNumeric&amp;&amp;(i=s.globals.xAxisScale.result.length),s.config.xaxis.convertedCatToNumeric&amp;&amp;(i=s.globals.xaxisLabelsCount),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >t.xC,</span>r=<span class="cstat-no" title="statement not covered" >t.x1,</span>n=<span class="cstat-no" title="statement not covered" >t.y1,</span>o=<span class="cstat-no" title="statement not covered" >t.x2,</span>l=<span class="cstat-no" title="statement not covered" >t.y2,</span>h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;a+(s.globals.isXNumeric?0:1);h++)<span class="cstat-no" title="statement not covered" >0===h&amp;&amp;1===a&amp;&amp;1===s.globals.dataPoints&amp;&amp;(o=r=s.globals.gridWidth/2),e._drawGridLines({i:h,x1:r,y1:n,x2:o,y2:l,xCount:i,parent:e.elgridLinesV}),o=r+=s.globals.gridWidth/(s.globals.isXNumeric?a-1:a)}</span></span>({xC:i,x1:r,y1:0,x2:void 0,y2:n}))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.config.grid.yaxis.lines.show){var o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >s.globals.gridWidth,</span>c=<span class="cstat-no" title="statement not covered" >a+1;<span class="cstat-no" title="statement not covered" ></span>this.isTimelineBar&amp;&amp;(c=s.globals.labels.length);<span class="cstat-no" title="statement not covered" >f</span>or(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;c+(this.isTimelineBar?1:0);d++)<span class="cstat-no" title="statement not covered" >this._drawGridLine({x1:0,y1:o,x2:h,y2:l,parent:this.elgridLinesH}),l=o+=s.globals.gridHeight/(this.isTimelineBar?c:a)}</span></span>}</span>},{key:"_drawInvertedXYLines",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.xCount,</span>i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(i.config.grid.xaxis.lines.show||i.config.xaxis.axisTicks.show)<span class="cstat-no" title="statement not covered" >for(var a,s=<span class="cstat-no" title="statement not covered" >i.globals.padHorizontal,</span>r=<span class="cstat-no" title="statement not covered" >i.globals.gridHeight,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e+1;n++){<span class="cstat-no" title="statement not covered" >i.config.grid.xaxis.lines.show&amp;&amp;this._drawGridLine({x1:s,y1:0,x2:a,y2:r,parent:this.elgridLinesV}),new G(this.ctx).drawXaxisTicks(s,this.elg),a=s=s+i.globals.gridWidth/e+.3}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(i.config.grid.yaxis.lines.show)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >i.globals.gridWidth,</span>c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;i.globals.dataPoints+1;c++)<span class="cstat-no" title="statement not covered" >this._drawGridLine({x1:0,y1:o,x2:h,y2:l,parent:this.elgridLinesH}),l=o+=i.globals.gridHeight/i.globals.dataPoints}</span></span></span>},{key:"renderGrid",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.elg=e.group({class:"apexcharts-grid"}),this.elgridLinesH=e.group({class:"apexcharts-gridlines-horizontal"}),this.elgridLinesV=e.group({class:"apexcharts-gridlines-vertical"}),this.elg.add(this.elgridLinesH),this.elg.add(this.elgridLinesV),t.config.grid.show||(this.elgridLinesV.hide(),this.elgridLinesH.hide());<span class="cstat-no" title="statement not covered" >f</span>or(var i,a=<span class="cstat-no" title="statement not covered" >t.globals.yAxisScale.length?t.globals.yAxisScale[0].result.length-1:5,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.globals.series.length&amp;&amp;(void 0!==t.globals.yAxisScale[s]&amp;&amp;(a=t.globals.yAxisScale[s].result.length-1),!(a&gt;2));s++);<span class="cstat-no" title="statement not covered" >r</span>eturn!t.globals.isBarHorizontal||this.isTimelineBar?(i=this.xaxisLabels.length,this.isTimelineBar&amp;&amp;(a=t.globals.labels.length),this._drawXYLines({xCount:i,tickAmount:a})):(i=a,a=t.globals.xTickAmount,this._drawInvertedXYLines({xCount:i,tickAmount:a})),this.drawGridBands(i,a),{el:this.elg,xAxisTickWidth:t.globals.gridWidth/i}}</span>},{key:"drawGridBands",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i.config.grid.row.colors&amp;&amp;i.config.grid.row.colors.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >i.globals.gridHeight/e,</span>r=<span class="cstat-no" title="statement not covered" >i.globals.gridWidth,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;n++,o++)<span class="cstat-no" title="statement not covered" >o&gt;=i.config.grid.row.colors.length&amp;&amp;(o=0),this._drawGridBandRect({c:o,x1:0,y1:a,x2:r,y2:s,type:"row"}),a+=i.globals.gridHeight/e;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(void 0!==i.config.grid.column.colors&amp;&amp;i.config.grid.column.colors.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var l=<span class="cstat-no" title="statement not covered" >i.globals.isBarHorizontal||"category"!==i.config.xaxis.type&amp;&amp;!i.config.xaxis.convertedCatToNumeric?t:t-1,</span>h=<span class="cstat-no" title="statement not covered" >i.globals.padHorizontal,</span>c=<span class="cstat-no" title="statement not covered" >i.globals.padHorizontal+i.globals.gridWidth/l,</span>d=<span class="cstat-no" title="statement not covered" >i.globals.gridHeight,</span>g=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;t;g++,u++)<span class="cstat-no" title="statement not covered" >u&gt;=i.config.grid.column.colors.length&amp;&amp;(u=0),this._drawGridBandRect({c:u,x1:h,y1:0,x2:c,y2:d,type:"column"}),h+=i.globals.gridWidth/l}</span></span></span>}]),t}</span>(),</span>j=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"niceScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:10,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:0,</span>s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4?arguments[4]:void 0,</span>r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if("dataPoints"===i&amp;&amp;(i=r.globals.dataPoints-1),t===Number.MIN_VALUE&amp;&amp;0===e||!g.isNumber(t)&amp;&amp;!g.isNumber(e)||t===Number.MIN_VALUE&amp;&amp;e===-Number.MAX_VALUE){<span class="cstat-no" title="statement not covered" >t=0,e=i;v</span>ar n=<span class="cstat-no" title="statement not covered" >this.linearScale(t,e,i);<span class="cstat-no" title="statement not covered" ></span>return n}<span class="cstat-no" title="statement not covered" ></span>t</span>&gt;e?(console.warn("axis.min cannot be greater than axis.max"),e=t+.1):t===e&amp;&amp;(t=0===t?0:t-.5,e=0===e?2:e+.5);v</span>ar o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >Math.abs(e-t);<span class="cstat-no" title="statement not covered" ></span>l&lt;1&amp;&amp;s&amp;&amp;("candlestick"===r.config.chart.type||"candlestick"===r.config.series[a].type||r.globals.isRangeData)&amp;&amp;(e*=1.01);v</span>ar h=<span class="cstat-no" title="statement not covered" >i+1;<span class="cstat-no" title="statement not covered" ></span>h&lt;2?h=2:h&gt;2&amp;&amp;(h-=2);v</span>ar c=<span class="cstat-no" title="statement not covered" >l/h,</span>d=<span class="cstat-no" title="statement not covered" >Math.floor(g.log10(c)),</span>u=<span class="cstat-no" title="statement not covered" >Math.pow(10,d),</span>f=<span class="cstat-no" title="statement not covered" >Math.round(c/u);<span class="cstat-no" title="statement not covered" ></span>f&lt;1&amp;&amp;(f=1);v</span>ar p=<span class="cstat-no" title="statement not covered" >f*u,</span>x=<span class="cstat-no" title="statement not covered" >p*Math.floor(t/p),</span>b=<span class="cstat-no" title="statement not covered" >p*Math.ceil(e/p),</span>m=<span class="cstat-no" title="statement not covered" >x;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;l&gt;2){<span class="cstat-no" title="statement not covered" >for(;o.push(m),!((m+=p)&gt;b););<span class="cstat-no" title="statement not covered" >r</span>eturn{result:o,niceMin:o[0],niceMax:o[o.length-1]}}</span>v</span>ar v=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>(o=[]).push(v);<span class="cstat-no" title="statement not covered" >f</span>or(var y=<span class="cstat-no" title="statement not covered" >Math.abs(e-t)/i,</span>w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;=i;w++)<span class="cstat-no" title="statement not covered" >v+=y,o.push(v);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o[o.length-2]&gt;=e&amp;&amp;o.pop(),{result:o,niceMin:o[0],niceMax:o[o.length-1]}}</span>},{key:"linearScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:10,</span>a=<span class="cstat-no" title="statement not covered" >Math.abs(e-t),</span>s=<span class="cstat-no" title="statement not covered" >a/i;<span class="cstat-no" title="statement not covered" ></span>i===Number.MAX_VALUE&amp;&amp;(i=10,s=1);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t;</span>i&gt;=0;)<span class="cstat-no" title="statement not covered" >r.push(n),n+=s,i-=1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{result:r,niceMin:r[0],niceMax:r[r.length-1]}}</span>},{key:"logarithmicScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >(e&lt;0||e===Number.MIN_VALUE)&amp;&amp;(e=.01);<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >Math.log(e)/Math.log(10),</span>r=<span class="cstat-no" title="statement not covered" >Math.log(i)/Math.log(10),</span>n=<span class="cstat-no" title="statement not covered" >Math.abs(i-e)/a,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >e;</span>a&gt;=0;)<span class="cstat-no" title="statement not covered" >o.push(l),l+=n,a-=1;v</span></span>ar h=<span class="cstat-no" title="statement not covered" >o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >t&lt;=0&amp;&amp;(t=.01);v</span>ar n=<span class="cstat-no" title="statement not covered" >(r-s)/(i-e),</span>o=<span class="cstat-no" title="statement not covered" >Math.pow(10,s+n*(t-s));<span class="cstat-no" title="statement not covered" ></span>return Math.round(o/g.roundToBase(o,10))*g.roundToBase(o,10)}</span>));<span class="cstat-no" title="statement not covered" ></span>return 0===h[0]&amp;&amp;(h[0]=1),{result:h,niceMin:h[0],niceMax:h[h.length-1]}}</span>},{key:"setYScaleForIndex",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>s=<span class="cstat-no" title="statement not covered" >this.w.config,</span>r=<span class="cstat-no" title="statement not covered" >a.isBarHorizontal?s.xaxis:s.yaxis[t];<span class="cstat-no" title="statement not covered" ></span>void 0===a.yAxisScale[t]&amp;&amp;(a.yAxisScale[t]=[]);v</span>ar n=<span class="cstat-no" title="statement not covered" >Math.abs(i-e);<span class="cstat-no" title="statement not covered" ></span>if(r.logarithmic&amp;&amp;n&lt;=5&amp;&amp;(a.invalidLogScale=!0),r.logarithmic&amp;&amp;n&gt;5)<span class="cstat-no" title="statement not covered" >a.allSeriesCollapsed=!1,a.yAxisScale[t]=this.logarithmicScale(t,e,i,r.tickAmount?r.tickAmount:Math.floor(Math.log10(i)));e</span>lse <span class="cstat-no" title="statement not covered" >if(i!==-Number.MAX_VALUE&amp;&amp;g.isNumber(i))<span class="cstat-no" title="statement not covered" >if(a.allSeriesCollapsed=!1,void 0===r.min&amp;&amp;void 0===r.max||r.forceNiceScale){var o=<span class="cstat-no" title="statement not covered" >void 0===s.yaxis[t].max&amp;&amp;void 0===s.yaxis[t].min||s.yaxis[t].forceNiceScale;<span class="cstat-no" title="statement not covered" ></span>a.yAxisScale[t]=this.niceScale(e,i,r.tickAmount?r.tickAmount:n&lt;5&amp;&amp;n&gt;1?n+1:5,t,o)}</span>else <span class="cstat-no" title="statement not covered" >a.yAxisScale[t]=this.linearScale(e,i,r.tickAmount);e</span></span>lse <span class="cstat-no" title="statement not covered" >a.yAxisScale[t]=this.linearScale(0,5,5)}</span></span></span>},{key:"setXScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals,</span>s=<span class="cstat-no" title="statement not covered" >i.config.xaxis,</span>r=<span class="cstat-no" title="statement not covered" >Math.abs(e-t);<span class="cstat-no" title="statement not covered" ></span>return e!==-Number.MAX_VALUE&amp;&amp;g.isNumber(e)?a.xAxisScale=this.niceScale(t,e,s.tickAmount?s.tickAmount:r&lt;5&amp;&amp;r&gt;1?r+1:5,0):a.xAxisScale=this.linearScale(0,5,5),a.xAxisScale}</span>},{key:"setMultipleYScales",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>i=<span class="cstat-no" title="statement not covered" >this.w.config,</span>a=<span class="cstat-no" title="statement not covered" >e.minYArr.concat([]),</span>s=<span class="cstat-no" title="statement not covered" >e.maxYArr.concat([]),</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var o=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>i.series.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.name===e.seriesName&amp;&amp;(o=i,n!==i?r.push({index:i,similarIndex:n,alreadyExists:!0}):r.push({index:i}))}</span>));v</span>ar l=<span class="cstat-no" title="statement not covered" >a[o],</span>h=<span class="cstat-no" title="statement not covered" >s[o];<span class="cstat-no" title="statement not covered" ></span>t.setYScaleForIndex(n,l,h)}</span>)),this.sameScaleInMultipleAxes(a,s,r)}</span>},{key:"sameScaleInMultipleAxes",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.w.config,</span>r=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.alreadyExists&amp;&amp;(void 0===n[t.index]&amp;&amp;(n[t.index]=[]),n[t.index].push(t.index),n[t.index].push(t.similarIndex))}</span>)),r.yAxisSameScaleIndices=n,n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){var s,r;<span class="cstat-no" title="statement not covered" >e!==a&amp;&amp;(s=t,r=i,s.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return-1!==r.indexOf(t)}</span>))).length&gt;0&amp;&amp;(n[e]=n[e].concat(n[a]))}</span>))}</span>));v</span>ar o=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >return t.indexOf(e)===i}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.sort()}</span>));<span class="cstat-no" title="statement not covered" ></span>n=n.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!!t}</span>));v</span>ar l=<span class="cstat-no" title="statement not covered" >o.slice(),</span>h=<span class="cstat-no" title="statement not covered" >l.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return JSON.stringify(t)}</span>));<span class="cstat-no" title="statement not covered" ></span>l=l.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return h.indexOf(JSON.stringify(t))===e}</span>));v</span>ar c=<span class="cstat-no" title="statement not covered" >[],</span>d=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >l.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(a,s){<span class="cstat-no" title="statement not covered" >a.indexOf(i)&gt;-1&amp;&amp;(void 0===c[s]&amp;&amp;(c[s]=[],d[s]=[]),c[s].push({key:i,value:t}),d[s].push({key:i,value:e[i]}))}</span>))}</span>));v</span>ar g=<span class="cstat-no" title="statement not covered" >Array.apply(null,Array(l.length)).map(Number.prototype.valueOf,Number.MIN_VALUE),</span>u=<span class="cstat-no" title="statement not covered" >Array.apply(null,Array(l.length)).map(Number.prototype.valueOf,-Number.MAX_VALUE);<span class="cstat-no" title="statement not covered" ></span>c.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >g[e]=Math.min(t.value,g[e])}</span>))}</span>)),d.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >u[e]=Math.max(t.value,u[e])}</span>))}</span>)),t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >d.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >g[i],</span>o=<span class="cstat-no" title="statement not covered" >u[i];<span class="cstat-no" title="statement not covered" ></span>s.chart.stacked&amp;&amp;(o=0,t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.value!==-Number.MAX_VALUE&amp;&amp;(o+=t.value),n!==Number.MIN_VALUE&amp;&amp;(n+=c[i][e].value)}</span>))),t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i,l){<span class="cstat-no" title="statement not covered" >t[l].key===e&amp;&amp;(void 0!==s.yaxis[e].min&amp;&amp;(n="function"==typeof s.yaxis[e].min?s.yaxis[e].min(r.minY):s.yaxis[e].min),void 0!==s.yaxis[e].max&amp;&amp;(o="function"==typeof s.yaxis[e].max?s.yaxis[e].max(r.maxY):s.yaxis[e].max),a.setYScaleForIndex(e,n,o))}</span>))}</span>))}</span>))}</span>},{key:"autoScaleY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t||(t=this);v</span>ar a=<span class="cstat-no" title="statement not covered" >t.w;<span class="cstat-no" title="statement not covered" ></span>if(a.globals.isMultipleYAxis||a.globals.collapsedSeries.length)<span class="cstat-no" title="statement not covered" >return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."),e;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >a.globals.seriesX[0],</span>r=<span class="cstat-no" title="statement not covered" >a.config.chart.stacked;<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;s.length;l++)<span class="cstat-no" title="statement not covered" >if(s[l]&gt;=i.xaxis.min){<span class="cstat-no" title="statement not covered" >o=l;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>v</span></span>ar h,c,d=<span class="cstat-no" title="statement not covered" >a.globals.minYArr[n],</span>g=<span class="cstat-no" title="statement not covered" >a.globals.maxYArr[n],</span>u=<span class="cstat-no" title="statement not covered" >a.globals.stackedSeriesTotals;<span class="cstat-no" title="statement not covered" ></span>a.globals.series.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n,l){var f=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>r?(f=u[o],h=c=f,u.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >s[e]&lt;=i.xaxis.max&amp;&amp;s[e]&gt;=i.xaxis.min&amp;&amp;(t&gt;c&amp;&amp;null!==t&amp;&amp;(c=t),n[e]&lt;h&amp;&amp;null!==n[e]&amp;&amp;(h=n[e]))}</span>))):(h=c=f,n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(s[e]&lt;=i.xaxis.max&amp;&amp;s[e]&gt;=i.xaxis.min){var r=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>a.globals.series.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){<span class="cstat-no" title="statement not covered" >null!==t&amp;&amp;(r=Math.min(i[e],r),n=Math.max(i[e],n))}</span>)),n&gt;c&amp;&amp;null!==n&amp;&amp;(c=n),r&lt;h&amp;&amp;null!==r&amp;&amp;(h=r)}</span>}</span>))),void 0===h&amp;&amp;void 0===c&amp;&amp;(h=d,c=g),(c*=c&lt;0?.9:1.1)&lt;0&amp;&amp;c&lt;g&amp;&amp;(c=g),(h*=h&lt;0?1.1:.9)&lt;0&amp;&amp;h&gt;d&amp;&amp;(h=d),e.length&gt;1?(e[l].min=void 0===t.min?h:t.min,e[l].max=void 0===t.max?c:t.max):(e[0].min=void 0===t.min?h:t.min,e[0].max=void 0===t.max?c:t.max)}</span>))}</span>)),e}</span>}]),t}</span>(),</span>U=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.scales=new j(i)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.setYRange(),this.setXRange(),this.setZRange()}</span>},{key:"getMinYMaxY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE,</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:-Number.MAX_VALUE,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:null,</span>s=<span class="cstat-no" title="statement not covered" >this.w.config,</span>r=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>n=<span class="cstat-no" title="statement not covered" >-Number.MAX_VALUE,</span>o=<span class="cstat-no" title="statement not covered" >Number.MIN_VALUE;<span class="cstat-no" title="statement not covered" ></span>null===a&amp;&amp;(a=t+1);v</span>ar l=<span class="cstat-no" title="statement not covered" >r.series,</span>h=<span class="cstat-no" title="statement not covered" >l,</span>c=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>"candlestick"===s.chart.type?(h=r.seriesCandleL,c=r.seriesCandleH):r.isRangeData&amp;&amp;(h=r.seriesRangeStart,c=r.seriesRangeEnd);<span class="cstat-no" title="statement not covered" >f</span>or(var d=<span class="cstat-no" title="statement not covered" >t;</span>d&lt;a;d++){<span class="cstat-no" title="statement not covered" >r.dataPoints=Math.max(r.dataPoints,l[d].length);<span class="cstat-no" title="statement not covered" >f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;r.series[d].length;u++){var f=<span class="cstat-no" title="statement not covered" >l[d][u];<span class="cstat-no" title="statement not covered" ></span>null!==f&amp;&amp;g.isNumber(f)?(n=Math.max(n,c[d][u]),e=Math.min(e,h[d][u]),i=Math.max(i,h[d][u]),"candlestick"===this.w.config.chart.type&amp;&amp;(n=Math.max(n,r.seriesCandleO[d][u]),n=Math.max(n,r.seriesCandleH[d][u]),n=Math.max(n,r.seriesCandleL[d][u]),i=n=Math.max(n,r.seriesCandleC[d][u])),g.isFloat(f)&amp;&amp;(f=g.noExponents(f),r.yValueDecimal=Math.max(r.yValueDecimal,f.toString().split(".")[1].length)),o&gt;h[d][u]&amp;&amp;h[d][u]&lt;0&amp;&amp;(o=h[d][u])):r.hasNullValues=!0}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"rangeBar"===s.chart.type&amp;&amp;r.seriesRangeStart.length&amp;&amp;r.isBarHorizontal&amp;&amp;"datetime"===s.xaxis.type&amp;&amp;(o=e),"bar"===s.chart.type&amp;&amp;(o&lt;0&amp;&amp;n&lt;0&amp;&amp;(n=0),o===Number.MIN_VALUE&amp;&amp;(o=0)),{minY:o,maxY:n,lowestY:e,highestY:i}}</span>},{key:"setYRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >this.w.config;<span class="cstat-no" title="statement not covered" ></span>t.maxY=-Number.MAX_VALUE,t.minY=Number.MIN_VALUE;v</span>ar i=<span class="cstat-no" title="statement not covered" >Number.MAX_VALUE;<span class="cstat-no" title="statement not covered" ></span>if(t.isMultipleYAxis)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.series.length;a++){var s=<span class="cstat-no" title="statement not covered" >this.getMinYMaxY(a,i,null,a+1);<span class="cstat-no" title="statement not covered" ></span>t.minYArr.push(s.minY),t.maxYArr.push(s.maxY),i=s.lowestY}</span>v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.getMinYMaxY(0,i,null,t.series.length);<span class="cstat-no" title="statement not covered" ></span>if(t.minY=r.minY,t.maxY=r.maxY,i=r.lowestY,e.chart.stacked&amp;&amp;this._setStackedMinMax(),("line"===e.chart.type||"area"===e.chart.type||"candlestick"===e.chart.type||"rangeBar"===e.chart.type&amp;&amp;!t.isBarHorizontal)&amp;&amp;t.minY===Number.MIN_VALUE&amp;&amp;i!==-Number.MAX_VALUE&amp;&amp;i!==t.maxY){var n=<span class="cstat-no" title="statement not covered" >t.maxY-i;<span class="cstat-no" title="statement not covered" ></span>i&gt;=0&amp;&amp;i&lt;=10&amp;&amp;(n=0),t.minY=i-5*n/100,i&gt;0&amp;&amp;t.minY&lt;0&amp;&amp;(t.minY=0),t.maxY=t.maxY+5*n/100}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >void 0!==e.max&amp;&amp;("number"==typeof e.max?t.maxYArr[i]=e.max:"function"==typeof e.max&amp;&amp;(t.maxYArr[i]=e.max(t.maxY)),t.maxY=t.maxYArr[i]),void 0!==e.min&amp;&amp;("number"==typeof e.min?t.minYArr[i]=e.min:"function"==typeof e.min&amp;&amp;(t.minYArr[i]=e.min(t.minY)),t.minY=t.minYArr[i])}</span>)),t.isBarHorizontal){<span class="cstat-no" title="statement not covered" >["min","max"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >void 0!==e.xaxis[i]&amp;&amp;"number"==typeof e.xaxis[i]&amp;&amp;("min"===i?t.minY=e.xaxis[i]:t.maxY=e.xaxis[i])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.isMultipleYAxis?(this.scales.setMultipleYScales(),t.minY=i,t.yAxisScale.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >t.minYArr[i]=e.niceMin,t.maxYArr[i]=e.niceMax}</span>))):(this.scales.setYScaleForIndex(0,t.minY,t.maxY),t.minY=t.yAxisScale[0].niceMin,t.maxY=t.yAxisScale[0].niceMax,t.minYArr[0]=t.yAxisScale[0].niceMin,t.maxYArr[0]=t.yAxisScale[0].niceMax),{minY:t.minY,maxY:t.maxY,minYArr:t.minYArr,maxYArr:t.maxYArr}}</span>},{key:"setXRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >this.w.config,</span>i=<span class="cstat-no" title="statement not covered" >"numeric"===e.xaxis.type||"datetime"===e.xaxis.type||"category"===e.xaxis.type&amp;&amp;!t.noLabelsProvided||t.noLabelsProvided||t.isXNumeric;<span class="cstat-no" title="statement not covered" ></span>if(t.isXNumeric&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.series.length;e++)<span class="cstat-no" title="statement not covered" >if(t.labels[e])<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.labels[e].length;i++)<span class="cstat-no" title="statement not covered" >null!==t.labels[e][i]&amp;&amp;g.isNumber(t.labels[e][i])&amp;&amp;(t.maxX=Math.max(t.maxX,t.labels[e][i]),t.initialMaxX=Math.max(t.maxX,t.labels[e][i]),t.minX=Math.min(t.minX,t.labels[e][i]),t.initialMinX=Math.min(t.minX,t.labels[e][i]))}</span></span></span></span>(),t.noLabelsProvided&amp;&amp;0===e.xaxis.categories.length&amp;&amp;(t.maxX=t.labels[t.labels.length-1],t.initialMaxX=t.labels[t.labels.length-1],t.minX=1,t.initialMinX=1),t.isXNumeric||t.noLabelsProvided||t.dataFormatXNumeric){var a;<span class="cstat-no" title="statement not covered" >if(void 0===e.xaxis.tickAmount?(a=Math.round(t.svgWidth/150),"numeric"===e.xaxis.type&amp;&amp;t.dataPoints&lt;30&amp;&amp;(a=t.dataPoints-1),a&gt;t.dataPoints&amp;&amp;0!==t.dataPoints&amp;&amp;(a=t.dataPoints-1)):"dataPoints"===e.xaxis.tickAmount?(t.series.length&gt;1&amp;&amp;(a=t.series[t.maxValsInArrayIndex].length-1),t.isXNumeric&amp;&amp;(a=t.maxX-t.minX-1)):a=e.xaxis.tickAmount,t.xTickAmount=a,void 0!==e.xaxis.max&amp;&amp;"number"==typeof e.xaxis.max&amp;&amp;(t.maxX=e.xaxis.max),void 0!==e.xaxis.min&amp;&amp;"number"==typeof e.xaxis.min&amp;&amp;(t.minX=e.xaxis.min),void 0!==e.xaxis.range&amp;&amp;(t.minX=t.maxX-e.xaxis.range),t.minX!==Number.MAX_VALUE&amp;&amp;t.maxX!==-Number.MAX_VALUE)<span class="cstat-no" title="statement not covered" >if(e.xaxis.convertedCatToNumeric&amp;&amp;!t.dataFormatXNumeric){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >t.minX-1;</span>r&lt;t.maxX;r++)<span class="cstat-no" title="statement not covered" >s.push(r+1);<span class="cstat-no" title="statement not covered" >t</span></span>.xAxisScale={result:s,niceMin:s[0],niceMax:s[s.length-1]}}</span>else <span class="cstat-no" title="statement not covered" >t.xAxisScale=this.scales.setXScale(t.minX,t.maxX);e</span></span>lse <span class="cstat-no" title="statement not covered" >t.xAxisScale=this.scales.linearScale(1,a,a),t.noLabelsProvided&amp;&amp;t.labels.length&gt;0&amp;&amp;(t.xAxisScale=this.scales.linearScale(1,t.labels.length,a-1),t.seriesX=t.labels.slice());<span class="cstat-no" title="statement not covered" >i</span></span>&amp;&amp;(t.labels=t.xAxisScale.result.slice())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.isBarHorizontal&amp;&amp;t.labels.length&amp;&amp;(t.xTickAmount=t.labels.length),this._handleSingleDataPoint(),this._getMinXDiff(),{minX:t.minX,maxX:t.maxX}}</span>},{key:"setZRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>if(t.isDataXYZ)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.series.length;e++)<span class="cstat-no" title="statement not covered" >if(void 0!==t.seriesZ[e])<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.seriesZ[e].length;i++)<span class="cstat-no" title="statement not covered" >null!==t.seriesZ[e][i]&amp;&amp;g.isNumber(t.seriesZ[e][i])&amp;&amp;(t.maxZ=Math.max(t.maxZ,t.seriesZ[e][i]),t.minZ=Math.min(t.minZ,t.seriesZ[e][i]))}</span></span></span></span></span>},{key:"_handleSingleDataPoint",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >this.w.config;<span class="cstat-no" title="statement not covered" ></span>if(t.minX===t.maxX){var i=<span class="cstat-no" title="statement not covered" >new Y(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if("datetime"===e.xaxis.type){var a=<span class="cstat-no" title="statement not covered" >i.getDate(t.minX);<span class="cstat-no" title="statement not covered" ></span>a.setUTCDate(a.getDate()-2),t.minX=new Date(a).getTime();v</span>ar s=<span class="cstat-no" title="statement not covered" >i.getDate(t.maxX);<span class="cstat-no" title="statement not covered" ></span>s.setUTCDate(s.getDate()+2),t.maxX=new Date(s).getTime()}</span>else<span class="cstat-no" title="statement not covered" >("numeric"===e.xaxis.type||"category"===e.xaxis.type&amp;&amp;!t.noLabelsProvided)&amp;&amp;(t.minX=t.minX-2,t.initialMinX=t.minX,t.maxX=t.maxX+2,t.initialMaxX=t.maxX)}</span></span>}</span>},{key:"_getMinXDiff",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>t.isXNumeric&amp;&amp;t.seriesX.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >1===e.length&amp;&amp;e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length-1]);v</span>ar a=<span class="cstat-no" title="statement not covered" >e.slice();<span class="cstat-no" title="statement not covered" ></span>a.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t-e}</span>)),a.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >if(a&gt;0){var s=<span class="cstat-no" title="statement not covered" >e-t.seriesX[i][a-1];<span class="cstat-no" title="statement not covered" ></span>s&gt;0&amp;&amp;(t.minXDiff=Math.min(s,t.minXDiff))}</span>}</span>)),1===t.dataPoints&amp;&amp;t.minXDiff===Number.MAX_VALUE&amp;&amp;(t.minXDiff=.5)}</span>))}</span>},{key:"_setStackedMinMax",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t.series.length)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.series[t.maxValsInArrayIndex].length;a++)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.series.length;n++)<span class="cstat-no" title="statement not covered" >null!==t.series[n][a]&amp;&amp;g.isNumber(t.series[n][a])&amp;&amp;(t.series[n][a]&gt;0?s=s+parseFloat(t.series[n][a])+1e-4:r+=parseFloat(t.series[n][a])),n===t.series.length-1&amp;&amp;(e.push(s),i.push(r));<span class="cstat-no" title="statement not covered" >f</span></span></span></span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.length;o++)<span class="cstat-no" title="statement not covered" >t.maxY=Math.max(t.maxY,e[o]),t.minY=Math.min(t.minY,i[o])}</span></span>}]),t}</span>(),</span>q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.xaxisFontSize=a.config.xaxis.labels.style.fontSize,this.axisFontFamily=a.config.xaxis.labels.style.fontFamily,this.xaxisForeColors=a.config.xaxis.labels.style.colors,this.isCategoryBarHorizontal="bar"===a.config.chart.type&amp;&amp;a.config.plotOptions.bar.horizontal,this.xAxisoffX=0,"bottom"===a.config.xaxis.position&amp;&amp;(this.xAxisoffX=a.globals.gridHeight),this.drawnLabels=[],this.axesUtils=new B(i)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawYaxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >e.config.yaxis[t].labels.style,</span>s=<span class="cstat-no" title="statement not covered" >a.fontSize,</span>r=<span class="cstat-no" title="statement not covered" >a.fontFamily,</span>n=<span class="cstat-no" title="statement not covered" >a.fontWeight,</span>o=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-yaxis",rel:t,transform:"translate("+e.globals.translateYAxisX[t]+", 0)"});<span class="cstat-no" title="statement not covered" ></span>if(this.axesUtils.isYAxisHidden(t))<span class="cstat-no" title="statement not covered" >return o;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-yaxis-texts-g"});<span class="cstat-no" title="statement not covered" ></span>o.add(l);v</span>ar h=<span class="cstat-no" title="statement not covered" >e.globals.yAxisScale[t].result.length-1,</span>c=<span class="cstat-no" title="statement not covered" >e.globals.gridHeight/h,</span>d=<span class="cstat-no" title="statement not covered" >e.globals.translateY,</span>g=<span class="cstat-no" title="statement not covered" >e.globals.yLabelFormatters[t],</span>u=<span class="cstat-no" title="statement not covered" >e.globals.yAxisScale[t].result.slice();<span class="cstat-no" title="statement not covered" ></span>u=this.axesUtils.checkForReversedLabels(t,u);v</span>ar f=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(e.config.yaxis[t].labels.show)<span class="cstat-no" title="statement not covered" >for(var x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(o){var p=<span class="cstat-no" title="statement not covered" >u[o];<span class="cstat-no" title="statement not covered" ></span>p=g(p,o);v</span>ar x=<span class="cstat-no" title="statement not covered" >e.config.yaxis[t].labels.padding;<span class="cstat-no" title="statement not covered" ></span>e.config.yaxis[t].opposite&amp;&amp;0!==e.config.yaxis.length&amp;&amp;(x*=-1);v</span>ar b=<span class="cstat-no" title="statement not covered" >i.drawText({x:x,y:d+h/10+e.config.yaxis[t].labels.offsetY+1,text:p,textAnchor:e.config.yaxis[t].opposite?"start":"end",fontSize:s,fontFamily:r,fontWeight:n,foreColor:Array.isArray(a.colors)?a.colors[o]:a.colors,isPlainText:!1,cssClass:"apexcharts-yaxis-label "+a.cssClass});<span class="cstat-no" title="statement not covered" ></span>if(o===h&amp;&amp;(f=b),l.add(b),0!==e.config.yaxis[t].labels.rotate){var m=<span class="cstat-no" title="statement not covered" >i.rotateAroundCenter(f.node),</span>v=<span class="cstat-no" title="statement not covered" >i.rotateAroundCenter(b.node);<span class="cstat-no" title="statement not covered" ></span>b.node.setAttribute("transform","rotate(".concat(e.config.yaxis[t].labels.rotate," ").concat(m.x," ").concat(v.y,")"))}<span class="cstat-no" title="statement not covered" ></span>d</span>+=c}</span>,</span>b=<span class="cstat-no" title="statement not covered" >h;</span>b&gt;=0;b--)<span class="cstat-no" title="statement not covered" >x(b);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(void 0!==e.config.yaxis[t].title.text){var m=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-yaxis-title"}),</span>v=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.config.yaxis[t].opposite&amp;&amp;(v=e.globals.translateYAxisX[t]);v</span>ar y=<span class="cstat-no" title="statement not covered" >i.drawText({x:v,y:e.globals.gridHeight/2+e.globals.translateY+e.config.yaxis[t].title.offsetY,text:e.config.yaxis[t].title.text,textAnchor:"end",foreColor:e.config.yaxis[t].title.style.color,fontSize:e.config.yaxis[t].title.style.fontSize,fontWeight:e.config.yaxis[t].title.style.fontWeight,fontFamily:e.config.yaxis[t].title.style.fontFamily,cssClass:"apexcharts-yaxis-title-text "+e.config.yaxis[t].title.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>m.add(y),o.add(m)}</span>v</span>ar w=<span class="cstat-no" title="statement not covered" >e.config.yaxis[t].axisBorder,</span>k=<span class="cstat-no" title="statement not covered" >31+w.offsetX;<span class="cstat-no" title="statement not covered" ></span>if(e.config.yaxis[t].opposite&amp;&amp;(k=-31-w.offsetX),w.show){var A=<span class="cstat-no" title="statement not covered" >i.drawLine(k,e.globals.translateY+w.offsetY-2,k,e.globals.gridHeight+e.globals.translateY+w.offsetY+2,w.color,0,w.width);<span class="cstat-no" title="statement not covered" ></span>o.add(A)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.config.yaxis[t].axisTicks.show&amp;&amp;this.axesUtils.drawYAxisTicks(k,h,w,e.config.yaxis[t].axisTicks,t,c,o),o}</span>},{key:"drawYaxisInversed",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-xaxis apexcharts-yaxis-inversed"}),</span>s=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-xaxis-texts-g",transform:"translate(".concat(e.globals.translateXAxisX,", ").concat(e.globals.translateXAxisY,")")});<span class="cstat-no" title="statement not covered" ></span>a.add(s);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.globals.yAxisScale[t].result.length-1,</span>n=<span class="cstat-no" title="statement not covered" >e.globals.gridWidth/r+.1,</span>o=<span class="cstat-no" title="statement not covered" >n+e.config.xaxis.labels.offsetX,</span>l=<span class="cstat-no" title="statement not covered" >e.globals.xLabelFormatter,</span>h=<span class="cstat-no" title="statement not covered" >e.globals.yAxisScale[t].result.slice(),</span>c=<span class="cstat-no" title="statement not covered" >e.globals.timescaleLabels;<span class="cstat-no" title="statement not covered" ></span>c.length&gt;0&amp;&amp;(this.xaxisLabels=c.slice(),r=(h=c.slice()).length),h=this.axesUtils.checkForReversedLabels(t,h);v</span>ar d=<span class="cstat-no" title="statement not covered" >c.length;<span class="cstat-no" title="statement not covered" ></span>if(e.config.xaxis.labels.show)<span class="cstat-no" title="statement not covered" >for(var g=<span class="cstat-no" title="statement not covered" >d?0:r;</span>d?g&lt;d:g&gt;=0;d?g++:g--){var u=<span class="cstat-no" title="statement not covered" >h[g];<span class="cstat-no" title="statement not covered" ></span>u=l(u,g);v</span>ar f=<span class="cstat-no" title="statement not covered" >e.globals.gridWidth+e.globals.padHorizontal-(o-n+e.config.xaxis.labels.offsetX);<span class="cstat-no" title="statement not covered" ></span>if(c.length){var x=<span class="cstat-no" title="statement not covered" >this.axesUtils.getLabel(h,c,f,g,this.drawnLabels,this.xaxisFontSize);<span class="cstat-no" title="statement not covered" ></span>f=x.x,u=x.text,this.drawnLabels.push(x.text),0===g&amp;&amp;e.globals.skipFirstTimelinelabel&amp;&amp;(u=""),g===h.length-1&amp;&amp;e.globals.skipLastTimelinelabel&amp;&amp;(u="")}</span>v</span>ar b=<span class="cstat-no" title="statement not covered" >i.drawText({x:f,y:this.xAxisoffX+e.config.xaxis.labels.offsetY+30-("top"===e.config.xaxis.position?e.globals.xAxisHeight+e.config.xaxis.axisTicks.height-2:0),text:u,textAnchor:"middle",foreColor:Array.isArray(this.xaxisForeColors)?this.xaxisForeColors[t]:this.xaxisForeColors,fontSize:this.xaxisFontSize,fontFamily:this.xaxisFontFamily,fontWeight:e.config.xaxis.labels.style.fontWeight,isPlainText:!1,cssClass:"apexcharts-xaxis-label "+e.config.xaxis.labels.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>s.add(b),b.tspan(u);v</span>ar m=<span class="cstat-no" title="statement not covered" >document.createElementNS(e.globals.SVGNS,"title");<span class="cstat-no" title="statement not covered" ></span>m.textContent=u,b.node.appendChild(m),o+=n}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this.inversedYAxisTitleText(a),this.inversedYAxisBorder(a),a}</span>},{key:"inversedYAxisBorder",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >e.config.xaxis.axisBorder;<span class="cstat-no" title="statement not covered" ></span>if(a.show){var s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>"bar"===e.config.chart.type&amp;&amp;e.globals.isXNumeric&amp;&amp;(s-=15);v</span>ar r=<span class="cstat-no" title="statement not covered" >i.drawLine(e.globals.padHorizontal+s+a.offsetX,this.xAxisoffX,e.globals.gridWidth,this.xAxisoffX,a.color,0,a.height);<span class="cstat-no" title="statement not covered" ></span>t.add(r)}</span>}</span>},{key:"inversedYAxisTitleText",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==e.config.xaxis.title.text){var a=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-xaxis-title apexcharts-yaxis-title-inversed"}),</span>s=<span class="cstat-no" title="statement not covered" >i.drawText({x:e.globals.gridWidth/2+e.config.xaxis.title.offsetX,y:this.xAxisoffX+parseFloat(this.xaxisFontSize)+parseFloat(e.config.xaxis.title.style.fontSize)+e.config.xaxis.title.offsetY+20,text:e.config.xaxis.title.text,textAnchor:"middle",fontSize:e.config.xaxis.title.style.fontSize,fontFamily:e.config.xaxis.title.style.fontFamily,fontWeight:e.config.xaxis.title.style.fontWeight,cssClass:"apexcharts-xaxis-title-text "+e.config.xaxis.title.style.cssClass});<span class="cstat-no" title="statement not covered" ></span>a.add(s),t.add(a)}</span>}</span>},{key:"yAxisTitleRotate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >{width:0,height:0},</span>r=<span class="cstat-no" title="statement not covered" >{width:0,height:0},</span>n=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-texts-g"));<span class="cstat-no" title="statement not covered" ></span>null!==n&amp;&amp;(s=n.getBoundingClientRect());v</span>ar o=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-title text"));<span class="cstat-no" title="statement not covered" ></span>if(null!==o&amp;&amp;(r=o.getBoundingClientRect()),null!==o){var l=<span class="cstat-no" title="statement not covered" >this.xPaddingForYAxisTitle(t,s,r,e);<span class="cstat-no" title="statement not covered" ></span>o.setAttribute("x",l.xPos-(e?10:0))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(null!==o){var h=<span class="cstat-no" title="statement not covered" >a.rotateAroundCenter(o);<span class="cstat-no" title="statement not covered" ></span>o.setAttribute("transform","rotate(".concat(e?"":"-").concat(i.config.yaxis[t].title.rotate," ").concat(h.x," ").concat(h.y,")"))}</span>}</span>},{key:"xPaddingForYAxisTitle",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >10;<span class="cstat-no" title="statement not covered" ></span>return void 0===s.config.yaxis[t].title.text||t&lt;0?{xPos:n,padd:0}:(a?(n=e.width+s.config.yaxis[t].title.offsetX+i.width/2+o/2,0===(r+=1)&amp;&amp;(n-=o/2)):(n=-1*e.width+s.config.yaxis[t].title.offsetX+o/2+i.width/2,s.globals.isBarHorizontal&amp;&amp;(o=25,n=-1*e.width-s.config.yaxis[t].title.offsetX-o)),{xPos:n,padd:o})}</span>},{key:"setYAxisXPosition",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >18,</span>n=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>i.config.yaxis.length&gt;1&amp;&amp;(this.multipleYs=!0),i.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(o,l){var h=<span class="cstat-no" title="statement not covered" >i.globals.ignoreYAxisIndexes.indexOf(l)&gt;-1||!o.show||o.floating||0===t[l].width,</span>c=<span class="cstat-no" title="statement not covered" >t[l].width+e[l].width;<span class="cstat-no" title="statement not covered" ></span>o.opposite?i.globals.isBarHorizontal?(s=i.globals.gridWidth+i.globals.translateX-1,i.globals.translateYAxisX[l]=s-o.labels.offsetX):(s=i.globals.gridWidth+i.globals.translateX+n,h||(n=n+c+20),i.globals.translateYAxisX[l]=s-o.labels.offsetX+20):(a=i.globals.translateX-r,h||(r=r+c+20),i.globals.translateYAxisX[l]=a+o.labels.offsetX)}</span>))}</span>},{key:"setYAxisTextAlignments",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");<span class="cstat-no" title="statement not covered" ></span>(e=g.listToArray(e)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){var a=<span class="cstat-no" title="statement not covered" >t.config.yaxis[i];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==a.labels.align){var s=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i,"'] .apexcharts-yaxis-texts-g")),</span>r=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i,"'] .apexcharts-yaxis-label"));<span class="cstat-no" title="statement not covered" ></span>r=g.listToArray(r);v</span>ar n=<span class="cstat-no" title="statement not covered" >s.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>"left"===a.labels.align?(r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.setAttribute("text-anchor","start")}</span>)),a.opposite||s.setAttribute("transform","translate(-".concat(n.width,", 0)"))):"center"===a.labels.align?(r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.setAttribute("text-anchor","middle")}</span>)),s.setAttribute("transform","translate(".concat(n.width/2*(a.opposite?1:-1),", 0)"))):"right"===a.labels.align&amp;&amp;(r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.setAttribute("text-anchor","end")}</span>)),a.opposite&amp;&amp;s.setAttribute("transform","translate(".concat(n.width,", 0)")))}</span>}</span>))}</span>}]),t}</span>(),</span>Z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.documentEvent=g.bind(this.documentEvent,this)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"addEventListener",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>i.globals.events.hasOwnProperty(t)?i.globals.events[t].push(e):i.globals.events[t]=[e]}</span>},{key:"removeEventListener",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(i.globals.events.hasOwnProperty(t)){var a=<span class="cstat-no" title="statement not covered" >i.globals.events[t].indexOf(e);<span class="cstat-no" title="statement not covered" ></span>-1!==a&amp;&amp;i.globals.events[t].splice(a,1)}</span>}</span>},{key:"fireEvent",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(i.globals.events.hasOwnProperty(t)){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.length||(e=[]);<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >i.globals.events[t],</span>s=<span class="cstat-no" title="statement not covered" >a.length,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;s;r++)<span class="cstat-no" title="statement not covered" >a[r].apply(null,e)}</span></span>}</span>},{key:"setupEventHandlers",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx,</span>a=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelector(e.globals.chartClass);<span class="cstat-no" title="statement not covered" ></span>this.ctx.eventList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.addEventListener(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var a=<span class="cstat-no" title="statement not covered" >Object.assign({},e,{seriesIndex:e.globals.capturedSeriesIndex,dataPointIndex:e.globals.capturedDataPointIndex});<span class="cstat-no" title="statement not covered" ></span>"mousemove"===t.type||"touchmove"===t.type?"function"==typeof e.config.chart.events.mouseMove&amp;&amp;e.config.chart.events.mouseMove(t,i,a):("mouseup"===t.type&amp;&amp;1===t.which||"touchend"===t.type)&amp;&amp;("function"==typeof e.config.chart.events.click&amp;&amp;e.config.chart.events.click(t,i,a),i.ctx.events.fireEvent("click",[t,i,a]))}</span>),{capture:!1,passive:!0})}</span>)),this.ctx.eventList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >document.addEventListener(e,t.documentEvent)}</span>)),this.ctx.core.setupBrushHandler()}</span>},{key:"documentEvent",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >t.target.className;<span class="cstat-no" title="statement not covered" ></span>if("click"===t.type){var a=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelector(".apexcharts-menu");<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;a.classList.contains("apexcharts-menu-open")&amp;&amp;"apexcharts-menu-icon"!==i&amp;&amp;a.classList.remove("apexcharts-menu-open")}<span class="cstat-no" title="statement not covered" ></span>i</span>f("mousedown"===t.type){var s=<span class="cstat-no" title="statement not covered" >e.globals.dom.Paper.select(".apexcharts-resizable-element").members;<span class="cstat-no" title="statement not covered" ></span>Array.prototype.forEach.call(s,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.target.classList.contains("apexcharts-resizable-element")||t.target.classList.contains("svg_select_points")||e.selectize(!1)}</span>))}<span class="cstat-no" title="statement not covered" ></span>e</span>.globals.clientX="touchmove"===t.type?t.touches[0].clientX:t.clientX,e.globals.clientY="touchmove"===t.type?t.touches[0].clientY:t.clientY}</span>}]),t}</span>(),</span>$=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"setCurrentLocaleValues",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w.config.chart.locales;<span class="cstat-no" title="statement not covered" ></span>window.Apex.chart&amp;&amp;window.Apex.chart.locales&amp;&amp;window.Apex.chart.locales.length&gt;0&amp;&amp;(e=this.w.config.chart.locales.concat(window.Apex.chart.locales));v</span>ar i=<span class="cstat-no" title="statement not covered" >e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.name===t}</span>))[0];<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");v</span></span>ar a=<span class="cstat-no" title="statement not covered" >g.extend(A,i);<span class="cstat-no" title="statement not covered" ></span>this.w.globals.locale=a.options}</span>}]),t}</span>(),</span>J=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawAxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i,a,s=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>r=<span class="cstat-no" title="statement not covered" >this.w.config,</span>n=<span class="cstat-no" title="statement not covered" >new G(this.ctx),</span>o=<span class="cstat-no" title="statement not covered" >new q(this.ctx);<span class="cstat-no" title="statement not covered" ></span>s.axisCharts&amp;&amp;"radar"!==t&amp;&amp;(s.isBarHorizontal?(a=o.drawYaxisInversed(0),i=n.drawXaxisInversed(0),s.dom.elGraphical.add(i),s.dom.elGraphical.add(a)):(i=n.drawXaxis(),s.dom.elGraphical.add(i),r.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >-1===s.ignoreYAxisIndexes.indexOf(e)&amp;&amp;(a=o.drawYaxis(e),s.dom.Paper.add(a))}</span>))));<span class="cstat-no" title="statement not covered" >r</span>.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >-1===s.ignoreYAxisIndexes.indexOf(e)&amp;&amp;o.yAxisTitleRotate(e,t.opposite)}</span>))}</span>}]),t}</span>(),</span>Q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawXCrosshairs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>i=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >t.config.xaxis.crosshairs.fill.gradient,</span>s=<span class="cstat-no" title="statement not covered" >t.config.xaxis.crosshairs.dropShadow,</span>r=<span class="cstat-no" title="statement not covered" >t.config.xaxis.crosshairs.fill.type,</span>n=<span class="cstat-no" title="statement not covered" >a.colorFrom,</span>o=<span class="cstat-no" title="statement not covered" >a.colorTo,</span>l=<span class="cstat-no" title="statement not covered" >a.opacityFrom,</span>h=<span class="cstat-no" title="statement not covered" >a.opacityTo,</span>c=<span class="cstat-no" title="statement not covered" >a.stops,</span>d=<span class="cstat-no" title="statement not covered" >s.enabled,</span>f=<span class="cstat-no" title="statement not covered" >s.left,</span>x=<span class="cstat-no" title="statement not covered" >s.top,</span>b=<span class="cstat-no" title="statement not covered" >s.blur,</span>m=<span class="cstat-no" title="statement not covered" >s.color,</span>v=<span class="cstat-no" title="statement not covered" >s.opacity,</span>y=<span class="cstat-no" title="statement not covered" >t.config.xaxis.crosshairs.fill.color;<span class="cstat-no" title="statement not covered" ></span>if(t.config.xaxis.crosshairs.show){<span class="cstat-no" title="statement not covered" >"gradient"===r&amp;&amp;(y=e.drawGradient("vertical",n,o,l,h,null,c,null));v</span>ar w=<span class="cstat-no" title="statement not covered" >e.drawRect();<span class="cstat-no" title="statement not covered" ></span>1===t.config.xaxis.crosshairs.width&amp;&amp;(w=e.drawLine()),w.attr({class:"apexcharts-xcrosshairs",x:0,y:0,y2:t.globals.gridHeight,width:g.isNumber(t.config.xaxis.crosshairs.width)?t.config.xaxis.crosshairs.width:0,height:t.globals.gridHeight,fill:y,filter:"none","fill-opacity":t.config.xaxis.crosshairs.opacity,stroke:t.config.xaxis.crosshairs.stroke.color,"stroke-width":t.config.xaxis.crosshairs.stroke.width,"stroke-dasharray":t.config.xaxis.crosshairs.stroke.dashArray}),d&amp;&amp;(w=i.dropShadow(w,{left:f,top:x,blur:b,color:m,opacity:v})),t.globals.dom.elGraphical.add(w)}</span>}</span>},{key:"drawYCrosshairs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>i=<span class="cstat-no" title="statement not covered" >t.config.yaxis[0].crosshairs,</span>a=<span class="cstat-no" title="statement not covered" >t.globals.barPadForNumericAxis;<span class="cstat-no" title="statement not covered" ></span>if(t.config.yaxis[0].crosshairs.show){var s=<span class="cstat-no" title="statement not covered" >e.drawLine(-a,0,t.globals.gridWidth+a,0,i.stroke.color,i.stroke.dashArray,i.stroke.width);<span class="cstat-no" title="statement not covered" ></span>s.attr({class:"apexcharts-ycrosshairs"}),t.globals.dom.elGraphical.add(s)}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >e.drawLine(-a,0,t.globals.gridWidth+a,0,i.stroke.color,0,0);<span class="cstat-no" title="statement not covered" ></span>r.attr({class:"apexcharts-ycrosshairs-hidden"}),t.globals.dom.elGraphical.add(r)}</span>}]),t}</span>(),</span>K=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"checkResponsiveConfig",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.config;<span class="cstat-no" title="statement not covered" ></span>if(0!==a.responsive.length){var s=<span class="cstat-no" title="statement not covered" >a.responsive.slice();<span class="cstat-no" title="statement not covered" ></span>s.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.breakpoint&gt;e.breakpoint?1:e.breakpoint&gt;t.breakpoint?-1:0}</span>)).reverse();v</span>ar r=<span class="cstat-no" title="statement not covered" >new D({}),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:{},</span>a=<span class="cstat-no" title="statement not covered" >s[0].breakpoint,</span>n=<span class="cstat-no" title="statement not covered" >window.innerWidth&gt;0?window.innerWidth:screen.width;<span class="cstat-no" title="statement not covered" ></span>if(n&gt;a){var o=<span class="cstat-no" title="statement not covered" >m.extendArrayProps(r,i.globals.initialConfig,i);<span class="cstat-no" title="statement not covered" ></span>t=g.extend(o,t),t=g.extend(i.config,t),e.overrideResponsiveOptions(t)}</span>else <span class="cstat-no" title="statement not covered" >for(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;s.length;l++)<span class="cstat-no" title="statement not covered" >n&lt;s[l].breakpoint&amp;&amp;(t=m.extendArrayProps(r,s[l].options,i),t=g.extend(i.config,t),e.overrideResponsiveOptions(t))}</span></span></span>;<span class="cstat-no" title="statement not covered" ></span>if(t){var o=<span class="cstat-no" title="statement not covered" >m.extendArrayProps(r,t,i);<span class="cstat-no" title="statement not covered" ></span>o=g.extend(i.config,o),n(o=g.extend(o,t))}</span>else <span class="cstat-no" title="statement not covered" >n({})}</span></span>}</span>},{key:"overrideResponsiveOptions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new D(t).init({responsiveOverride:!0});<span class="cstat-no" title="statement not covered" ></span>this.w.config=e}</span>}]),t}</span>(),</span>tt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.colors=[],this.w=i.w;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.isColorFn=!1,this.isBarDistributed=a.config.plotOptions.bar.distributed&amp;&amp;("bar"===a.config.chart.type||"rangeBar"===a.config.chart.type)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.setDefaultColors()}</span>},{key:"setDefaultColors",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new g;<span class="cstat-no" title="statement not covered" ></span>if(e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)),void 0===e.config.colors?e.globals.colors=this.predefined():(e.globals.colors=e.config.colors,Array.isArray(e.config.colors)&amp;&amp;e.config.colors.length&gt;0&amp;&amp;"function"==typeof e.config.colors[0]&amp;&amp;(e.globals.colors=e.config.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){var s=<span class="cstat-no" title="statement not covered" >e.config.colors[a];<span class="cstat-no" title="statement not covered" ></span>return s||(s=e.config.colors[0]),"function"==typeof s?(t.isColorFn=!0,s({value:e.globals.axisCharts?e.globals.series[a][0]?e.globals.series[a][0]:0:e.globals.series[a],seriesIndex:a,dataPointIndex:a,w:e})):s}</span>)))),e.config.theme.monochrome.enabled){var a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >e.globals.series.length;<span class="cstat-no" title="statement not covered" ></span>this.isBarDistributed&amp;&amp;(s=e.globals.series[0].length*e.globals.series.length);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >e.config.theme.monochrome.color,</span>n=<span class="cstat-no" title="statement not covered" >1/(s/e.config.theme.monochrome.shadeIntensity),</span>o=<span class="cstat-no" title="statement not covered" >e.config.theme.monochrome.shadeTo,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;s;h++){var c=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>"dark"===o?(c=i.shadeColor(-1*l,r),l+=n):(c=i.shadeColor(l,r),l+=n),a.push(c)}<span class="cstat-no" title="statement not covered" ></span>e</span>.globals.colors=a.slice()}</span>v</span>ar d=<span class="cstat-no" title="statement not covered" >e.globals.colors.slice();<span class="cstat-no" title="statement not covered" ></span>this.pushExtraColors(e.globals.colors);<span class="cstat-no" title="statement not covered" >[</span>"fill","stroke"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >void 0===e.config[i].colors?e.globals[i].colors=t.isColorFn?e.config.colors:d:e.globals[i].colors=e.config[i].colors.slice(),t.pushExtraColors(e.globals[i].colors)}</span>)),void 0===e.config.dataLabels.style.colors?e.globals.dataLabels.style.colors=d:e.globals.dataLabels.style.colors=e.config.dataLabels.style.colors.slice(),this.pushExtraColors(e.globals.dataLabels.style.colors,50),void 0===e.config.plotOptions.radar.polygons.fill.colors?e.globals.radarPolygons.fill.colors=["dark"===e.config.theme.mode?"#424242":"#fff"]:e.globals.radarPolygons.fill.colors=e.config.plotOptions.radar.polygons.fill.colors.slice(),this.pushExtraColors(e.globals.radarPolygons.fill.colors,20),void 0===e.config.markers.colors?e.globals.markers.colors=d:e.globals.markers.colors=e.config.markers.colors.slice(),this.pushExtraColors(e.globals.markers.colors)}</span>},{key:"pushExtraColors",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:null,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >e||a.globals.series.length;<span class="cstat-no" title="statement not covered" ></span>if(null===i&amp;&amp;(i=this.isBarDistributed||"heatmap"===a.config.chart.type&amp;&amp;a.config.plotOptions.heatmap.colorScale.inverse),i&amp;&amp;(s=a.globals.series[0].length*a.globals.series.length),t.length&lt;s)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >s-t.length,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;r;n++)<span class="cstat-no" title="statement not covered" >t.push(t[n])}</span></span></span>},{key:"updateThemeOptions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.chart=t.chart||{},t.tooltip=t.tooltip||{};v</span>ar e=<span class="cstat-no" title="statement not covered" >t.theme.mode||"light",</span>i=<span class="cstat-no" title="statement not covered" >t.theme.palette?t.theme.palette:"dark"===e?"palette4":"palette1",</span>a=<span class="cstat-no" title="statement not covered" >t.chart.foreColor?t.chart.foreColor:"dark"===e?"#f6f7f8":"#373d3f";<span class="cstat-no" title="statement not covered" ></span>return t.tooltip.theme=e,t.chart.foreColor=a,t.theme.palette=i,t}</span>},{key:"predefined",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.w.config.theme.palette){case"palette1":<span class="cstat-no" title="statement not covered" >this.colors=["#008FFB","#00E396","#FEB019","#FF4560","#775DD0"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette2":<span class="cstat-no" title="statement not covered" >this.colors=["#3f51b5","#03a9f4","#4caf50","#f9ce1d","#FF9800"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette3":<span class="cstat-no" title="statement not covered" >this.colors=["#33b2df","#546E7A","#d4526e","#13d8aa","#A5978B"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette4":<span class="cstat-no" title="statement not covered" >this.colors=["#4ecdc4","#c7f464","#81D4FA","#fd6a6a","#546E7A"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette5":<span class="cstat-no" title="statement not covered" >this.colors=["#2b908f","#f9a3a4","#90ee7e","#fa4443","#69d2e7"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette6":<span class="cstat-no" title="statement not covered" >this.colors=["#449DD1","#F86624","#EA3546","#662E9B","#C5D86D"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette7":<span class="cstat-no" title="statement not covered" >this.colors=["#D7263D","#1B998B","#2E294E","#F46036","#E2C044"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette8":<span class="cstat-no" title="statement not covered" >this.colors=["#662E9B","#F86624","#F9C80E","#EA3546","#43BCCD"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette9":<span class="cstat-no" title="statement not covered" >this.colors=["#5C4742","#A5978B","#8D5B4C","#5A2A27","#C4BBAF"];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"palette10":<span class="cstat-no" title="statement not covered" >this.colors=["#A300D6","#7D02EB","#5653FE","#2983FF","#00B1F2"];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.colors=["#008FFB","#00E396","#FEB019","#FF4560","#775DD0"]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.colors}</span>}]),t}</span>(),</span>et=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.drawTitleSubtitle("title"),this.drawTitleSubtitle("subtitle")}</span>},{key:"drawTitleSubtitle",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >"title"===t?e.config.title:e.config.subtitle,</span>a=<span class="cstat-no" title="statement not covered" >e.globals.svgWidth/2,</span>s=<span class="cstat-no" title="statement not covered" >i.offsetY,</span>r=<span class="cstat-no" title="statement not covered" >"middle";<span class="cstat-no" title="statement not covered" ></span>if("left"===i.align?(a=10,r="start"):"right"===i.align&amp;&amp;(a=e.globals.svgWidth-10,r="end"),a+=i.offsetX,s=s+parseInt(i.style.fontSize,10)+i.margin/2,void 0!==i.text){var n=<span class="cstat-no" title="statement not covered" >new p(this.ctx).drawText({x:a,y:s,text:i.text,textAnchor:r,fontSize:i.style.fontSize,fontFamily:i.style.fontFamily,fontWeight:i.style.fontWeight,foreColor:i.style.color,opacity:1});<span class="cstat-no" title="statement not covered" ></span>n.node.setAttribute("class","apexcharts-".concat(t,"-text")),e.globals.dom.Paper.add(n)}</span>}</span>}]),t}</span>(),</span>it=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.dCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getTitleSubtitleCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >"title"===t?e.config.title.floating:e.config.subtitle.floating,</span>r=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t,"-text"));<span class="cstat-no" title="statement not covered" ></span>if(null!==r&amp;&amp;!s){var n=<span class="cstat-no" title="statement not covered" >r.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>i=n.width,a=e.globals.axisCharts?n.height+5:n.height}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{width:i,height:a}}</span>},{key:"getLegendsRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-legend"),</span>i=<span class="cstat-no" title="statement not covered" >Object.assign({},g.getBoundingClientRect(e));<span class="cstat-no" title="statement not covered" ></span>return null!==e&amp;&amp;!t.config.legend.floating&amp;&amp;t.config.legend.show?this.dCtx.lgRect={x:i.x,y:i.y,height:i.height,width:0===i.height?0:i.width}:this.dCtx.lgRect={x:0,y:0,height:0,width:0},"left"!==t.config.legend.position&amp;&amp;"right"!==t.config.legend.position||1.5*this.dCtx.lgRect.width&gt;t.globals.svgWidth&amp;&amp;(this.dCtx.lgRect.width=t.globals.svgWidth/1.5),this.dCtx.lgRect}</span>},{key:"getLargestStringFromMultiArr",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(this.w.globals.isMultiLineX){var a=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Array.isArray(t)?t.length:1}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >Math.max.apply(Math,d(a));<span class="cstat-no" title="statement not covered" ></span>i=e[a.indexOf(s)]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}]),t}</span>(),</span>at=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.dCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getxAxisLabelsCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals.labels.slice();<span class="cstat-no" title="statement not covered" ></span>if(e.config.xaxis.convertedCatToNumeric&amp;&amp;0===i.length&amp;&amp;(i=e.globals.categoryLabels),e.globals.timescaleLabels.length&gt;0){var a=<span class="cstat-no" title="statement not covered" >this.getxAxisTimeScaleLabelsCoords();<span class="cstat-no" title="statement not covered" ></span>t={width:a.width,height:a.height},e.globals.rotateXLabels=!1}</span>else{<span class="cstat-no" title="statement not covered" >this.dCtx.lgWidthForSideLegends="left"!==e.config.legend.position&amp;&amp;"right"!==e.config.legend.position||e.config.legend.floating?0:this.dCtx.lgRect.width;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.globals.xLabelFormatter,</span>r=<span class="cstat-no" title="statement not covered" >g.getLargestStringFromArr(i),</span>n=<span class="cstat-no" title="statement not covered" >this.dCtx.dimHelpers.getLargestStringFromMultiArr(r,i);<span class="cstat-no" title="statement not covered" ></span>e.globals.isBarHorizontal&amp;&amp;(n=r=e.globals.yAxisScale[0].result.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.length&gt;e.length?t:e}</span>),0));v</span>ar o=<span class="cstat-no" title="statement not covered" >new W(this.dCtx.ctx),</span>l=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>r=o.xLabelFormat(s,r,l),n=o.xLabelFormat(s,n,l),(e.config.xaxis.convertedCatToNumeric&amp;&amp;void 0===r||""===String(r).trim())&amp;&amp;(n=r="1");v</span>ar h=<span class="cstat-no" title="statement not covered" >new p(this.dCtx.ctx),</span>c=<span class="cstat-no" title="statement not covered" >h.getTextRects(r,e.config.xaxis.labels.style.fontSize),</span>d=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>if(r!==n&amp;&amp;(d=h.getTextRects(n,e.config.xaxis.labels.style.fontSize)),(t={width:c.width&gt;=d.width?c.width:d.width,height:c.height&gt;=d.height?c.height:d.height}).width*i.length&gt;e.globals.svgWidth-this.dCtx.lgWidthForSideLegends-this.dCtx.yAxisWidth-this.dCtx.gridPad.left-this.dCtx.gridPad.right&amp;&amp;0!==e.config.xaxis.labels.rotate||e.config.xaxis.labels.rotateAlways){<span class="cstat-no" title="statement not covered" >if(!e.globals.isBarHorizontal){<span class="cstat-no" title="statement not covered" >e.globals.rotateXLabels=!0;v</span>ar u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return h.getTextRects(t,e.config.xaxis.labels.style.fontSize,e.config.xaxis.labels.style.fontFamily,"rotate(".concat(e.config.xaxis.labels.rotate," 0 0)"),!1)}</span>;<span class="cstat-no" title="statement not covered" ></span>c=u(r),r!==n&amp;&amp;(d=u(n)),t.height=(c.height&gt;d.height?c.height:d.height)/1.5,t.width=c.width&gt;d.width?c.width:d.width}</span>}</span>else <span class="cstat-no" title="statement not covered" >e.globals.rotateXLabels=!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e.config.xaxis.labels.show||(t={width:0,height:0}),{width:t.width,height:t.height}}</span>},{key:"getxAxisTitleCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t.config.xaxis.title.text){var a=<span class="cstat-no" title="statement not covered" >new p(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text,t.config.xaxis.title.style.fontSize);<span class="cstat-no" title="statement not covered" ></span>e=a.width,i=a.height}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{width:e,height:i}}</span>},{key:"getxAxisTimeScaleLabelsCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.dCtx.timescaleLabels=e.globals.timescaleLabels.slice();v</span>ar i=<span class="cstat-no" title="statement not covered" >this.dCtx.timescaleLabels.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.value}</span>)),</span>a=<span class="cstat-no" title="statement not covered" >i.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t?(console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"),0):t.length&gt;e.length?t:e}</span>),0);<span class="cstat-no" title="statement not covered" ></span>return 1.05*(t=new p(this.dCtx.ctx).getTextRects(a,e.config.xaxis.labels.style.fontSize)).width*i.length&gt;e.globals.gridWidth&amp;&amp;0!==e.config.xaxis.labels.rotate&amp;&amp;(e.globals.overlappingXLabels=!0),t}</span>},{key:"additionalPaddingXLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals,</span>s=<span class="cstat-no" title="statement not covered" >i.config,</span>r=<span class="cstat-no" title="statement not covered" >s.xaxis.type,</span>n=<span class="cstat-no" title="statement not covered" >t.width;<span class="cstat-no" title="statement not covered" ></span>a.skipLastTimelinelabel=!1,a.skipFirstTimelinelabel=!1;v</span>ar o=<span class="cstat-no" title="statement not covered" >i.config.yaxis[0].opposite&amp;&amp;i.globals.isBarHorizontal,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,o){<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return-1!==a.collapsedSeriesIndices.indexOf(t)}</span>)(o)||("datetime"!==r&amp;&amp;e.dCtx.gridPad.left&lt;n/2-e.dCtx.yAxisWidthLeft&amp;&amp;!a.rotateXLabels&amp;&amp;!s.xaxis.labels.trim&amp;&amp;(e.dCtx.xPadLeft=n/2+1),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(e.dCtx.timescaleLabels&amp;&amp;e.dCtx.timescaleLabels.length){var s=<span class="cstat-no" title="statement not covered" >e.dCtx.timescaleLabels[0],</span>o=<span class="cstat-no" title="statement not covered" >e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length-1].position+n/1.75-e.dCtx.yAxisWidthRight,</span>l=<span class="cstat-no" title="statement not covered" >s.position-n/1.75+e.dCtx.yAxisWidthLeft;<span class="cstat-no" title="statement not covered" ></span>o&gt;a.gridWidth&amp;&amp;(a.skipLastTimelinelabel=!0),l&lt;0&amp;&amp;(a.skipFirstTimelinelabel=!0)}</span>else<span class="cstat-no" title="statement not covered" >"datetime"===r?e.dCtx.gridPad.right&lt;n&amp;&amp;!a.rotateXLabels&amp;&amp;(a.skipLastTimelinelabel=!0):"datetime"!==r&amp;&amp;e.dCtx.gridPad.right&lt;n/2-e.dCtx.yAxisWidthRight&amp;&amp;!a.rotateXLabels&amp;&amp;("between"!==i.config.xaxis.tickPlacement||i.globals.isBarHorizontal)&amp;&amp;(e.dCtx.xPadRight=n/2+1)}</span></span>())}</span>;<span class="cstat-no" title="statement not covered" ></span>s.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >o?(e.dCtx.gridPad.left&lt;n&amp;&amp;(e.dCtx.xPadLeft=n/2+1),e.dCtx.xPadRight=n/2+1):l(0,i)}</span>))}</span>}]),t}</span>(),</span>st=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.dCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getyAxisLabelsCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >10,</span>s=<span class="cstat-no" title="statement not covered" >new B(this.dCtx.ctx);<span class="cstat-no" title="statement not covered" ></span>return e.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(r,n){var o=<span class="cstat-no" title="statement not covered" >e.globals.yAxisScale[n];<span class="cstat-no" title="statement not covered" ></span>if(!s.isYAxisHidden(n)&amp;&amp;r.labels.show&amp;&amp;o.result.length){var l=<span class="cstat-no" title="statement not covered" >e.globals.yLabelFormatters[n],</span>h=<span class="cstat-no" title="statement not covered" >String(o.niceMin).length&gt;String(o.niceMax).length?o.niceMin:o.niceMax,</span>c=<span class="cstat-no" title="statement not covered" >l(h,{seriesIndex:n,dataPointIndex:-1,w:e}),</span>d=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==c&amp;&amp;0!==c.length||(c=h),e.globals.isBarHorizontal){<span class="cstat-no" title="statement not covered" >a=0;v</span>ar u=<span class="cstat-no" title="statement not covered" >e.globals.labels.slice();<span class="cstat-no" title="statement not covered" ></span>c=l(c=g.getLargestStringFromArr(u),{seriesIndex:n,dataPointIndex:-1,w:e}),d=t.dCtx.dimHelpers.getLargestStringFromMultiArr(c,u)}</span>v</span>ar f=<span class="cstat-no" title="statement not covered" >new p(t.dCtx.ctx),</span>x=<span class="cstat-no" title="statement not covered" >f.getTextRects(c,r.labels.style.fontSize),</span>b=<span class="cstat-no" title="statement not covered" >x;<span class="cstat-no" title="statement not covered" ></span>c!==d&amp;&amp;(b=f.getTextRects(d,r.labels.style.fontSize)),i.push({width:(b.width&gt;x.width?b.width:x.width)+a,height:b.height&gt;x.height?b.height:x.height})}</span>else <span class="cstat-no" title="statement not covered" >i.push({width:0,height:0})}</span></span>)),i}</span>},{key:"getyAxisTitleCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >if(e.show&amp;&amp;void 0!==e.title.text){var s=<span class="cstat-no" title="statement not covered" >new p(t.dCtx.ctx).getTextRects(e.title.text,e.title.style.fontSize,e.title.style.fontFamily,"rotate(-90 0 0)",!1);<span class="cstat-no" title="statement not covered" ></span>i.push({width:s.width,height:s.height})}</span>else <span class="cstat-no" title="statement not covered" >i.push({width:0,height:0})}</span></span>)),i}</span>},{key:"getTotalYAxisWidth",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.globals.yAxisScale.length&gt;1?10:0,</span>r=<span class="cstat-no" title="statement not covered" >new B(this.dCtx.ctx),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n,o){var l=<span class="cstat-no" title="statement not covered" >t.config.yaxis[o].floating,</span>h=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.width&gt;0&amp;&amp;!l?(h=n.width+s,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.globals.ignoreYAxisIndexes.indexOf(e)&gt;-1}</span>(o)&amp;&amp;(h=h-n.width-s)):h=l||r.isYAxisHidden(o)?0:5,t.config.yaxis[o].opposite?a+=h:i+=h,e+=h}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.globals.yLabelsCoords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >n(t,e)}</span>)),t.globals.yTitleCoords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >n(t,e)}</span>)),t.globals.isBarHorizontal&amp;&amp;(e=t.globals.yLabelsCoords[0].width+t.globals.yTitleCoords[0].width+15),this.dCtx.yAxisWidthLeft=i,this.dCtx.yAxisWidthRight=a,e}</span>}]),t}</span>(),</span>rt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.dCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"gridPadForColumnsInNumericAxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(e.globals.noData||e.globals.allSeriesCollapsed)<span class="cstat-no" title="statement not covered" >return 0;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >e.config.chart.type,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >"bar"===i||"rangeBar"===i?e.config.series.length:1;<span class="cstat-no" title="statement not covered" ></span>if(e.globals.comboBarCount&gt;0&amp;&amp;(s=e.globals.comboBarCount),e.globals.collapsedSeries.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"bar"!==t.type&amp;&amp;"rangeBar"!==t.type||(s-=1)}</span>)),e.config.chart.stacked&amp;&amp;(s=1),("bar"===i||"rangeBar"===i||e.globals.comboBarCount&gt;0)&amp;&amp;e.globals.isXNumeric&amp;&amp;!e.globals.isBarHorizontal&amp;&amp;s&gt;0){var r,n,o=<span class="cstat-no" title="statement not covered" >Math.abs(e.globals.initialMaxX-e.globals.initialMinX);<span class="cstat-no" title="statement not covered" ></span>o&lt;=3&amp;&amp;(o=e.globals.dataPoints),r=o/t,e.globals.minXDiff&amp;&amp;e.globals.minXDiff/r&gt;0&amp;&amp;(n=e.globals.minXDiff/r),n&gt;t/2&amp;&amp;(n/=2),(a=n/s*parseInt(e.config.plotOptions.bar.columnWidth,10)/100)&lt;1&amp;&amp;(a=1),a=a/(s&gt;1?1:1.5)+5,e.globals.barPadForNumericAxis=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>},{key:"gridPadFortitleSubtitle",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals,</span>a=<span class="cstat-no" title="statement not covered" >this.dCtx.isSparkline||!e.globals.axisCharts?0:10;<span class="cstat-no" title="statement not covered" ></span>["title","subtitle"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >void 0!==e.config[i].text?a+=e.config[i].margin:a+=t.dCtx.isSparkline||!e.globals.axisCharts?0:5}</span>));v</span>ar s=<span class="cstat-no" title="statement not covered" >e.config.series.length&gt;1||!e.globals.axisCharts||e.config.legend.showForSingleSeries;<span class="cstat-no" title="statement not covered" ></span>e.config.legend.show&amp;&amp;"bottom"===e.config.legend.position&amp;&amp;!e.config.legend.floating&amp;&amp;s&amp;&amp;(a+=10);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),</span>n=<span class="cstat-no" title="statement not covered" >this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");<span class="cstat-no" title="statement not covered" ></span>i.gridHeight=i.gridHeight-r.height-n.height-a,i.translateY=i.translateY+r.height+n.height+a}</span>},{key:"setGridXPosForDualYAxis",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new B(this.dCtx.ctx);<span class="cstat-no" title="statement not covered" ></span>i.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(s,r){<span class="cstat-no" title="statement not covered" >-1!==i.globals.ignoreYAxisIndexes.indexOf(r)||s.floating||a.isYAxisHidden(r)||(s.opposite&amp;&amp;(i.globals.translateX=i.globals.translateX-(e[r].width+t[r].width)-parseInt(i.config.yaxis[r].labels.style.fontSize,10)/1.2-12),i.globals.translateX&lt;2&amp;&amp;(i.globals.translateX=2))}</span>))}</span>}]),t}</span>(),</span>nt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.lgRect={},this.yAxisWidth=0,this.yAxisWidthLeft=0,this.yAxisWidthRight=0,this.xAxisHeight=0,this.isSparkline=this.w.config.chart.sparkline.enabled,this.dimHelpers=new it(this),this.dimYAxis=new st(this),this.dimXAxis=new at(this),this.dimGrid=new rt(this),this.lgWidthForSideLegends=0,this.gridPad=this.w.config.grid.padding,this.xPadRight=0,this.xPadLeft=0}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"plotCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>this.lgRect=this.dimHelpers.getLegendsRect(),t.axisCharts?this.setDimensionsForAxisCharts():this.setDimensionsForNonAxisCharts(),this.dimGrid.gridPadFortitleSubtitle(),t.gridHeight=t.gridHeight-this.gridPad.top-this.gridPad.bottom,t.gridWidth=t.gridWidth-this.gridPad.left-this.gridPad.right-this.xPadRight-this.xPadLeft;v</span>ar e=<span class="cstat-no" title="statement not covered" >this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth);<span class="cstat-no" title="statement not covered" ></span>t.gridWidth=t.gridWidth-2*e,t.translateX=t.translateX+this.gridPad.left+this.xPadLeft+(e&gt;0?e+4:0),t.translateY=t.translateY+this.gridPad.top}</span>},{key:"setDimensionsForAxisCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.globals,</span>a=<span class="cstat-no" title="statement not covered" >this.dimYAxis.getyAxisLabelsCoords(),</span>s=<span class="cstat-no" title="statement not covered" >this.dimYAxis.getyAxisTitleCoords();<span class="cstat-no" title="statement not covered" ></span>e.globals.yLabelsCoords=[],e.globals.yTitleCoords=[],e.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >e.globals.yLabelsCoords.push({width:a[i].width,index:i}),e.globals.yTitleCoords.push({width:s[i].width,index:i})}</span>)),this.yAxisWidth=this.dimYAxis.getTotalYAxisWidth();v</span>ar r=<span class="cstat-no" title="statement not covered" >this.dimXAxis.getxAxisLabelsCoords(),</span>n=<span class="cstat-no" title="statement not covered" >this.dimXAxis.getxAxisTitleCoords();<span class="cstat-no" title="statement not covered" ></span>this.conditionalChecksForAxisCoords(r,n),i.translateXAxisY=e.globals.rotateXLabels?this.xAxisHeight/8:-4,i.translateXAxisX=e.globals.rotateXLabels&amp;&amp;e.globals.isXNumeric&amp;&amp;e.config.xaxis.labels.rotate&lt;=-45?-this.xAxisWidth/4:0,e.globals.isBarHorizontal&amp;&amp;(i.rotateXLabels=!1,i.translateXAxisY=parseInt(e.config.xaxis.labels.style.fontSize,10)/1.5*-1),i.translateXAxisY=i.translateXAxisY+e.config.xaxis.labels.offsetY,i.translateXAxisX=i.translateXAxisX+e.config.xaxis.labels.offsetX;v</span>ar o=<span class="cstat-no" title="statement not covered" >this.yAxisWidth,</span>l=<span class="cstat-no" title="statement not covered" >this.xAxisHeight;<span class="cstat-no" title="statement not covered" ></span>i.xAxisLabelsHeight=this.xAxisHeight,i.xAxisHeight=this.xAxisHeight;v</span>ar h=<span class="cstat-no" title="statement not covered" >10;<span class="cstat-no" title="statement not covered" ></span>("radar"===e.config.chart.type||this.isSparkline)&amp;&amp;(o=0,l=i.goldenPadding),this.isSparkline&amp;&amp;(this.lgRect={height:0,width:0},l=0,o=0,h=0),this.dimXAxis.additionalPaddingXLabels(r);v</span>ar c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.translateX=o,i.gridHeight=i.svgHeight-t.lgRect.height-l-(t.isSparkline?0:e.globals.rotateXLabels?10:15),i.gridWidth=i.svgWidth-o}</span>;<span class="cstat-no" title="statement not covered" ></span>switch("top"===e.config.xaxis.position&amp;&amp;(h=i.xAxisHeight-e.config.xaxis.axisTicks.height-5),e.config.legend.position){case"bottom":<span class="cstat-no" title="statement not covered" >i.translateY=h,c();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"top":<span class="cstat-no" title="statement not covered" >i.translateY=this.lgRect.height+h,c();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"left":<span class="cstat-no" title="statement not covered" >i.translateY=h,i.translateX=this.lgRect.width+o,i.gridHeight=i.svgHeight-l-12,i.gridWidth=i.svgWidth-this.lgRect.width-o;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >i.translateY=h,i.translateX=o,i.gridHeight=i.svgHeight-l-12,i.gridWidth=i.svgWidth-this.lgRect.width-o-5;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Legend position not supported")}<span class="cstat-no" title="statement not covered" ></span>t</span>his.dimGrid.setGridXPosForDualYAxis(s,a),new q(this.ctx).setYAxisXPosition(a,s)}</span>},{key:"setDimensionsForNonAxisCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals,</span>i=<span class="cstat-no" title="statement not covered" >t.config,</span>a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.config.legend.show&amp;&amp;!t.config.legend.floating&amp;&amp;(a=20);v</span>ar s=<span class="cstat-no" title="statement not covered" >"pie"===i.chart.type||"polarArea"===i.chart.type||"donut"===i.chart.type?"pie":"radialBar",</span>r=<span class="cstat-no" title="statement not covered" >i.plotOptions[s].offsetY,</span>n=<span class="cstat-no" title="statement not covered" >i.plotOptions[s].offsetX;<span class="cstat-no" title="statement not covered" ></span>if(!i.legend.show||i.legend.floating)<span class="cstat-no" title="statement not covered" >return e.gridHeight=e.svgHeight-i.grid.padding.left+i.grid.padding.right,e.gridWidth=e.gridHeight,e.translateY=r,void(e.translateX=n+(e.svgWidth-e.gridWidth)/2);<span class="cstat-no" title="statement not covered" >s</span></span>witch(i.legend.position){case"bottom":<span class="cstat-no" title="statement not covered" >e.gridHeight=e.svgHeight-this.lgRect.height-e.goldenPadding,e.gridWidth=e.gridHeight,e.translateY=r-10,e.translateX=n+(e.svgWidth-e.gridWidth)/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"top":<span class="cstat-no" title="statement not covered" >e.gridHeight=e.svgHeight-this.lgRect.height-e.goldenPadding,e.gridWidth=e.gridHeight,e.translateY=this.lgRect.height+r+10,e.translateX=n+(e.svgWidth-e.gridWidth)/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"left":<span class="cstat-no" title="statement not covered" >e.gridWidth=e.svgWidth-this.lgRect.width-a,e.gridHeight="auto"!==i.chart.height?e.svgHeight:e.gridWidth,e.translateY=r,e.translateX=n+this.lgRect.width+a;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >e.gridWidth=e.svgWidth-this.lgRect.width-a-5,e.gridHeight="auto"!==i.chart.height?e.svgHeight:e.gridWidth,e.translateY=r,e.translateX=n+10;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Legend position not supported")}</span>}</span>},{key:"conditionalChecksForAxisCoords",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.xAxisHeight=(t.height+e.height)*(i.globals.isMultiLineX?1.2:i.globals.LINE_HEIGHT_RATIO)+(i.globals.rotateXLabels?22:10),this.xAxisWidth=t.width,this.xAxisHeight-e.height&gt;i.config.xaxis.labels.maxHeight&amp;&amp;(this.xAxisHeight=i.config.xaxis.labels.maxHeight),i.config.xaxis.labels.minHeight&amp;&amp;this.xAxisHeight&lt;i.config.xaxis.labels.minHeight&amp;&amp;(this.xAxisHeight=i.config.xaxis.labels.minHeight),i.config.xaxis.floating&amp;&amp;(this.xAxisHeight=0);v</span>ar a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>i.config.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a+=t.labels.minWidth,s+=t.labels.maxWidth}</span>)),this.yAxisWidth&lt;a&amp;&amp;(this.yAxisWidth=a),this.yAxisWidth&gt;s&amp;&amp;(this.yAxisWidth=s)}</span>}]),t}</span>(),</span>ot=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.lgCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getLegendStyles",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >document.createElement("style");<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("type","text/css");v</span>ar e=<span class="cstat-no" title="statement not covered" >document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");<span class="cstat-no" title="statement not covered" ></span>return t.appendChild(e),t}</span>},{key:"getLegendBBox",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),</span>e=<span class="cstat-no" title="statement not covered" >t.width;<span class="cstat-no" title="statement not covered" ></span>return{clwh:t.height,clww:e}}</span>},{key:"appendToForeignObject",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>t.dom.elLegendForeign=document.createElementNS(t.SVGNS,"foreignObject");v</span>ar e=<span class="cstat-no" title="statement not covered" >t.dom.elLegendForeign;<span class="cstat-no" title="statement not covered" ></span>e.setAttribute("x",0),e.setAttribute("y",0),e.setAttribute("width",t.svgWidth),e.setAttribute("height",t.svgHeight),t.dom.elLegendWrap.setAttribute("xmlns","http://www.w3.org/1999/xhtml"),e.appendChild(t.dom.elLegendWrap),e.appendChild(this.getLegendStyles()),t.dom.Paper.node.insertBefore(e,t.dom.elGraphical.node)}</span>},{key:"toggleDataSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(a.globals.axisCharts||"radialBar"===a.config.chart.type){<span class="cstat-no" title="statement not covered" >a.globals.resized=!0;v</span>ar s=<span class="cstat-no" title="statement not covered" >null,</span>r=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(a.globals.risingSeries=[],a.globals.axisCharts?(s=a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t,"']")),r=parseInt(s.getAttribute("data:realIndex"),10)):(s=a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t+1,"']")),r=parseInt(s.getAttribute("rel"),10)-1),e)<span class="cstat-no" title="statement not covered" >[{cs:a.globals.collapsedSeries,csi:a.globals.collapsedSeriesIndices},{cs:a.globals.ancillaryCollapsedSeries,csi:a.globals.ancillaryCollapsedSeriesIndices}].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.riseCollapsedSeries(t.cs,t.csi,r)}</span>));e</span>lse <span class="cstat-no" title="statement not covered" >this.hideSeries({seriesEl:s,realIndex:r})}</span></span>else{var n=<span class="cstat-no" title="statement not covered" >a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t+1,"'] path")),</span>o=<span class="cstat-no" title="statement not covered" >a.config.chart.type;<span class="cstat-no" title="statement not covered" ></span>if("pie"===o||"polarArea"===o||"donut"===o){var l=<span class="cstat-no" title="statement not covered" >a.config.plotOptions.pie.donut.labels;<span class="cstat-no" title="statement not covered" ></span>new p(this.lgCtx.ctx).pathMouseDown(n.members[0],null),this.lgCtx.ctx.pie.printDataLabelsInner(n.members[0].node,l)}<span class="cstat-no" title="statement not covered" ></span>n</span>.fire("click")}</span>}</span>},{key:"hideSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.seriesEl,</span>i=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >g.clone(a.config.series);<span class="cstat-no" title="statement not covered" ></span>if(a.globals.axisCharts){var r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(a.config.yaxis[i]&amp;&amp;a.config.yaxis[i].show&amp;&amp;a.config.yaxis[i].showAlways&amp;&amp;(r=!0,a.globals.ancillaryCollapsedSeriesIndices.indexOf(i)&lt;0&amp;&amp;(a.globals.ancillaryCollapsedSeries.push({index:i,data:s[i].data.slice(),type:e.parentNode.className.baseVal.split("-")[1]}),a.globals.ancillaryCollapsedSeriesIndices.push(i))),!r){<span class="cstat-no" title="statement not covered" >a.globals.collapsedSeries.push({index:i,data:s[i].data.slice(),type:e.parentNode.className.baseVal.split("-")[1]}),a.globals.collapsedSeriesIndices.push(i);v</span>ar n=<span class="cstat-no" title="statement not covered" >a.globals.risingSeries.indexOf(i);<span class="cstat-no" title="statement not covered" ></span>a.globals.risingSeries.splice(n,1)}<span class="cstat-no" title="statement not covered" ></span>s</span>[i].data=[]}</span>else <span class="cstat-no" title="statement not covered" >a.globals.collapsedSeries.push({index:i,data:s[i]}),a.globals.collapsedSeriesIndices.push(i),s[i]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >e.childNodes,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o.length;l++)<span class="cstat-no" title="statement not covered" >o[l].classList.contains("apexcharts-series-markers-wrap")&amp;&amp;(o[l].classList.contains("apexcharts-hide")?o[l].classList.remove("apexcharts-hide"):o[l].classList.add("apexcharts-hide"));<span class="cstat-no" title="statement not covered" >a</span></span>.globals.allSeriesCollapsed=a.globals.collapsedSeries.length===a.config.series.length,this.lgCtx.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled)}</span>},{key:"riseCollapsedSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.length;s++)<span class="cstat-no" title="statement not covered" >t[s].index===i&amp;&amp;(a.globals.axisCharts?(a.config.series[i].data=t[s].data.slice(),t.splice(s,1),e.splice(s,1),a.globals.risingSeries.push(i)):(a.config.series[i]=t[s].data,t.splice(s,1),e.splice(s,1),a.globals.risingSeries.push(i)),this.lgCtx.ctx.updateHelpers._updateSeries(a.config.series,a.config.chart.animations.dynamicAnimation.enabled))}</span></span></span>}]),t}</span>(),</span>lt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.onLegendClick=this.onLegendClick.bind(this),this.onLegendHovered=this.onLegendHovered.bind(this),this.isBarsDistributed="bar"===this.w.config.chart.type&amp;&amp;this.w.config.plotOptions.bar.distributed&amp;&amp;1===this.w.config.series.length,this.legendHelpers=new ot(this)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals,</span>i=<span class="cstat-no" title="statement not covered" >t.config;<span class="cstat-no" title="statement not covered" ></span>if((i.legend.showForSingleSeries&amp;&amp;1===e.series.length||this.isBarsDistributed||e.series.length&gt;1||!e.axisCharts)&amp;&amp;i.legend.show){<span class="cstat-no" title="statement not covered" >for(;e.dom.elLegendWrap.firstChild;)<span class="cstat-no" title="statement not covered" >e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);<span class="cstat-no" title="statement not covered" >t</span></span>his.drawLegends(),g.isIE11()?document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()):this.legendHelpers.appendToForeignObject(),"bottom"===i.legend.position||"top"===i.legend.position?this.legendAlignHorizontal():"right"!==i.legend.position&amp;&amp;"left"!==i.legend.position||this.legendAlignVertical()}</span>}</span>},{key:"drawLegends",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.config.legend.fontFamily,</span>i=<span class="cstat-no" title="statement not covered" >t.globals.seriesNames,</span>a=<span class="cstat-no" title="statement not covered" >t.globals.colors.slice();<span class="cstat-no" title="statement not covered" ></span>if("heatmap"===t.config.chart.type){var s=<span class="cstat-no" title="statement not covered" >t.config.plotOptions.heatmap.colorScale.ranges;<span class="cstat-no" title="statement not covered" ></span>i=s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.name?t.name:t.from+" - "+t.to}</span>)),a=s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.color}</span>))}</span>else <span class="cstat-no" title="statement not covered" >this.isBarsDistributed&amp;&amp;(i=t.globals.labels.slice());<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >t.globals.legendFormatter,</span>n=<span class="cstat-no" title="statement not covered" >t.config.legend.inverseOrder,</span>o=<span class="cstat-no" title="statement not covered" >n?i.length-1:0;</span>n?o&gt;=0:o&lt;=i.length-1;n?o--:o++){var l=<span class="cstat-no" title="statement not covered" >r(i[o],{seriesIndex:o,w:t}),</span>h=<span class="cstat-no" title="statement not covered" >!1,</span>c=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(t.globals.collapsedSeries.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;t.globals.collapsedSeries.length;d++)<span class="cstat-no" title="statement not covered" >t.globals.collapsedSeries[d].index===o&amp;&amp;(h=!0);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(t.globals.ancillaryCollapsedSeriesIndices.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;t.globals.ancillaryCollapsedSeriesIndices.length;g++)<span class="cstat-no" title="statement not covered" >t.globals.ancillaryCollapsedSeriesIndices[g]===o&amp;&amp;(c=!0);v</span></span></span>ar u=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>u.classList.add("apexcharts-legend-marker");v</span>ar f=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.offsetX,</span>x=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.offsetY,</span>b=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.height,</span>v=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.width,</span>y=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.strokeWidth,</span>w=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.strokeColor,</span>k=<span class="cstat-no" title="statement not covered" >t.config.legend.markers.radius,</span>A=<span class="cstat-no" title="statement not covered" >u.style;<span class="cstat-no" title="statement not covered" ></span>A.background=a[o],A.color=a[o],t.config.legend.markers.fillColors&amp;&amp;t.config.legend.markers.fillColors[o]&amp;&amp;(A.background=t.config.legend.markers.fillColors[o]),A.height=Array.isArray(b)?parseFloat(b[o])+"px":parseFloat(b)+"px",A.width=Array.isArray(v)?parseFloat(v[o])+"px":parseFloat(v)+"px",A.left=Array.isArray(f)?f[o]:f,A.top=Array.isArray(x)?x[o]:x,A.borderWidth=Array.isArray(y)?y[o]:y,A.borderColor=Array.isArray(w)?w[o]:w,A.borderRadius=Array.isArray(k)?parseFloat(k[o])+"px":parseFloat(k)+"px",t.config.legend.markers.customHTML&amp;&amp;(Array.isArray(t.config.legend.markers.customHTML)?t.config.legend.markers.customHTML[o]&amp;&amp;(u.innerHTML=t.config.legend.markers.customHTML[o]()):u.innerHTML=t.config.legend.markers.customHTML()),p.setAttrs(u,{rel:o+1,"data:collapsed":h||c}),(h||c)&amp;&amp;u.classList.add("apexcharts-inactive-legend");v</span>ar S=<span class="cstat-no" title="statement not covered" >document.createElement("div"),</span>C=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>C.classList.add("apexcharts-legend-text"),C.innerHTML=Array.isArray(l)?l.join(" "):l;v</span>ar L=<span class="cstat-no" title="statement not covered" >t.config.legend.labels.useSeriesColors?t.globals.colors[o]:t.config.legend.labels.colors;<span class="cstat-no" title="statement not covered" ></span>L||(L=t.config.chart.foreColor),C.style.color=L,C.style.fontSize=parseFloat(t.config.legend.fontSize)+"px",C.style.fontWeight=t.config.legend.fontWeight,C.style.fontFamily=e||t.config.chart.fontFamily,p.setAttrs(C,{rel:o+1,i:o,"data:default-text":encodeURIComponent(l),"data:collapsed":h||c}),S.appendChild(u),S.appendChild(C);v</span>ar P=<span class="cstat-no" title="statement not covered" >new m(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(!t.config.legend.showForZeroSeries)<span class="cstat-no" title="statement not covered" >0===P.getSeriesTotalByIndex(o)&amp;&amp;P.seriesHaveSameValues(o)&amp;&amp;!P.isSeriesNull(o)&amp;&amp;-1===t.globals.collapsedSeriesIndices.indexOf(o)&amp;&amp;-1===t.globals.ancillaryCollapsedSeriesIndices.indexOf(o)&amp;&amp;S.classList.add("apexcharts-hidden-zero-series");<span class="cstat-no" title="statement not covered" >t</span></span>.config.legend.showForNullSeries||P.isSeriesNull(o)&amp;&amp;-1===t.globals.collapsedSeriesIndices.indexOf(o)&amp;&amp;-1===t.globals.ancillaryCollapsedSeriesIndices.indexOf(o)&amp;&amp;S.classList.add("apexcharts-hidden-null-series"),t.globals.dom.elLegendWrap.appendChild(S),t.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t.config.legend.horizontalAlign)),t.globals.dom.elLegendWrap.classList.add("position-"+t.config.legend.position),S.classList.add("apexcharts-legend-series"),S.style.margin="".concat(t.config.legend.itemMargin.vertical,"px ").concat(t.config.legend.itemMargin.horizontal,"px"),t.globals.dom.elLegendWrap.style.width=t.config.legend.width?t.config.legend.width+"px":"",t.globals.dom.elLegendWrap.style.height=t.config.legend.height?t.config.legend.height+"px":"",p.setAttrs(S,{rel:o+1,"data:collapsed":h||c}),(h||c)&amp;&amp;S.classList.add("apexcharts-inactive-legend"),t.config.legend.onItemClick.toggleDataSeries||S.classList.add("apexcharts-no-click")}<span class="cstat-no" title="statement not covered" ></span>"</span>heatmap"!==t.config.chart.type&amp;&amp;!this.isBarsDistributed&amp;&amp;t.config.legend.onItemClick.toggleDataSeries&amp;&amp;t.globals.dom.elWrap.addEventListener("click",this.onLegendClick,!0),t.config.legend.onItemHover.highlightDataSeries&amp;&amp;(t.globals.dom.elWrap.addEventListener("mousemove",this.onLegendHovered,!0),t.globals.dom.elWrap.addEventListener("mouseout",this.onLegendHovered,!0))}</span>},{key:"setLegendWrapXY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(".apexcharts-legend"),</span>s=<span class="cstat-no" title="statement not covered" >a.getBoundingClientRect(),</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if("bottom"===i.config.legend.position)<span class="cstat-no" title="statement not covered" >n+=i.globals.svgHeight-s.height/2;e</span>lse <span class="cstat-no" title="statement not covered" >if("top"===i.config.legend.position){var o=<span class="cstat-no" title="statement not covered" >new nt(this.ctx),</span>l=<span class="cstat-no" title="statement not covered" >o.dimHelpers.getTitleSubtitleCoords("title").height,</span>h=<span class="cstat-no" title="statement not covered" >o.dimHelpers.getTitleSubtitleCoords("subtitle").height;<span class="cstat-no" title="statement not covered" ></span>n=n+(l&gt;0?l-10:0)+(h&gt;0?h-10:0)}<span class="cstat-no" title="statement not covered" ></span>a</span></span>.style.position="absolute",r=r+t+i.config.legend.offsetX,n=n+e+i.config.legend.offsetY,a.style.left=r+"px",a.style.top=n+"px","bottom"===i.config.legend.position?(a.style.top="auto",a.style.bottom=5-i.config.legend.offsetY+"px"):"right"===i.config.legend.position&amp;&amp;(a.style.left="auto",a.style.right=25+i.config.legend.offsetX+"px");<span class="cstat-no" title="statement not covered" >[</span>"width","height"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.style[t]&amp;&amp;(a.style[t]=parseInt(i.config.legend[t],10)+"px")}</span>))}</span>},{key:"legendAlignHorizontal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right=0;v</span>ar e=<span class="cstat-no" title="statement not covered" >this.legendHelpers.getLegendBBox(),</span>i=<span class="cstat-no" title="statement not covered" >new nt(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >i.dimHelpers.getTitleSubtitleCoords("title"),</span>s=<span class="cstat-no" title="statement not covered" >i.dimHelpers.getTitleSubtitleCoords("subtitle"),</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>"bottom"===t.config.legend.position?r=-e.clwh/1.8:"top"===t.config.legend.position&amp;&amp;(r=a.height+s.height+t.config.title.margin+t.config.subtitle.margin-10),this.setLegendWrapXY(20,r)}</span>},{key:"legendAlignVertical",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.legendHelpers.getLegendBBox(),</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>"left"===t.config.legend.position&amp;&amp;(i=20),"right"===t.config.legend.position&amp;&amp;(i=t.globals.svgWidth-e.clww-10),this.setLegendWrapXY(i,20)}</span>},{key:"onLegendHovered",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >t.target.classList.contains("apexcharts-legend-text")||t.target.classList.contains("apexcharts-legend-marker");<span class="cstat-no" title="statement not covered" ></span>if("heatmap"===e.config.chart.type||this.isBarsDistributed){<span class="cstat-no" title="statement not covered" >if(i){var a=<span class="cstat-no" title="statement not covered" >parseInt(t.target.getAttribute("rel"),10)-1;<span class="cstat-no" title="statement not covered" ></span>this.ctx.events.fireEvent("legendHover",[this.ctx,a,this.w]),new M(this.ctx).highlightRangeInSeries(t,t.target)}</span>}</span>else<span class="cstat-no" title="statement not covered" >!t.target.classList.contains("apexcharts-inactive-legend")&amp;&amp;i&amp;&amp;new M(this.ctx).toggleSeriesOnHover(t,t.target)}</span></span>},{key:"onLegendClick",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t.target.classList.contains("apexcharts-legend-text")||t.target.classList.contains("apexcharts-legend-marker")){var e=<span class="cstat-no" title="statement not covered" >parseInt(t.target.getAttribute("rel"),10)-1,</span>i=<span class="cstat-no" title="statement not covered" >"true"===t.target.getAttribute("data:collapsed"),</span>a=<span class="cstat-no" title="statement not covered" >this.w.config.chart.events.legendClick;<span class="cstat-no" title="statement not covered" ></span>"function"==typeof a&amp;&amp;a(this.ctx,e,this.w),this.ctx.events.fireEvent("legendClick",[this.ctx,e,this.w]);v</span>ar s=<span class="cstat-no" title="statement not covered" >this.w.config.legend.markers.onClick;<span class="cstat-no" title="statement not covered" ></span>"function"==typeof s&amp;&amp;t.target.classList.contains("apexcharts-legend-marker")&amp;&amp;(s(this.ctx,e,this.w),this.ctx.events.fireEvent("legendMarkerClick",[this.ctx,e,this.w])),this.legendHelpers.toggleDataSeries(e,i)}</span>}</span>}]),t}</span>(),</span>ht=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.ev=this.w.config.chart.events,this.selectedClass="apexcharts-selected",this.localeValues=this.w.globals.locale.toolbar}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"createToolbar",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return document.createElement("div")}</span>,</span>a=<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" ></span>if(a.setAttribute("class","apexcharts-toolbar"),a.style.top=e.config.chart.toolbar.offsetY+"px",a.style.right=3-e.config.chart.toolbar.offsetX+"px",e.globals.dom.elWrap.appendChild(a),this.elZoom=i(),this.elZoomIn=i(),this.elZoomOut=i(),this.elPan=i(),this.elSelection=i(),this.elZoomReset=i(),this.elMenuIcon=i(),this.elMenu=i(),this.elCustomIcons=[],this.t=e.config.chart.toolbar.tools,Array.isArray(this.t.customIcons))<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.t.customIcons.length;s++)<span class="cstat-no" title="statement not covered" >this.elCustomIcons.push(i());v</span></span></span>ar r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i,a,s){var n=<span class="cstat-no" title="statement not covered" >i.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>t.t[n]&amp;&amp;e.config.chart.zoom.enabled&amp;&amp;r.push({el:a,icon:"string"==typeof t.t[n]?t.t[n]:s,title:t.localeValues[i],class:"apexcharts-".concat(n,"-icon")})}</span>;<span class="cstat-no" title="statement not covered" ></span>n("zoomIn",this.elZoomIn,'&lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"&gt;\n    &lt;path d="M0 0h24v24H0z" fill="none"/&gt;\n    &lt;path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/&gt;\n&lt;/svg&gt;\n'),n("zoomOut",this.elZoomOut,'&lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"&gt;\n    &lt;path d="M0 0h24v24H0z" fill="none"/&gt;\n    &lt;path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/&gt;\n&lt;/svg&gt;\n');v</span>ar o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.t[i]&amp;&amp;e.config.chart[i].enabled&amp;&amp;r.push({el:"zoom"===i?t.elZoom:t.elSelection,icon:"string"==typeof t.t[i]?t.t[i]:"zoom"===i?'&lt;svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24"&gt;\n    &lt;path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/&gt;\n    &lt;path d="M0 0h24v24H0V0z" fill="none"/&gt;\n    &lt;path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/&gt;\n&lt;/svg&gt;':'&lt;svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;\n    &lt;path d="M0 0h24v24H0z" fill="none"/&gt;\n    &lt;path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/&gt;\n&lt;/svg&gt;',title:t.localeValues["zoom"===i?"selectionZoom":"selection"],class:e.globals.isTouchDevice?"apexcharts-element-hidden":"apexcharts-".concat(i,"-icon")})}</span>;<span class="cstat-no" title="statement not covered" ></span>o("zoom"),o("selection"),this.t.pan&amp;&amp;e.config.chart.zoom.enabled&amp;&amp;r.push({el:this.elPan,icon:"string"==typeof this.t.pan?this.t.pan:'&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24"&gt;\n    &lt;defs&gt;\n        &lt;path d="M0 0h24v24H0z" id="a"/&gt;\n    &lt;/defs&gt;\n    &lt;clipPath id="b"&gt;\n        &lt;use overflow="visible" xlink:href="#a"/&gt;\n    &lt;/clipPath&gt;\n    &lt;path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/&gt;\n&lt;/svg&gt;',title:this.localeValues.pan,class:e.globals.isTouchDevice?"apexcharts-element-hidden":"apexcharts-pan-icon"}),n("reset",this.elZoomReset,'&lt;svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"&gt;\n    &lt;path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/&gt;\n    &lt;path d="M0 0h24v24H0z" fill="none"/&gt;\n&lt;/svg&gt;'),this.t.download&amp;&amp;r.push({el:this.elMenuIcon,icon:"string"==typeof this.t.download?this.t.download:'&lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"&gt;&lt;path fill="none" d="M0 0h24v24H0V0z"/&gt;&lt;path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/&gt;&lt;/svg&gt;',title:this.localeValues.menu,class:"apexcharts-menu-icon"});<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;this.elCustomIcons.length;l++)<span class="cstat-no" title="statement not covered" >r.push({el:this.elCustomIcons[l],icon:this.t.customIcons[l].icon,title:this.t.customIcons[l].title,index:this.t.customIcons[l].index,class:"apexcharts-toolbar-custom-icon "+this.t.customIcons[l].class});<span class="cstat-no" title="statement not covered" >r</span></span>.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.index&amp;&amp;g.moveIndexInArray(r,e,t.index)}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;r.length;h++)<span class="cstat-no" title="statement not covered" >p.setAttrs(r[h].el,{class:r[h].class,title:r[h].title}),r[h].el.innerHTML=r[h].icon,a.appendChild(r[h].el);<span class="cstat-no" title="statement not covered" >t</span></span>his._createHamburgerMenu(a),e.globals.zoomEnabled?this.elZoom.classList.add(this.selectedClass):e.globals.panEnabled?this.elPan.classList.add(this.selectedClass):e.globals.selectionEnabled&amp;&amp;this.elSelection.classList.add(this.selectedClass),this.addToolbarEventListeners()}</span>},{key:"_createHamburgerMenu",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.elMenuItems=[],t.appendChild(this.elMenu),p.setAttrs(this.elMenu,{class:"apexcharts-menu"});v</span>ar e=<span class="cstat-no" title="statement not covered" >[{name:"exportSVG",title:this.localeValues.exportToSVG},{name:"exportPNG",title:this.localeValues.exportToPNG},{name:"exportCSV",title:this.localeValues.exportToCSV}];<span class="cstat-no" title="statement not covered" ></span>this.w.globals.allSeriesHasEqualX||e.splice(2,1);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++)<span class="cstat-no" title="statement not covered" >this.elMenuItems.push(document.createElement("div")),this.elMenuItems[i].innerHTML=e[i].title,p.setAttrs(this.elMenuItems[i],{class:"apexcharts-menu-item ".concat(e[i].name),title:e[i].title}),this.elMenu.appendChild(this.elMenuItems[i])}</span></span>},{key:"addToolbarEventListeners",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.elZoomReset.addEventListener("click",this.handleZoomReset.bind(this)),this.elSelection.addEventListener("click",this.toggleZoomSelection.bind(this,"selection")),this.elZoom.addEventListener("click",this.toggleZoomSelection.bind(this,"zoom")),this.elZoomIn.addEventListener("click",this.handleZoomIn.bind(this)),this.elZoomOut.addEventListener("click",this.handleZoomOut.bind(this)),this.elPan.addEventListener("click",this.togglePanning.bind(this)),this.elMenuIcon.addEventListener("click",this.toggleMenu.bind(this)),this.elMenuItems.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.classList.contains("exportSVG")?e.addEventListener("click",t.handleDownload.bind(t,"svg")):e.classList.contains("exportPNG")?e.addEventListener("click",t.handleDownload.bind(t,"png")):e.classList.contains("exportCSV")&amp;&amp;e.addEventListener("click",t.handleDownload.bind(t,"csv"))}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.t.customIcons.length;e++)<span class="cstat-no" title="statement not covered" >this.elCustomIcons[e].addEventListener("click",this.t.customIcons[e].click.bind(this,this.ctx,this.ctx.w))}</span></span>},{key:"toggleZoomSelection",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.ctx.getSyncedCharts().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.ctx.toolbar.toggleOtherControls();v</span>ar i=<span class="cstat-no" title="statement not covered" >"selection"===t?e.ctx.toolbar.elSelection:e.ctx.toolbar.elZoom,</span>a=<span class="cstat-no" title="statement not covered" >"selection"===t?"selectionEnabled":"zoomEnabled";<span class="cstat-no" title="statement not covered" ></span>e.w.globals[a]=!e.w.globals[a],i.classList.contains(e.ctx.toolbar.selectedClass)?i.classList.remove(e.ctx.toolbar.selectedClass):i.classList.add(e.ctx.toolbar.selectedClass)}</span>))}</span>},{key:"getToolbarIconsReference",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.elZoom||(this.elZoom=t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),this.elPan||(this.elPan=t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),this.elSelection||(this.elSelection=t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))}</span>},{key:"enableZoomPanFromToolbar",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.toggleOtherControls(),"pan"===t?this.w.globals.panEnabled=!0:this.w.globals.zoomEnabled=!0;v</span>ar e=<span class="cstat-no" title="statement not covered" >"pan"===t?this.elPan:this.elZoom,</span>i=<span class="cstat-no" title="statement not covered" >"pan"===t?this.elZoom:this.elPan;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.classList.add(this.selectedClass),i&amp;&amp;i.classList.remove(this.selectedClass)}</span>},{key:"togglePanning",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.ctx.getSyncedCharts().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.ctx.toolbar.toggleOtherControls(),t.w.globals.panEnabled=!t.w.globals.panEnabled,t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass)?t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass):t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass)}</span>))}</span>},{key:"toggleOtherControls",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>e.globals.panEnabled=!1,e.globals.zoomEnabled=!1,e.globals.selectionEnabled=!1,this.getToolbarIconsReference(),[this.elPan,this.elSelection,this.elZoom].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.classList.remove(t.selectedClass)}</span>))}</span>},{key:"handleZoomIn",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >(t.globals.minX+t.globals.maxX)/2,</span>i=<span class="cstat-no" title="statement not covered" >(t.globals.minX+e)/2,</span>a=<span class="cstat-no" title="statement not covered" >(t.globals.maxX+e)/2,</span>s=<span class="cstat-no" title="statement not covered" >this._getNewMinXMaxX(i,a);<span class="cstat-no" title="statement not covered" ></span>t.globals.disableZoomIn||this.zoomUpdateOptions(s.minX,s.maxX)}</span>},{key:"handleZoomOut",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(!("datetime"===t.config.xaxis.type&amp;&amp;new Date(t.globals.minX).getUTCFullYear()&lt;1e3)){var e=<span class="cstat-no" title="statement not covered" >(t.globals.minX+t.globals.maxX)/2,</span>i=<span class="cstat-no" title="statement not covered" >t.globals.minX-(e-t.globals.minX),</span>a=<span class="cstat-no" title="statement not covered" >t.globals.maxX-(e-t.globals.maxX),</span>s=<span class="cstat-no" title="statement not covered" >this._getNewMinXMaxX(i,a);<span class="cstat-no" title="statement not covered" ></span>t.globals.disableZoomOut||this.zoomUpdateOptions(s.minX,s.maxX)}</span>}</span>},{key:"_getNewMinXMaxX",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w.config.xaxis.convertedCatToNumeric;<span class="cstat-no" title="statement not covered" ></span>return{minX:i?Math.floor(t):t,maxX:i?Math.floor(e):e}}</span>},{key:"zoomUpdateOptions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t||void 0!==e){<span class="cstat-no" title="statement not covered" >if(!(i.config.xaxis.convertedCatToNumeric&amp;&amp;(t&lt;1&amp;&amp;(t=1,e=i.globals.dataPoints),e-t&lt;2))){var a=<span class="cstat-no" title="statement not covered" >{min:t,max:e},</span>s=<span class="cstat-no" title="statement not covered" >this.getBeforeZoomRange(a);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(a=s.xaxis);v</span>ar r=<span class="cstat-no" title="statement not covered" >{xaxis:a},</span>n=<span class="cstat-no" title="statement not covered" >g.clone(i.globals.initialConfig.yaxis);<span class="cstat-no" title="statement not covered" ></span>if(i.config.chart.zoom.autoScaleYaxis)<span class="cstat-no" title="statement not covered" >n=new j(this.ctx).autoScaleY(this.ctx,n,{xaxis:a});<span class="cstat-no" title="statement not covered" >i</span></span>.config.chart.group||(r.yaxis=n),this.w.globals.zoomed=!0,this.ctx.updateHelpers._updateOptions(r,!1,this.w.config.chart.animations.dynamicAnimation.enabled),this.zoomCallback(a,n)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.handleZoomReset()}</span></span>},{key:"zoomCallback",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >"function"==typeof this.ev.zoomed&amp;&amp;this.ev.zoomed(this.ctx,{xaxis:t,yaxis:e})}</span>},{key:"getBeforeZoomRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof this.ev.beforeZoom&amp;&amp;(i=this.ev.beforeZoom(this,{xaxis:t,yaxis:e})),i}</span>},{key:"toggleMenu",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>window.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.elMenu.classList.contains("apexcharts-menu-open")?t.elMenu.classList.remove("apexcharts-menu-open"):t.elMenu.classList.add("apexcharts-menu-open")}</span>),0)}</span>},{key:"handleDownload",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new V(this.ctx);<span class="cstat-no" title="statement not covered" ></span>switch(t){case"svg":<span class="cstat-no" title="statement not covered" >i.exportToSVG(this.ctx);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"png":<span class="cstat-no" title="statement not covered" >i.exportToPng(this.ctx);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"csv":<span class="cstat-no" title="statement not covered" >i.exportToCSV({series:e.config.series})}</span>}</span>},{key:"handleZoomReset",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.ctx.getSyncedCharts().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.w;<span class="cstat-no" title="statement not covered" ></span>e.globals.lastXAxis.min=void 0,e.globals.lastXAxis.max=void 0,t.updateHelpers.revertDefaultAxisMinMax(),"function"==typeof e.config.chart.events.zoomed&amp;&amp;t.ctx.toolbar.zoomCallback({min:e.config.xaxis.min,max:e.config.xaxis.max}),e.globals.zoomed=!1;v</span>ar i=<span class="cstat-no" title="statement not covered" >t.ctx.series.emptyCollapsedSeries(g.clone(e.globals.initialSeries));<span class="cstat-no" title="statement not covered" ></span>t.updateHelpers._updateSeries(i,e.config.chart.animations.dynamicAnimation.enabled)}</span>))}</span>},{key:"destroy",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.elZoom=null,this.elZoomIn=null,this.elZoomOut=null,this.elPan=null,this.elSelection=null,this.elZoomReset=null,this.elMenuIcon=null}</span>}]),t}</span>(),</span>ct=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >i(</span>t){var a;<span class="cstat-no" title="statement not covered" >return e(this,i),(a=c(this,l(i).call(this,t))).ctx=t,a.w=t.w,a.dragged=!1,a.graphics=new p(a.ctx),a.eventList=["mousedown","mouseleave","mousemove","touchstart","touchmove","mouseup","touchend"],a.clientX=0,a.clientY=0,a.startX=0,a.endX=0,a.dragX=0,a.startY=0,a.endY=0,a.dragY=0,a.moveDirection="none",a}<span class="cstat-no" title="statement not covered" ></span>return o(i,t),a(i,[{key:"init",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >t.xyRatios,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.xyRatios=i,this.zoomRect=this.graphics.drawRect(0,0,0,0),this.selectionRect=this.graphics.drawRect(0,0,0,0),this.gridRect=a.globals.dom.baseEl.querySelector(".apexcharts-grid"),this.zoomRect.node.classList.add("apexcharts-zoom-rect"),this.selectionRect.node.classList.add("apexcharts-selection-rect"),a.globals.dom.elGraphical.add(this.zoomRect),a.globals.dom.elGraphical.add(this.selectionRect),"x"===a.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,minY:0,maxX:a.globals.gridWidth,maxY:a.globals.gridHeight}).on("dragmove",this.selectionDragging.bind(this,"dragging")):"y"===a.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,maxX:a.globals.gridWidth}).on("dragmove",this.selectionDragging.bind(this,"dragging")):this.slDraggableRect=this.selectionRect.draggable().on("dragmove",this.selectionDragging.bind(this,"dragging")),this.preselectedSelection(),this.hoverArea=a.globals.dom.baseEl.querySelector(a.globals.chartClass),this.hoverArea.classList.add("apexcharts-zoomable"),this.eventList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.hoverArea.addEventListener(t,s.svgMouseEvents.bind(s,i),{capture:!1,passive:!0})}</span>))}</span>},{key:"destroy",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.slDraggableRect&amp;&amp;(this.slDraggableRect.draggable(!1),this.slDraggableRect.off(),this.selectionRect.off()),this.selectionRect=null,this.zoomRect=null,this.gridRect=null}</span>},{key:"svgMouseEvents",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.ctx.toolbar,</span>r=<span class="cstat-no" title="statement not covered" >i.globals.zoomEnabled?i.config.chart.zoom.type:i.config.chart.selection.type,</span>n=<span class="cstat-no" title="statement not covered" >i.config.chart.toolbar.autoSelected;<span class="cstat-no" title="statement not covered" ></span>if(e.shiftKey?(this.shiftWasPressed=!0,s.enableZoomPanFromToolbar("pan"===n?"zoom":"pan")):this.shiftWasPressed&amp;&amp;(s.enableZoomPanFromToolbar(n),this.shiftWasPressed=!1),!(e.target.classList.contains("apexcharts-selection-rect")||e.target.parentNode.classList.contains("apexcharts-toolbar"))){<span class="cstat-no" title="statement not covered" >if(a.clientX="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientX:"touchend"===e.type?e.changedTouches[0].clientX:e.clientX,a.clientY="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientY:"touchend"===e.type?e.changedTouches[0].clientY:e.clientY,"mousedown"===e.type&amp;&amp;1===e.which){var o=<span class="cstat-no" title="statement not covered" >a.gridRect.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>a.startX=a.clientX-o.left,a.startY=a.clientY-o.top,a.dragged=!1,a.w.globals.mousedown=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(("mousemove"===e.type&amp;&amp;1===e.which||"touchmove"===e.type)&amp;&amp;(a.dragged=!0,i.globals.panEnabled?(i.globals.selection=null,a.w.globals.mousedown&amp;&amp;a.panDragging({context:a,zoomtype:r,xyRatios:t})):(a.w.globals.mousedown&amp;&amp;i.globals.zoomEnabled||a.w.globals.mousedown&amp;&amp;i.globals.selectionEnabled)&amp;&amp;(a.selection=a.selectionDrawing({context:a,zoomtype:r}))),"mouseup"===e.type||"touchend"===e.type||"mouseleave"===e.type){var l=<span class="cstat-no" title="statement not covered" >a.gridRect.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>a.w.globals.mousedown&amp;&amp;(a.endX=a.clientX-l.left,a.endY=a.clientY-l.top,a.dragX=Math.abs(a.endX-a.startX),a.dragY=Math.abs(a.endY-a.startY),(i.globals.zoomEnabled||i.globals.selectionEnabled)&amp;&amp;a.selectionDrawn({context:a,zoomtype:r}),i.globals.panEnabled&amp;&amp;i.config.xaxis.convertedCatToNumeric&amp;&amp;a.delayedPanScrolled()),i.globals.zoomEnabled&amp;&amp;a.hideSelectionRect(this.selectionRect),a.dragged=!1,a.w.globals.mousedown=!1}<span class="cstat-no" title="statement not covered" ></span>t</span>his.makeSelectionRectDraggable()}</span>}</span>},{key:"makeSelectionRectDraggable",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(this.selectionRect){var e=<span class="cstat-no" title="statement not covered" >this.selectionRect.node.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>e.width&gt;0&amp;&amp;e.height&gt;0&amp;&amp;this.slDraggableRect.selectize({points:"l, r",pointSize:8,pointType:"rect"}).resize({constraint:{minX:0,minY:0,maxX:t.globals.gridWidth,maxY:t.globals.gridHeight}}).on("resizing",this.selectionDragging.bind(this,"resizing"))}</span>}</span>},{key:"preselectedSelection",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.xyRatios;<span class="cstat-no" title="statement not covered" ></span>if(!t.globals.zoomEnabled)<span class="cstat-no" title="statement not covered" >if(void 0!==t.globals.selection&amp;&amp;null!==t.globals.selection)<span class="cstat-no" title="statement not covered" >this.drawSelectionRect(t.globals.selection);e</span>lse <span class="cstat-no" title="statement not covered" >if(void 0!==t.config.chart.selection.xaxis.min&amp;&amp;void 0!==t.config.chart.selection.xaxis.max){var i=<span class="cstat-no" title="statement not covered" >(t.config.chart.selection.xaxis.min-t.globals.minX)/e.xRatio,</span>a=<span class="cstat-no" title="statement not covered" >{x:i,y:0,width:t.globals.gridWidth-(t.globals.maxX-t.config.chart.selection.xaxis.max)/e.xRatio-i,height:t.globals.gridHeight,translateX:0,translateY:0,selectionEnabled:!0};<span class="cstat-no" title="statement not covered" ></span>this.drawSelectionRect(a),this.makeSelectionRectDraggable(),"function"==typeof t.config.chart.events.selection&amp;&amp;t.config.chart.events.selection(this.ctx,{xaxis:{min:t.config.chart.selection.xaxis.min,max:t.config.chart.selection.xaxis.max},yaxis:{}})}</span>}</span></span></span>},{key:"drawSelectionRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.x,</span>i=<span class="cstat-no" title="statement not covered" >t.y,</span>a=<span class="cstat-no" title="statement not covered" >t.width,</span>s=<span class="cstat-no" title="statement not covered" >t.height,</span>r=<span class="cstat-no" title="statement not covered" >t.translateX,</span>n=<span class="cstat-no" title="statement not covered" >void 0===r?0:r,</span>o=<span class="cstat-no" title="statement not covered" >t.translateY,</span>l=<span class="cstat-no" title="statement not covered" >void 0===o?0:o,</span>h=<span class="cstat-no" title="statement not covered" >this.w,</span>c=<span class="cstat-no" title="statement not covered" >this.zoomRect,</span>d=<span class="cstat-no" title="statement not covered" >this.selectionRect;<span class="cstat-no" title="statement not covered" ></span>if(this.dragged||null!==h.globals.selection){var g=<span class="cstat-no" title="statement not covered" >{transform:"translate("+n+", "+l+")"};<span class="cstat-no" title="statement not covered" ></span>h.globals.zoomEnabled&amp;&amp;this.dragged&amp;&amp;(a&lt;0&amp;&amp;(a=1),c.attr({x:e,y:i,width:a,height:s,fill:h.config.chart.zoom.zoomedArea.fill.color,"fill-opacity":h.config.chart.zoom.zoomedArea.fill.opacity,stroke:h.config.chart.zoom.zoomedArea.stroke.color,"stroke-width":h.config.chart.zoom.zoomedArea.stroke.width,"stroke-opacity":h.config.chart.zoom.zoomedArea.stroke.opacity}),p.setAttrs(c.node,g)),h.globals.selectionEnabled&amp;&amp;(d.attr({x:e,y:i,width:a&gt;0?a:0,height:s&gt;0?s:0,fill:h.config.chart.selection.fill.color,"fill-opacity":h.config.chart.selection.fill.opacity,stroke:h.config.chart.selection.stroke.color,"stroke-width":h.config.chart.selection.stroke.width,"stroke-dasharray":h.config.chart.selection.stroke.dashArray,"stroke-opacity":h.config.chart.selection.stroke.opacity}),p.setAttrs(d.node,g))}</span>}</span>},{key:"hideSelectionRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.attr({x:0,y:0,width:0,height:0})}</span>},{key:"selectionDrawing",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.context,</span>i=<span class="cstat-no" title="statement not covered" >t.zoomtype,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >this.gridRect.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >s.startX-1,</span>o=<span class="cstat-no" title="statement not covered" >s.startY,</span>l=<span class="cstat-no" title="statement not covered" >!1,</span>h=<span class="cstat-no" title="statement not covered" >!1,</span>c=<span class="cstat-no" title="statement not covered" >s.clientX-r.left-n,</span>d=<span class="cstat-no" title="statement not covered" >s.clientY-r.top-o,</span>g=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Math.abs(c+n)&gt;a.globals.gridWidth?c=a.globals.gridWidth-n:s.clientX-r.left&lt;0&amp;&amp;(c=n),n&gt;s.clientX-r.left&amp;&amp;(l=!0,c=Math.abs(c)),o&gt;s.clientY-r.top&amp;&amp;(h=!0,d=Math.abs(d)),g="x"===i?{x:l?n-c:n,y:0,width:c,height:a.globals.gridHeight}:"y"===i?{x:0,y:h?o-d:o,width:a.globals.gridWidth,height:d}:{x:l?n-c:n,y:h?o-d:o,width:c,height:d},s.drawSelectionRect(g),s.selectionDragging("resizing"),g}</span>},{key:"selectionDragging",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >this.xyRatios,</span>r=<span class="cstat-no" title="statement not covered" >this.selectionRect,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>"resizing"===t&amp;&amp;(n=30);v</span>ar o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseFloat(r.node.getAttribute(t))}</span>,</span>l=<span class="cstat-no" title="statement not covered" >{x:o("x"),y:o("y"),width:o("width"),height:o("height")};<span class="cstat-no" title="statement not covered" ></span>a.globals.selection=l,"function"==typeof a.config.chart.events.selection&amp;&amp;a.globals.selectionEnabled&amp;&amp;(clearTimeout(this.w.globals.selectionResizeTimer),this.w.globals.selectionResizeTimer=window.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >i.gridRect.getBoundingClientRect(),</span>e=<span class="cstat-no" title="statement not covered" >r.node.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >a.globals.xAxisScale.niceMin+(e.left-t.left)*s.xRatio,</span>o=<span class="cstat-no" title="statement not covered" >a.globals.xAxisScale.niceMin+(e.right-t.left)*s.xRatio,</span>l=<span class="cstat-no" title="statement not covered" >a.globals.yAxisScale[0].niceMin+(t.bottom-e.bottom)*s.yRatio[0],</span>h=<span class="cstat-no" title="statement not covered" >a.globals.yAxisScale[0].niceMax-(e.top-t.top)*s.yRatio[0];<span class="cstat-no" title="statement not covered" ></span>a.config.chart.events.selection(i.ctx,{xaxis:{min:n,max:o},yaxis:{min:l,max:h}})}</span>),n))}</span>},{key:"selectionDrawn",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.context,</span>i=<span class="cstat-no" title="statement not covered" >t.zoomtype,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >this.xyRatios,</span>n=<span class="cstat-no" title="statement not covered" >this.ctx.toolbar;<span class="cstat-no" title="statement not covered" ></span>if(s.startX&gt;s.endX){var o=<span class="cstat-no" title="statement not covered" >s.startX;<span class="cstat-no" title="statement not covered" ></span>s.startX=s.endX,s.endX=o}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.startY&gt;s.endY){var l=<span class="cstat-no" title="statement not covered" >s.startY;<span class="cstat-no" title="statement not covered" ></span>s.startY=s.endY,s.endY=l}</span>v</span>ar h=<span class="cstat-no" title="statement not covered" >a.globals.xAxisScale.niceMin+s.startX*r.xRatio,</span>c=<span class="cstat-no" title="statement not covered" >a.globals.xAxisScale.niceMin+s.endX*r.xRatio,</span>d=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(a.config.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >d.push(a.globals.yAxisScale[e].niceMax-r.yRatio[e]*s.startY),u.push(a.globals.yAxisScale[e].niceMax-r.yRatio[e]*s.endY)}</span>)),s.dragged&amp;&amp;(s.dragX&gt;10||s.dragY&gt;10)&amp;&amp;h!==c)<span class="cstat-no" title="statement not covered" >if(a.globals.zoomEnabled){var f=<span class="cstat-no" title="statement not covered" >g.clone(a.globals.initialConfig.yaxis),</span>p=<span class="cstat-no" title="statement not covered" >g.clone(a.globals.initialConfig.xaxis);<span class="cstat-no" title="statement not covered" ></span>if(a.globals.zoomed=!0,a.globals.zoomed||(a.globals.lastXAxis=g.clone(a.config.xaxis),a.globals.lastYAxis=g.clone(a.config.yaxis)),a.config.xaxis.convertedCatToNumeric&amp;&amp;(h=Math.floor(h),c=Math.floor(c),h&lt;1&amp;&amp;(h=1,c=a.globals.dataPoints),c-h&lt;2&amp;&amp;(c=h+1)),"xy"!==i&amp;&amp;"x"!==i||(p={min:h,max:c}),"xy"!==i&amp;&amp;"y"!==i||f.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >f[e].min=u[e],f[e].max=d[e]}</span>)),a.config.chart.zoom.autoScaleYaxis){var x=<span class="cstat-no" title="statement not covered" >new j(s.ctx);<span class="cstat-no" title="statement not covered" ></span>f=x.autoScaleY(s.ctx,f,{xaxis:p})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n){var b=<span class="cstat-no" title="statement not covered" >n.getBeforeZoomRange(p,f);<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;(p=b.xaxis?b.xaxis:p,f=b.yaxis?b.yaxe:f)}</span>v</span>ar m=<span class="cstat-no" title="statement not covered" >{xaxis:p};<span class="cstat-no" title="statement not covered" ></span>a.config.chart.group||(m.yaxis=f),s.ctx.updateHelpers._updateOptions(m,!1,s.w.config.chart.animations.dynamicAnimation.enabled),"function"==typeof a.config.chart.events.zoomed&amp;&amp;n.zoomCallback(p,f)}</span>else <span class="cstat-no" title="statement not covered" >if(a.globals.selectionEnabled){var v,y=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>v={min:h,max:c},"xy"!==i&amp;&amp;"y"!==i||(y=g.clone(a.config.yaxis)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >y[e].min=u[e],y[e].max=d[e]}</span>)),a.globals.selection=s.selection,"function"==typeof a.config.chart.events.selection&amp;&amp;a.config.chart.events.selection(s.ctx,{xaxis:v,yaxis:y})}</span>}</span></span></span>},{key:"panDragging",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.context,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i.globals.lastClientPosition.x){var s=<span class="cstat-no" title="statement not covered" >i.globals.lastClientPosition.x-a.clientX,</span>r=<span class="cstat-no" title="statement not covered" >i.globals.lastClientPosition.y-a.clientY;<span class="cstat-no" title="statement not covered" ></span>Math.abs(s)&gt;Math.abs(r)&amp;&amp;s&gt;0?this.moveDirection="left":Math.abs(s)&gt;Math.abs(r)&amp;&amp;s&lt;0?this.moveDirection="right":Math.abs(r)&gt;Math.abs(s)&amp;&amp;r&gt;0?this.moveDirection="up":Math.abs(r)&gt;Math.abs(s)&amp;&amp;r&lt;0&amp;&amp;(this.moveDirection="down")}<span class="cstat-no" title="statement not covered" ></span>i</span>.globals.lastClientPosition={x:a.clientX,y:a.clientY};v</span>ar n=<span class="cstat-no" title="statement not covered" >i.globals.minX,</span>o=<span class="cstat-no" title="statement not covered" >i.globals.maxX;<span class="cstat-no" title="statement not covered" ></span>i.config.xaxis.convertedCatToNumeric||a.panScrolled(n,o)}</span>},{key:"delayedPanScrolled",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals.minX,</span>i=<span class="cstat-no" title="statement not covered" >t.globals.maxX,</span>a=<span class="cstat-no" title="statement not covered" >(t.globals.maxX-t.globals.minX)/2;<span class="cstat-no" title="statement not covered" ></span>"left"===this.moveDirection?(e=t.globals.minX+a,i=t.globals.maxX+a):"right"===this.moveDirection&amp;&amp;(e=t.globals.minX-a,i=t.globals.maxX-a),e=Math.floor(e),i=Math.floor(i),this.updateScrolledChart({xaxis:{min:e,max:i}},e,i)}</span>},{key:"panScrolled",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this.xyRatios,</span>s=<span class="cstat-no" title="statement not covered" >g.clone(i.globals.initialConfig.yaxis);<span class="cstat-no" title="statement not covered" ></span>"left"===this.moveDirection?(t=i.globals.minX+i.globals.gridWidth/15*a.xRatio,e=i.globals.maxX+i.globals.gridWidth/15*a.xRatio):"right"===this.moveDirection&amp;&amp;(t=i.globals.minX-i.globals.gridWidth/15*a.xRatio,e=i.globals.maxX-i.globals.gridWidth/15*a.xRatio),(t&lt;i.globals.initialMinX||e&gt;i.globals.initialMaxX)&amp;&amp;(t=i.globals.minX,e=i.globals.maxX);v</span>ar r=<span class="cstat-no" title="statement not covered" >{min:t,max:e};<span class="cstat-no" title="statement not covered" ></span>i.config.chart.zoom.autoScaleYaxis&amp;&amp;(s=new j(this.ctx).autoScaleY(this.ctx,s,{xaxis:r}));v</span>ar n=<span class="cstat-no" title="statement not covered" >{xaxis:{min:t,max:e}};<span class="cstat-no" title="statement not covered" ></span>i.config.chart.group||(n.yaxis=s),this.updateScrolledChart(n,t,e)}</span>},{key:"updateScrolledChart",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.ctx.updateHelpers._updateOptions(t,!1,!1),"function"==typeof a.config.chart.events.scrolled&amp;&amp;a.config.chart.events.scrolled(this.ctx,{xaxis:{min:e,max:i}})}</span>}]),i}</span>(ht),</span>dt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.ttCtx=i,this.ctx=i.ctx}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getNearestValues",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.hoverArea,</span>i=<span class="cstat-no" title="statement not covered" >t.elGrid,</span>a=<span class="cstat-no" title="statement not covered" >t.clientX,</span>s=<span class="cstat-no" title="statement not covered" >t.clientY,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >r.globals.gridWidth,</span>o=<span class="cstat-no" title="statement not covered" >n/(r.globals.dataPoints-1),</span>l=<span class="cstat-no" title="statement not covered" >i.getBoundingClientRect(),</span>h=<span class="cstat-no" title="statement not covered" >this.hasBars();<span class="cstat-no" title="statement not covered" ></span>!r.globals.comboCharts&amp;&amp;!h||r.config.xaxis.convertedCatToNumeric||(o=n/r.globals.dataPoints);v</span>ar c=<span class="cstat-no" title="statement not covered" >a-l.left-r.globals.barPadForNumericAxis,</span>d=<span class="cstat-no" title="statement not covered" >s-l.top;<span class="cstat-no" title="statement not covered" ></span>c&lt;0||d&lt;0||c&gt;r.globals.gridWidth||d&gt;r.globals.gridHeight?(e.classList.remove("hovering-zoom"),e.classList.remove("hovering-pan")):r.globals.zoomEnabled?(e.classList.remove("hovering-pan"),e.classList.add("hovering-zoom")):r.globals.panEnabled&amp;&amp;(e.classList.remove("hovering-zoom"),e.classList.add("hovering-pan"));v</span>ar u=<span class="cstat-no" title="statement not covered" >Math.round(c/o);<span class="cstat-no" title="statement not covered" ></span>h&amp;&amp;!r.config.xaxis.convertedCatToNumeric&amp;&amp;(u=Math.ceil(c/o),u-=1);<span class="cstat-no" title="statement not covered" >f</span>or(var f,p=<span class="cstat-no" title="statement not covered" >null,</span>x=<span class="cstat-no" title="statement not covered" >null,</span>b=<span class="cstat-no" title="statement not covered" >[],</span>m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;r.globals.seriesXvalues.length;m++)<span class="cstat-no" title="statement not covered" >b.push([r.globals.seriesXvalues[m][0]-1e-6].concat(r.globals.seriesXvalues[m]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn b=b.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>))}</span>)),f=r.globals.seriesYvalues.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return g.isNumber(t)}</span>))}</span>)),r.globals.isXNumeric&amp;&amp;(p=(x=this.closestInMultiArray(c,d,b,f)).index,u=x.j,null!==p&amp;&amp;(b=r.globals.seriesXvalues[p],u=(x=this.closestInArray(c,b)).index)),r.globals.capturedSeriesIndex=null===p?-1:p,(!u||u&lt;1)&amp;&amp;(u=0),r.globals.capturedDataPointIndex=u,{capturedSeries:p,j:u,hoverX:c,hoverY:d}}</span>},{key:"closestInMultiArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>s.globals.series.length&gt;1?r=this.getFirstActiveXArray(i):n=0;v</span>ar l=<span class="cstat-no" title="statement not covered" >a[r][0],</span>h=<span class="cstat-no" title="statement not covered" >i[r][0],</span>c=<span class="cstat-no" title="statement not covered" >Math.abs(t-h),</span>d=<span class="cstat-no" title="statement not covered" >Math.abs(e-l),</span>g=<span class="cstat-no" title="statement not covered" >d+c;<span class="cstat-no" title="statement not covered" ></span>return a.map((<span class="fstat-no" title="function not covered" >fu</span>nction(s,r){<span class="cstat-no" title="statement not covered" >s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(s,l){var h=<span class="cstat-no" title="statement not covered" >Math.abs(e-a[r][l]),</span>u=<span class="cstat-no" title="statement not covered" >Math.abs(t-i[r][l]),</span>f=<span class="cstat-no" title="statement not covered" >u+h;<span class="cstat-no" title="statement not covered" ></span>f&lt;g&amp;&amp;(g=f,c=u,d=h,n=r,o=l)}</span>))}</span>)),{index:n,j:o}}</span>},{key:"getFirstActiveXArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >new m(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.length&gt;0?e:-1}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s++){var r=<span class="cstat-no" title="statement not covered" >i.getSeriesTotalByIndex(s);<span class="cstat-no" title="statement not covered" ></span>if(-1!==a[s]&amp;&amp;0!==r&amp;&amp;!i.seriesHaveSameValues(s)){<span class="cstat-no" title="statement not covered" >e=a[s];<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>},{key:"closestInArray",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >e[0],</span>a=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >Math.abs(t-i),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r++){var n=<span class="cstat-no" title="statement not covered" >Math.abs(t-e[r]);<span class="cstat-no" title="statement not covered" ></span>n&lt;s&amp;&amp;(s=n,a=r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{index:a}}</span>},{key:"isXoverlap",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >this.w.globals.seriesX.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0!==t[0]}</span>));<span class="cstat-no" title="statement not covered" ></span>if(i.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length-1;a++)<span class="cstat-no" title="statement not covered" >void 0!==i[a][t]&amp;&amp;void 0!==i[a+1][t]&amp;&amp;i[a][t]!==i[a+1][t]&amp;&amp;e.push("unEqual");<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn 0===e.length}</span>},{key:"isInitialSeriesSameLen",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >!0,</span>e=<span class="cstat-no" title="statement not covered" >this.w.globals.initialSeries,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length-1;i++)<span class="cstat-no" title="statement not covered" >if(e[i].data.length!==e[i+1].data.length){<span class="cstat-no" title="statement not covered" >t=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t}</span>},{key:"getBarsHeight",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return d(t).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t+e.getBBox().height}</span>),0)}</span>},{key:"getElMarkers",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers")}</span>},{key:"getAllMarkers",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");<span class="cstat-no" title="statement not covered" ></span>(t=d(t)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Number(e.getAttribute("data:realIndex"))&lt;Number(t.getAttribute("data:realIndex"))?0:-1}</span>));v</span>ar e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.push(t.querySelector(".apexcharts-marker"))}</span>)),e}</span>},{key:"hasMarkers",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.getElMarkers().length&gt;0}</span>},{key:"getElBars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series")}</span>},{key:"hasBars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.getElBars().length&gt;0}</span>},{key:"getHoverMarkerSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.config.markers.hover.size;<span class="cstat-no" title="statement not covered" ></span>return void 0===i&amp;&amp;(i=e.globals.markers.size[t]+e.config.markers.hover.sizeOffset),i}</span>},{key:"toggleAllTooltipSeriesGroups",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>0===i.allTooltipSeriesGroups.length&amp;&amp;(i.allTooltipSeriesGroups=e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >i.allTooltipSeriesGroups,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s++)<span class="cstat-no" title="statement not covered" >"enable"===t?(a[s].classList.add("apexcharts-active"),a[s].style.display=e.config.tooltip.items.display):(a[s].classList.remove("apexcharts-active"),a[s].style.display="none")}</span></span>}]),t}</span>(),</span>gt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.ctx=i.ctx,this.ttCtx=i,this.tooltipUtil=new dt(i)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawSeriesTexts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.shared,</span>i=<span class="cstat-no" title="statement not covered" >void 0===e||e,</span>a=<span class="cstat-no" title="statement not covered" >t.ttItems,</span>s=<span class="cstat-no" title="statement not covered" >t.i,</span>r=<span class="cstat-no" title="statement not covered" >void 0===s?0:s,</span>n=<span class="cstat-no" title="statement not covered" >t.j,</span>o=<span class="cstat-no" title="statement not covered" >void 0===n?null:n,</span>l=<span class="cstat-no" title="statement not covered" >t.y1,</span>h=<span class="cstat-no" title="statement not covered" >t.y2,</span>c=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>void 0!==c.config.tooltip.custom?this.handleCustomTooltip({i:r,j:o,y1:l,y2:h,w:c}):this.toggleActiveInactiveSeries(i);v</span>ar d=<span class="cstat-no" title="statement not covered" >this.getValuesToPrint({i:r,j:o});<span class="cstat-no" title="statement not covered" ></span>this.printLabels({i:r,j:o,values:d,ttItems:a,shared:i});v</span>ar g=<span class="cstat-no" title="statement not covered" >this.ttCtx.getElTooltip();<span class="cstat-no" title="statement not covered" ></span>this.ttCtx.tooltipRect.ttWidth=g.getBoundingClientRect().width,this.ttCtx.tooltipRect.ttHeight=g.getBoundingClientRect().height}</span>},{key:"printLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >t.i,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >t.values,</span>n=<span class="cstat-no" title="statement not covered" >t.ttItems,</span>o=<span class="cstat-no" title="statement not covered" >t.shared,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >r.xVal,</span>c=<span class="cstat-no" title="statement not covered" >r.zVal,</span>d=<span class="cstat-no" title="statement not covered" >r.xAxisTTVal,</span>g=<span class="cstat-no" title="statement not covered" >"",</span>u=<span class="cstat-no" title="statement not covered" >l.globals.colors[a];<span class="cstat-no" title="statement not covered" ></span>null!==s&amp;&amp;l.config.plotOptions.bar.distributed&amp;&amp;(u=l.globals.colors[s]);<span class="cstat-no" title="statement not covered" >f</span>or(var f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var f=<span class="cstat-no" title="statement not covered" >i.getFormatters(a);<span class="cstat-no" title="statement not covered" ></span>g=i.getSeriesName({fn:f.yLbTitleFormatter,index:a,seriesIndex:a,j:s});v</span>ar p=<span class="cstat-no" title="statement not covered" >l.config.tooltip.inverseOrder?r:t;<span class="cstat-no" title="statement not covered" ></span>if(l.globals.axisCharts){var x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return f.yLbFormatter(l.globals.series[t][s],{series:l.globals.series,seriesIndex:t,dataPointIndex:s,w:l})}</span>;<span class="cstat-no" title="statement not covered" ></span>o?(f=i.getFormatters(p),g=i.getSeriesName({fn:f.yLbTitleFormatter,index:p,seriesIndex:a,j:s}),u=l.globals.colors[p],e=x(p)):e=x(a)}<span class="cstat-no" title="statement not covered" ></span>n</span>ull===s&amp;&amp;(e=f.yLbFormatter(l.globals.series[a],l)),i.DOMHandling({i:a,t:p,j:s,ttItems:n,values:{val:e,xVal:h,xAxisTTVal:d,zVal:c},seriesName:g,shared:o,pColor:u})}</span>,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >l.globals.series.length-1;</span>p&lt;l.globals.series.length;p++,x--)<span class="cstat-no" title="statement not covered" >f(p,x)}</span></span>},{key:"getFormatters",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals.yLabelFormatters[t];<span class="cstat-no" title="statement not covered" ></span>return void 0!==i.globals.ttVal?Array.isArray(i.globals.ttVal)?(a=i.globals.ttVal[t]&amp;&amp;i.globals.ttVal[t].formatter,e=i.globals.ttVal[t]&amp;&amp;i.globals.ttVal[t].title&amp;&amp;i.globals.ttVal[t].title.formatter):(a=i.globals.ttVal.formatter,"function"==typeof i.globals.ttVal.title.formatter&amp;&amp;(e=i.globals.ttVal.title.formatter)):e=i.config.tooltip.y.title.formatter,"function"!=typeof a&amp;&amp;(a=i.globals.yLabelFormatters[0]?i.globals.yLabelFormatters[0]:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>),"function"!=typeof e&amp;&amp;(e=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>),{yLbFormatter:a,yLbTitleFormatter:e}}</span>},{key:"getSeriesName",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.fn,</span>i=<span class="cstat-no" title="statement not covered" >t.index,</span>a=<span class="cstat-no" title="statement not covered" >t.seriesIndex,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return e(String(r.globals.seriesNames[i]),{series:r.globals.series,seriesIndex:a,dataPointIndex:s,w:r})}</span>},{key:"DOMHandling",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.i,</span>i=<span class="cstat-no" title="statement not covered" >t.t,</span>a=(<span class="cstat-no" title="statement not covered" >t.j,t.ttItems)</span>,s=<span class="cstat-no" title="statement not covered" >t.values,</span>r=<span class="cstat-no" title="statement not covered" >t.seriesName,</span>n=<span class="cstat-no" title="statement not covered" >t.shared,</span>o=<span class="cstat-no" title="statement not covered" >t.pColor,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>c=<span class="cstat-no" title="statement not covered" >s.val,</span>d=<span class="cstat-no" title="statement not covered" >s.xVal,</span>g=<span class="cstat-no" title="statement not covered" >s.xAxisTTVal,</span>u=<span class="cstat-no" title="statement not covered" >s.zVal,</span>f=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>f=a[i].children,l.config.tooltip.fillSeriesColor&amp;&amp;(a[i].style.backgroundColor=o,f[0].style.display="none"),h.showTooltipTitle&amp;&amp;(null===h.tooltipTitle&amp;&amp;(h.tooltipTitle=l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),h.tooltipTitle.innerHTML=d),h.blxaxisTooltip&amp;&amp;(h.xaxisTooltipText.innerHTML=""!==g?g:d);v</span>ar p=<span class="cstat-no" title="statement not covered" >a[i].querySelector(".apexcharts-tooltip-text-label");<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(p.innerHTML=r?r+": ":"");v</span>ar x=<span class="cstat-no" title="statement not covered" >a[i].querySelector(".apexcharts-tooltip-text-value");<span class="cstat-no" title="statement not covered" ></span>(x&amp;&amp;(x.innerHTML=void 0!==c?c:""),f[0]&amp;&amp;f[0].classList.contains("apexcharts-tooltip-marker")&amp;&amp;(l.config.tooltip.marker.fillColors&amp;&amp;Array.isArray(l.config.tooltip.marker.fillColors)&amp;&amp;(o=l.config.tooltip.marker.fillColors[e]),f[0].style.backgroundColor=o),l.config.tooltip.marker.show||(f[0].style.display="none"),null!==u)&amp;&amp;(a[i].querySelector(".apexcharts-tooltip-text-z-label").innerHTML=l.config.tooltip.z.title,a[i].querySelector(".apexcharts-tooltip-text-z-value").innerHTML=void 0!==u?u:"");<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;f[0]&amp;&amp;(null==c||l.globals.collapsedSeriesIndices.indexOf(i)&gt;-1?f[0].parentNode.style.display="none":f[0].parentNode.style.display=l.config.tooltip.items.display)}</span>},{key:"toggleActiveInactiveSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");e</span>lse{<span class="cstat-no" title="statement not covered" >this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");v</span>ar i=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(i.classList.add("apexcharts-active"),i.style.display=e.config.tooltip.items.display)}</span>}</span>},{key:"getValuesToPrint",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.i,</span>i=<span class="cstat-no" title="statement not covered" >t.j,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >this.ctx.series.filteredSeriesX(),</span>r=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >"",</span>o=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >null,</span>h=<span class="cstat-no" title="statement not covered" >{series:a.globals.series,seriesIndex:e,dataPointIndex:i,w:a},</span>c=<span class="cstat-no" title="statement not covered" >a.globals.ttZFormatter;<span class="cstat-no" title="statement not covered" ></span>null===i?l=a.globals.series[e]:a.globals.isXNumeric?(r=s[e][i],0===s[e].length&amp;&amp;(r=s[this.tooltipUtil.getFirstActiveXArray(s)][i])):r=void 0!==a.globals.labels[i]?a.globals.labels[i]:"";v</span>ar d=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>a.globals.isXNumeric&amp;&amp;"datetime"===a.config.xaxis.type?r=new W(this.ctx).xLabelFormat(a.globals.ttKeyFormatter,d,d):a.globals.isBarHorizontal||(r=a.globals.xLabelFormatter(d,h));<span class="cstat-no" title="statement not covered" >r</span>eturn void 0!==a.config.tooltip.x.formatter&amp;&amp;(r=a.globals.ttKeyFormatter(d,h)),a.globals.seriesZ.length&gt;0&amp;&amp;a.globals.seriesZ[0].length&gt;0&amp;&amp;(o=c(a.globals.seriesZ[e][i],a)),n="function"==typeof a.config.xaxis.tooltip.formatter?a.globals.xaxisTooltipFormatter(d,h):r,{val:Array.isArray(l)?l.join(" "):l,xVal:Array.isArray(r)?r.join(" "):r,xAxisTTVal:Array.isArray(n)?n.join(" "):n,zVal:o}}</span>},{key:"handleCustomTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.i,</span>i=<span class="cstat-no" title="statement not covered" >t.j,</span>a=<span class="cstat-no" title="statement not covered" >t.y1,</span>s=<span class="cstat-no" title="statement not covered" >t.y2,</span>r=<span class="cstat-no" title="statement not covered" >t.w,</span>n=<span class="cstat-no" title="statement not covered" >this.ttCtx.getElTooltip(),</span>o=<span class="cstat-no" title="statement not covered" >r.config.tooltip.custom;<span class="cstat-no" title="statement not covered" ></span>Array.isArray(o)&amp;&amp;o[e]&amp;&amp;(o=o[e]),n.innerHTML=o({ctx:this.ctx,series:r.globals.series,seriesIndex:e,dataPointIndex:i,y1:a,y2:s,w:r})}</span>}]),t}</span>(),</span>ut=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ttCtx=i,this.ctx=i.ctx,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"moveXCrosshairs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:null,</span>i=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >i.getElXCrosshairs(),</span>r=<span class="cstat-no" title="statement not covered" >t-i.xcrosshairsWidth/2,</span>n=<span class="cstat-no" title="statement not covered" >a.globals.labels.slice().length;<span class="cstat-no" title="statement not covered" ></span>if(null!==e&amp;&amp;(r=a.globals.gridWidth/n*e),null!==s&amp;&amp;(s.setAttribute("x",r),s.setAttribute("x1",r),s.setAttribute("x2",r),s.setAttribute("y2",a.globals.gridHeight),s.classList.add("apexcharts-active")),r&lt;0&amp;&amp;(r=0),r&gt;a.globals.gridWidth&amp;&amp;(r=a.globals.gridWidth),i.blxaxisTooltip){var o=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>"tickWidth"!==a.config.xaxis.crosshairs.width&amp;&amp;"barWidth"!==a.config.xaxis.crosshairs.width||(o=r+i.xcrosshairsWidth/2),this.moveXAxisTooltip(o)}</span>}</span>},{key:"moveYCrosshairs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>null!==e.ycrosshairs&amp;&amp;p.setAttrs(e.ycrosshairs,{y1:t,y2:t}),null!==e.ycrosshairsHidden&amp;&amp;p.setAttrs(e.ycrosshairsHidden,{y1:t,y2:t})}</span>},{key:"moveXAxisTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>if(null!==i.xaxisTooltip){<span class="cstat-no" title="statement not covered" >i.xaxisTooltip.classList.add("apexcharts-active");v</span>ar a=<span class="cstat-no" title="statement not covered" >i.xaxisOffY+e.config.xaxis.tooltip.offsetY+e.globals.translateY+1+e.config.xaxis.offsetY;<span class="cstat-no" title="statement not covered" ></span>if(t-=i.xaxisTooltip.getBoundingClientRect().width/2,!isNaN(t)){<span class="cstat-no" title="statement not covered" >t+=e.globals.translateX;v</span>ar s;<span class="cstat-no" title="statement not covered" >s=new p(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML),i.xaxisTooltipText.style.minWidth=s.width+"px",i.xaxisTooltip.style.left=t+"px",i.xaxisTooltip.style.top=a+"px"}</span>}</span>}</span>},{key:"moveYAxisTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>null===i.yaxisTTEls&amp;&amp;(i.yaxisTTEls=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));v</span>ar a=<span class="cstat-no" title="statement not covered" >parseInt(i.ycrosshairsHidden.getAttribute("y1"),10),</span>s=<span class="cstat-no" title="statement not covered" >e.globals.translateY+a,</span>r=<span class="cstat-no" title="statement not covered" >i.yaxisTTEls[t].getBoundingClientRect().height,</span>n=<span class="cstat-no" title="statement not covered" >e.globals.translateYAxisX[t]-2;<span class="cstat-no" title="statement not covered" ></span>e.config.yaxis[t].opposite&amp;&amp;(n-=26),s-=r/2,-1===e.globals.ignoreYAxisIndexes.indexOf(t)?(i.yaxisTTEls[t].classList.add("apexcharts-active"),i.yaxisTTEls[t].style.top=s+"px",i.yaxisTTEls[t].style.left=n+e.config.yaxis[t].tooltip.offsetX+"px"):i.yaxisTTEls[t].classList.remove("apexcharts-active")}</span>},{key:"moveTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:null,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>r=<span class="cstat-no" title="statement not covered" >s.getElTooltip(),</span>n=<span class="cstat-no" title="statement not covered" >s.tooltipRect,</span>o=<span class="cstat-no" title="statement not covered" >null!==i?parseFloat(i):1,</span>l=<span class="cstat-no" title="statement not covered" >parseFloat(t)+o+5,</span>h=<span class="cstat-no" title="statement not covered" >parseFloat(e)+o/2;<span class="cstat-no" title="statement not covered" ></span>if(l&gt;a.globals.gridWidth/2&amp;&amp;(l=l-n.ttWidth-o-15),l&gt;a.globals.gridWidth-n.ttWidth-10&amp;&amp;(l=a.globals.gridWidth-n.ttWidth),l&lt;-20&amp;&amp;(l=-20),a.config.tooltip.followCursor){var c=<span class="cstat-no" title="statement not covered" >s.getElGrid(),</span>d=<span class="cstat-no" title="statement not covered" >c.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>h=s.e.clientY+a.globals.translateY-d.top-n.ttHeight/2}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!a.config.tooltip.followCursor){var g=<span class="cstat-no" title="statement not covered" >this.positionChecks(n,l,h);<span class="cstat-no" title="statement not covered" ></span>l=g.x,h=g.y}<span class="cstat-no" title="statement not covered" ></span>i</span>sNaN(l)||(l+=a.globals.translateX,r.style.left=l+"px",r.style.top=h+"px")}</span>},{key:"positionChecks",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return t.ttHeight/2+i&gt;a.globals.gridHeight&amp;&amp;(i=a.globals.gridHeight-t.ttHeight+a.globals.translateY),i&lt;0&amp;&amp;(i=0),{x:e,y:i}}</span>},{key:"moveMarkers",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>if(i.globals.markers.size[t]&gt;0)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t,"'] .apexcharts-marker")),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;s.length;r++)<span class="cstat-no" title="statement not covered" >parseInt(s[r].getAttribute("rel"),10)===e&amp;&amp;(a.marker.resetPointsSize(),a.marker.enlargeCurrentPoint(e,s[r]));e</span></span>lse <span class="cstat-no" title="statement not covered" >a.marker.resetPointsSize(),this.moveDynamicPointOnHover(e,t)}</span></span>},{key:"moveDynamicPointOnHover",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i,a,s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>n=<span class="cstat-no" title="statement not covered" >s.globals.pointsArray,</span>o=<span class="cstat-no" title="statement not covered" >r.tooltipUtil.getHoverMarkerSize(e),</span>l=<span class="cstat-no" title="statement not covered" >s.config.series[e].type;<span class="cstat-no" title="statement not covered" ></span>if(!l||"column"!==l&amp;&amp;"candlestick"!==l){<span class="cstat-no" title="statement not covered" >i=n[e][t][0],a=n[e][t][1]?n[e][t][1]:0;v</span>ar h=<span class="cstat-no" title="statement not covered" >s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e,"'] .apexcharts-series-markers circle"));<span class="cstat-no" title="statement not covered" ></span>h&amp;&amp;a&lt;s.globals.gridHeight&amp;&amp;a&gt;0&amp;&amp;(h.setAttribute("r",o),h.setAttribute("cx",i),h.setAttribute("cy",a)),this.moveXCrosshairs(i),r.fixedTooltip||this.moveTooltip(i,a,o)}</span>}</span>},{key:"moveDynamicPointsOnHover",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>a=<span class="cstat-no" title="statement not covered" >i.w,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >a.globals.pointsArray;<span class="cstat-no" title="statement not covered" ></span>e=new M(this.ctx).getActiveConfigSeriesIndex(!0);v</span>ar o=<span class="cstat-no" title="statement not covered" >i.tooltipUtil.getHoverMarkerSize(e);<span class="cstat-no" title="statement not covered" ></span>n[e]&amp;&amp;(s=n[e][t][0],r=n[e][t][1]);v</span>ar l=<span class="cstat-no" title="statement not covered" >i.tooltipUtil.getAllMarkers();<span class="cstat-no" title="statement not covered" ></span>if(null!==l)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;a.globals.series.length;h++){var c=<span class="cstat-no" title="statement not covered" >n[h];<span class="cstat-no" title="statement not covered" ></span>if(a.globals.comboCharts&amp;&amp;void 0===c&amp;&amp;l.splice(h,0,null),c&amp;&amp;c.length){var d=<span class="cstat-no" title="statement not covered" >n[h][t][1];<span class="cstat-no" title="statement not covered" ></span>l[h].setAttribute("cx",s),null!==d&amp;&amp;!isNaN(d)&amp;&amp;d&lt;a.globals.gridHeight&amp;&amp;d&gt;0?(l[h]&amp;&amp;l[h].setAttribute("r",o),l[h]&amp;&amp;l[h].setAttribute("cy",d)):l[h]&amp;&amp;l[h].setAttribute("r",0)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(this.moveXCrosshairs(s),!i.fixedTooltip){var g=<span class="cstat-no" title="statement not covered" >r||a.globals.gridHeight;<span class="cstat-no" title="statement not covered" ></span>this.moveTooltip(s,g,o)}</span>}</span>},{key:"moveStickyTooltipOverBars",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>s=<span class="cstat-no" title="statement not covered" >i.globals.columnSeries?i.globals.columnSeries.length:i.globals.series.length,</span>r=<span class="cstat-no" title="statement not covered" >s&gt;=2&amp;&amp;s%2==0?Math.floor(s/2):Math.floor(s/2)+1,</span>n=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r,"'] path[j='").concat(t,"'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"']")),</span>o=<span class="cstat-no" title="statement not covered" >n?parseFloat(n.getAttribute("cx")):0,</span>l=<span class="cstat-no" title="statement not covered" >n?parseFloat(n.getAttribute("barWidth")):0;<span class="cstat-no" title="statement not covered" ></span>i.globals.isXNumeric?o-=s%2!=0?l/2:0:(o=a.xAxisTicksPositions[t-1]+a.dataPointsDividedWidth/2,isNaN(o)&amp;&amp;(o=a.xAxisTicksPositions[t]-a.dataPointsDividedWidth/2));v</span>ar h=<span class="cstat-no" title="statement not covered" >a.getElGrid().getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if(e=a.e.clientY-h.top-a.tooltipRect.ttHeight/2,this.moveXCrosshairs(o),!a.fixedTooltip){var c=<span class="cstat-no" title="statement not covered" >e||i.globals.gridHeight;<span class="cstat-no" title="statement not covered" ></span>this.moveTooltip(o,c)}</span>}</span>}]),t}</span>(),</span>ft=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.ttCtx=i,this.ctx=i.ctx,this.tooltipPosition=new ut(i)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawDynamicPoints",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>i=<span class="cstat-no" title="statement not covered" >new P(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");<span class="cstat-no" title="statement not covered" ></span>(a=d(a)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Number(e.getAttribute("data:realIndex"))&lt;Number(t.getAttribute("data:realIndex"))?0:-1}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s++){var r=<span class="cstat-no" title="statement not covered" >a[s].querySelector(".apexcharts-series-markers-wrap");<span class="cstat-no" title="statement not covered" ></span>if(null!==r){var n=<span class="cstat-no" title="statement not covered" >void 0,</span>o=<span class="cstat-no" title="statement not covered" >"apexcharts-marker w".concat((Math.random()+1).toString(36).substring(4));<span class="cstat-no" title="statement not covered" ></span>"line"!==t.config.chart.type&amp;&amp;"area"!==t.config.chart.type||t.globals.comboCharts||t.config.tooltip.intersect||(o+=" no-pointer-events");v</span>ar l=<span class="cstat-no" title="statement not covered" >i.getMarkerConfig(o,s);<span class="cstat-no" title="statement not covered" ></span>(n=e.drawMarker(0,0,l)).node.setAttribute("default-marker-size",0);v</span>ar h=<span class="cstat-no" title="statement not covered" >document.createElementNS(t.globals.SVGNS,"g");<span class="cstat-no" title="statement not covered" ></span>h.classList.add("apexcharts-series-markers"),h.appendChild(n.node),r.appendChild(h)}</span>}</span>}</span>},{key:"enlargeCurrentPoint",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:null,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:null,</span>s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>"bubble"!==s.config.chart.type&amp;&amp;this.newPointSize(t,e);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.getAttribute("cx"),</span>n=<span class="cstat-no" title="statement not covered" >e.getAttribute("cy");<span class="cstat-no" title="statement not covered" ></span>if(null!==i&amp;&amp;null!==a&amp;&amp;(r=i,n=a),this.tooltipPosition.moveXCrosshairs(r),!this.fixedTooltip){<span class="cstat-no" title="statement not covered" >if("radar"===s.config.chart.type){var o=<span class="cstat-no" title="statement not covered" >this.ttCtx.getElGrid(),</span>l=<span class="cstat-no" title="statement not covered" >o.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>r=this.ttCtx.e.clientX-l.left}<span class="cstat-no" title="statement not covered" ></span>t</span>his.tooltipPosition.moveTooltip(r,n,s.config.markers.hover.size)}</span>}</span>},{key:"enlargePoints",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>a=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"),</span>r=<span class="cstat-no" title="statement not covered" >e.config.markers.hover.size,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){var o=<span class="cstat-no" title="statement not covered" >s[n].getAttribute("rel"),</span>l=<span class="cstat-no" title="statement not covered" >s[n].getAttribute("index");<span class="cstat-no" title="statement not covered" ></span>if(void 0===r&amp;&amp;(r=e.globals.markers.size[l]+e.config.markers.hover.sizeOffset),a===parseInt(o,10)){<span class="cstat-no" title="statement not covered" >this.newPointSize(a,s[n]);v</span>ar h=<span class="cstat-no" title="statement not covered" >s[n].getAttribute("cx"),</span>c=<span class="cstat-no" title="statement not covered" >s[n].getAttribute("cy");<span class="cstat-no" title="statement not covered" ></span>this.tooltipPosition.moveXCrosshairs(h),i.fixedTooltip||this.tooltipPosition.moveTooltip(h,c,r)}</span>else <span class="cstat-no" title="statement not covered" >this.oldPointSize(s[n])}</span></span>}</span>},{key:"newPointSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.config.markers.hover.size,</span>s=<span class="cstat-no" title="statement not covered" >0===t?e.parentNode.firstChild:e.parentNode.lastChild;<span class="cstat-no" title="statement not covered" ></span>if("0"!==s.getAttribute("default-marker-size")){var r=<span class="cstat-no" title="statement not covered" >parseInt(s.getAttribute("index"),10);<span class="cstat-no" title="statement not covered" ></span>void 0===a&amp;&amp;(a=i.globals.markers.size[r]+i.config.markers.hover.sizeOffset),s.setAttribute("r",a)}</span>}</span>},{key:"oldPointSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >parseFloat(t.getAttribute("default-marker-size"));<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("r",e)}</span>},{key:"resetPointsSize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"),</span>e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++){var i=<span class="cstat-no" title="statement not covered" >parseFloat(t[e].getAttribute("default-marker-size"));<span class="cstat-no" title="statement not covered" ></span>g.isNumber(i)?t[e].setAttribute("r",i):t[e].setAttribute("r",0)}</span>}</span>}]),t}</span>(),</span>pt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.ttCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getAttr",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return parseFloat(t.target.getAttribute(e))}</span>},{key:"handleHeatTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.e,</span>i=<span class="cstat-no" title="statement not covered" >t.opt,</span>a=<span class="cstat-no" title="statement not covered" >t.x,</span>s=<span class="cstat-no" title="statement not covered" >t.y,</span>r=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>n=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(e.target.classList.contains("apexcharts-heatmap-rect")){var o=<span class="cstat-no" title="statement not covered" >this.getAttr(e,"i"),</span>l=<span class="cstat-no" title="statement not covered" >this.getAttr(e,"j"),</span>h=<span class="cstat-no" title="statement not covered" >this.getAttr(e,"cx"),</span>c=<span class="cstat-no" title="statement not covered" >this.getAttr(e,"cy"),</span>d=<span class="cstat-no" title="statement not covered" >this.getAttr(e,"width"),</span>g=<span class="cstat-no" title="statement not covered" >this.getAttr(e,"height");<span class="cstat-no" title="statement not covered" ></span>if(r.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:o,j:l,shared:!1}),n.globals.capturedSeriesIndex=o,n.globals.capturedDataPointIndex=l,a=h+r.tooltipRect.ttWidth/2+d,s=c+r.tooltipRect.ttHeight/2-g/2,r.tooltipPosition.moveXCrosshairs(h+d/2),a&gt;n.globals.gridWidth/2&amp;&amp;(a=h-r.tooltipRect.ttWidth/2+d),r.w.config.tooltip.followCursor){var u=<span class="cstat-no" title="statement not covered" >r.getElGrid().getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>s=r.e.clientY-u.top+n.globals.translateY/2-10}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:a,y:s}}</span>},{key:"handleMarkerTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i,a=<span class="cstat-no" title="statement not covered" >t.e,</span>s=<span class="cstat-no" title="statement not covered" >t.opt,</span>r=<span class="cstat-no" title="statement not covered" >t.x,</span>n=<span class="cstat-no" title="statement not covered" >t.y,</span>o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>if(a.target.classList.contains("apexcharts-marker")){var h=<span class="cstat-no" title="statement not covered" >parseInt(s.paths.getAttribute("cx"),10),</span>c=<span class="cstat-no" title="statement not covered" >parseInt(s.paths.getAttribute("cy"),10),</span>d=<span class="cstat-no" title="statement not covered" >parseFloat(s.paths.getAttribute("val"));<span class="cstat-no" title="statement not covered" ></span>if(i=parseInt(s.paths.getAttribute("rel"),10),e=parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"),10)-1,l.intersect){var u=<span class="cstat-no" title="statement not covered" >g.findAncestor(s.paths,"apexcharts-series");<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(e=parseInt(u.getAttribute("data:realIndex"),10))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.tooltipLabels.drawSeriesTexts({ttItems:s.ttItems,i:e,j:i,shared:!l.showOnIntersect&amp;&amp;o.config.tooltip.shared}),"mouseup"===a.type&amp;&amp;l.markerClick(a,e,i),o.globals.capturedSeriesIndex=e,o.globals.capturedDataPointIndex=i,r=h,n=c+o.globals.translateY-1.4*l.tooltipRect.ttHeight,l.w.config.tooltip.followCursor){var f=<span class="cstat-no" title="statement not covered" >l.getElGrid().getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>n=l.e.clientY+o.globals.translateY-f.top}<span class="cstat-no" title="statement not covered" ></span>d</span>&lt;0&amp;&amp;(n=c),l.marker.enlargeCurrentPoint(i,s.paths,r,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:r,y:n}}</span>},{key:"handleBarTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i,a=<span class="cstat-no" title="statement not covered" >t.e,</span>s=<span class="cstat-no" title="statement not covered" >t.opt,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>o=<span class="cstat-no" title="statement not covered" >n.getElTooltip(),</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >this.getBarTooltipXY({e:a,opt:s});<span class="cstat-no" title="statement not covered" ></span>e=d.i;v</span>ar g=<span class="cstat-no" title="statement not covered" >d.barHeight,</span>u=<span class="cstat-no" title="statement not covered" >d.j;<span class="cstat-no" title="statement not covered" ></span>if(r.globals.capturedSeriesIndex=e,r.globals.capturedDataPointIndex=u,r.globals.isBarHorizontal&amp;&amp;n.tooltipUtil.hasBars()||!r.config.tooltip.shared?(h=d.x,c=d.y,i=Array.isArray(r.config.stroke.width)?r.config.stroke.width[e]:r.config.stroke.width,l=h):r.globals.comboCharts||r.config.tooltip.shared||(l/=2),isNaN(c)?c=r.globals.svgHeight-n.tooltipRect.ttHeight:c&lt;0&amp;&amp;(c=0),h+n.tooltipRect.ttWidth&gt;r.globals.gridWidth?h-=n.tooltipRect.ttWidth:h&lt;0&amp;&amp;(h=0),n.w.config.tooltip.followCursor){var f=<span class="cstat-no" title="statement not covered" >n.getElGrid().getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>c=n.e.clientY-f.top}<span class="cstat-no" title="statement not covered" ></span>i</span>f(null===n.tooltip&amp;&amp;(n.tooltip=r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),r.config.tooltip.shared||(r.globals.comboBarCount&gt;0?n.tooltipPosition.moveXCrosshairs(l+i/2):n.tooltipPosition.moveXCrosshairs(l)),!n.fixedTooltip&amp;&amp;(!r.config.tooltip.shared||r.globals.isBarHorizontal&amp;&amp;n.tooltipUtil.hasBars())){var p=<span class="cstat-no" title="statement not covered" >r.globals.isMultipleYAxis?r.config.yaxis[x]&amp;&amp;r.config.yaxis[x].reversed:r.config.yaxis[0].reversed;<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(h-=n.tooltipRect.ttWidth)&lt;0&amp;&amp;(h=0),o.style.left=h+r.globals.translateX+"px";v</span>ar x=<span class="cstat-no" title="statement not covered" >parseInt(s.paths.parentNode.getAttribute("data:realIndex"),10);<span class="cstat-no" title="statement not covered" ></span>!p||r.globals.isBarHorizontal&amp;&amp;n.tooltipUtil.hasBars()||(c=c+g-2*(r.globals.series[e][u]&lt;0?g:0)),n.tooltipRect.ttHeight+c&gt;r.globals.gridHeight?(c=r.globals.gridHeight-n.tooltipRect.ttHeight+r.globals.translateY,o.style.top=c+"px"):o.style.top=c+r.globals.translateY-n.tooltipRect.ttHeight/2+"px"}</span>}</span>},{key:"getBarTooltipXY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.e,</span>i=<span class="cstat-no" title="statement not covered" >t.opt,</span>a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >null,</span>r=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >e.target.classList;<span class="cstat-no" title="statement not covered" ></span>if(d.contains("apexcharts-bar-area")||d.contains("apexcharts-candlestick-area")||d.contains("apexcharts-rangebar-area")){var g=<span class="cstat-no" title="statement not covered" >e.target,</span>u=<span class="cstat-no" title="statement not covered" >g.getBoundingClientRect(),</span>f=<span class="cstat-no" title="statement not covered" >i.elGrid.getBoundingClientRect(),</span>p=<span class="cstat-no" title="statement not covered" >u.height;<span class="cstat-no" title="statement not covered" ></span>c=u.height;v</span>ar x=<span class="cstat-no" title="statement not covered" >u.width,</span>b=<span class="cstat-no" title="statement not covered" >parseInt(g.getAttribute("cx"),10),</span>m=<span class="cstat-no" title="statement not covered" >parseInt(g.getAttribute("cy"),10);<span class="cstat-no" title="statement not covered" ></span>h=parseFloat(g.getAttribute("barWidth"));v</span>ar v=<span class="cstat-no" title="statement not covered" >"touchmove"===e.type?e.touches[0].clientX:e.clientX;<span class="cstat-no" title="statement not covered" ></span>s=parseInt(g.getAttribute("j"),10),n=parseInt(g.parentNode.getAttribute("rel"),10)-1;v</span>ar y=<span class="cstat-no" title="statement not covered" >g.getAttribute("data-range-y1"),</span>w=<span class="cstat-no" title="statement not covered" >g.getAttribute("data-range-y2");<span class="cstat-no" title="statement not covered" ></span>a.globals.comboCharts&amp;&amp;(n=parseInt(g.parentNode.getAttribute("data:realIndex"),10)),r.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:n,j:s,y1:y?parseInt(y,10):null,y2:w?parseInt(w,10):null,shared:!r.showOnIntersect&amp;&amp;a.config.tooltip.shared}),a.config.tooltip.followCursor?a.globals.isBarHorizontal?(o=v-f.left+15,l=m-r.dataPointsDividedHeight+p/2-r.tooltipRect.ttHeight/2):(o=a.globals.isXNumeric?b-x/2:b-r.dataPointsDividedWidth+x/2,l=e.clientY-f.top-r.tooltipRect.ttHeight/2-15):a.globals.isBarHorizontal?((o=b)&lt;r.xyRatios.baseLineInvertedY&amp;&amp;(o=b-r.tooltipRect.ttWidth),l=m-r.dataPointsDividedHeight+p/2-r.tooltipRect.ttHeight/2):(o=a.globals.isXNumeric?b-x/2:b-r.dataPointsDividedWidth+x/2,l=m)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:o,y:l,barHeight:c,barWidth:h,i:n,j:s}}</span>}]),t}</span>(),</span>xt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.ttCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawXaxisTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>i=<span class="cstat-no" title="statement not covered" >"bottom"===t.config.xaxis.position;<span class="cstat-no" title="statement not covered" ></span>e.xaxisOffY=i?t.globals.gridHeight+1:-t.globals.xAxisHeight-t.config.xaxis.axisTicks.height+3;v</span>ar a=<span class="cstat-no" title="statement not covered" >i?"apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom":"apexcharts-xaxistooltip apexcharts-xaxistooltip-top",</span>s=<span class="cstat-no" title="statement not covered" >t.globals.dom.elWrap;<span class="cstat-no" title="statement not covered" ></span>e.blxaxisTooltip&amp;&amp;(null===t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip")&amp;&amp;(e.xaxisTooltip=document.createElement("div"),e.xaxisTooltip.setAttribute("class",a+" apexcharts-theme-"+t.config.tooltip.theme),s.appendChild(e.xaxisTooltip),e.xaxisTooltipText=document.createElement("div"),e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),e.xaxisTooltipText.style.fontFamily=t.config.xaxis.tooltip.style.fontFamily||t.config.chart.fontFamily,e.xaxisTooltipText.style.fontSize=t.config.xaxis.tooltip.style.fontSize,e.xaxisTooltip.appendChild(e.xaxisTooltipText)))}</span>},{key:"drawYaxisTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){var a=<span class="cstat-no" title="statement not covered" >t.config.yaxis[i].opposite||t.config.yaxis[i].crosshairs.opposite;<span class="cstat-no" title="statement not covered" ></span>e.yaxisOffX=a?t.globals.gridWidth+1:1;v</span>ar s=<span class="cstat-no" title="statement not covered" >"apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i,a?" apexcharts-yaxistooltip-right":" apexcharts-yaxistooltip-left");<span class="cstat-no" title="statement not covered" ></span>t.globals.yAxisSameScaleIndices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >a===i&amp;&amp;(s+=t.config.yaxis[a].show?" ":" apexcharts-yaxistooltip-hidden")}</span>))}</span>));v</span>ar r=<span class="cstat-no" title="statement not covered" >t.globals.dom.elWrap;<span class="cstat-no" title="statement not covered" ></span>null===t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i))&amp;&amp;(e.yaxisTooltip=document.createElement("div"),e.yaxisTooltip.setAttribute("class",s+" apexcharts-theme-"+t.config.tooltip.theme),r.appendChild(e.yaxisTooltip),0===i&amp;&amp;(e.yaxisTooltipText=[]),e.yaxisTooltipText[i]=document.createElement("div"),e.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"),e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]))}</span>,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.config.yaxis.length;a++)<span class="cstat-no" title="statement not covered" >i(a)}</span></span>},{key:"setXCrosshairWidth",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>i=<span class="cstat-no" title="statement not covered" >e.getElXCrosshairs();<span class="cstat-no" title="statement not covered" ></span>if(e.xcrosshairsWidth=parseInt(t.config.xaxis.crosshairs.width,10),t.globals.comboCharts){var a=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");<span class="cstat-no" title="statement not covered" ></span>if(null!==a&amp;&amp;"barWidth"===t.config.xaxis.crosshairs.width){var s=<span class="cstat-no" title="statement not covered" >parseFloat(a.getAttribute("barWidth"));<span class="cstat-no" title="statement not covered" ></span>e.xcrosshairsWidth=s}</span>else <span class="cstat-no" title="statement not covered" >if("tickWidth"===t.config.xaxis.crosshairs.width){var r=<span class="cstat-no" title="statement not covered" >t.globals.labels.length;<span class="cstat-no" title="statement not covered" ></span>e.xcrosshairsWidth=t.globals.gridWidth/r}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >if("tickWidth"===t.config.xaxis.crosshairs.width){var n=<span class="cstat-no" title="statement not covered" >t.globals.labels.length;<span class="cstat-no" title="statement not covered" ></span>e.xcrosshairsWidth=t.globals.gridWidth/n}</span>else <span class="cstat-no" title="statement not covered" >if("barWidth"===t.config.xaxis.crosshairs.width){var o=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");<span class="cstat-no" title="statement not covered" ></span>if(null!==o){var l=<span class="cstat-no" title="statement not covered" >parseFloat(o.getAttribute("barWidth"));<span class="cstat-no" title="statement not covered" ></span>e.xcrosshairsWidth=l}</span>else <span class="cstat-no" title="statement not covered" >e.xcrosshairsWidth=1}<span class="cstat-no" title="statement not covered" ></span></span>t</span></span></span>.globals.isBarHorizontal&amp;&amp;(e.xcrosshairsWidth=0),null!==i&amp;&amp;e.xcrosshairsWidth&gt;0&amp;&amp;i.setAttribute("width",e.xcrosshairsWidth)}</span>},{key:"handleYCrosshair",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.ttCtx;<span class="cstat-no" title="statement not covered" ></span>e.ycrosshairs=t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"),e.ycrosshairsHidden=t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")}</span>},{key:"drawYaxisTooltipText",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.ttCtx,</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >s.globals.yLabelFormatters[t];<span class="cstat-no" title="statement not covered" ></span>if(a.yaxisTooltips[t]){var n=<span class="cstat-no" title="statement not covered" >a.getElGrid().getBoundingClientRect(),</span>o=<span class="cstat-no" title="statement not covered" >(e-n.top)*i.yRatio[t],</span>l=<span class="cstat-no" title="statement not covered" >s.globals.maxYArr[t]-s.globals.minYArr[t],</span>h=<span class="cstat-no" title="statement not covered" >s.globals.minYArr[t]+(l-o);<span class="cstat-no" title="statement not covered" ></span>a.tooltipPosition.moveYCrosshairs(e-n.top),a.yaxisTooltipText[t].innerHTML=r(h),a.tooltipPosition.moveYAxisTooltip(t)}</span>}</span>}]),t}</span>(),</span>bt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.tConfig=a.config.tooltip,this.tooltipUtil=new dt(this),this.tooltipLabels=new gt(this),this.tooltipPosition=new ut(this),this.marker=new ft(this),this.intersect=new pt(this),this.axesTooltip=new xt(this),this.showOnIntersect=this.tConfig.intersect,this.showTooltipTitle=this.tConfig.x.show,this.fixedTooltip=this.tConfig.fixed.enabled,this.xaxisTooltip=null,this.yaxisTTEls=null,this.isBarShared=!a.globals.isBarHorizontal&amp;&amp;this.tConfig.shared}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"getElTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t||(t=this),t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip")}</span>},{key:"getElXCrosshairs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")}</span>},{key:"getElGrid",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")}</span>},{key:"drawTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.xyRatios=t,this.blxaxisTooltip=e.config.xaxis.tooltip.enabled&amp;&amp;e.globals.axisCharts,this.yaxisTooltips=e.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return!!(t.show&amp;&amp;t.tooltip.enabled&amp;&amp;e.globals.axisCharts)}</span>)),this.allTooltipSeriesGroups=[],e.globals.axisCharts||(this.showTooltipTitle=!1);v</span>ar i=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>if(i.classList.add("apexcharts-tooltip"),i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),e.globals.dom.elWrap.appendChild(i),e.globals.axisCharts){<span class="cstat-no" title="statement not covered" >this.axesTooltip.drawXaxisTooltip(),this.axesTooltip.drawYaxisTooltip(),this.axesTooltip.setXCrosshairWidth(),this.axesTooltip.handleYCrosshair();v</span>ar a=<span class="cstat-no" title="statement not covered" >new G(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.xAxisTicksPositions=a.getXAxisTicksPositions()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!e.globals.comboCharts&amp;&amp;!this.tConfig.intersect&amp;&amp;"bar"!==e.config.chart.type&amp;&amp;"rangeBar"!==e.config.chart.type||this.tConfig.shared||(this.showOnIntersect=!0),0!==e.config.markers.size&amp;&amp;0!==e.globals.markers.largestSize||this.marker.drawDynamicPoints(this),e.globals.collapsedSeries.length!==e.globals.series.length){<span class="cstat-no" title="statement not covered" >this.dataPointsDividedHeight=e.globals.gridHeight/e.globals.dataPoints,this.dataPointsDividedWidth=e.globals.gridWidth/e.globals.dataPoints,this.showTooltipTitle&amp;&amp;(this.tooltipTitle=document.createElement("div"),this.tooltipTitle.classList.add("apexcharts-tooltip-title"),this.tooltipTitle.style.fontFamily=this.tConfig.style.fontFamily||e.config.chart.fontFamily,this.tooltipTitle.style.fontSize=this.tConfig.style.fontSize,i.appendChild(this.tooltipTitle));v</span>ar s=<span class="cstat-no" title="statement not covered" >e.globals.series.length;<span class="cstat-no" title="statement not covered" ></span>(e.globals.xyCharts||e.globals.comboCharts)&amp;&amp;this.tConfig.shared&amp;&amp;(s=this.showOnIntersect?1:e.globals.series.length),this.legendLabels=e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"),this.ttItems=this.createTTElements(s),this.addSVGEvents()}</span>}</span>},{key:"createTTElements",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >this.getElTooltip(),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t;s++){var r=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>r.classList.add("apexcharts-tooltip-series-group"),this.tConfig.shared&amp;&amp;this.tConfig.enabledOnSeries&amp;&amp;Array.isArray(this.tConfig.enabledOnSeries)&amp;&amp;this.tConfig.enabledOnSeries.indexOf(s)&lt;0&amp;&amp;r.classList.add("apexcharts-tooltip-series-group-hidden");v</span>ar n=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>n.classList.add("apexcharts-tooltip-marker"),n.style.backgroundColor=e.globals.colors[s],r.appendChild(n);v</span>ar o=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>o.classList.add("apexcharts-tooltip-text"),o.style.fontFamily=this.tConfig.style.fontFamily||e.config.chart.fontFamily,o.style.fontSize=this.tConfig.style.fontSize;v</span>ar l=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>l.classList.add("apexcharts-tooltip-y-group");v</span>ar h=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>h.classList.add("apexcharts-tooltip-text-label"),l.appendChild(h);v</span>ar c=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>c.classList.add("apexcharts-tooltip-text-value"),l.appendChild(c);v</span>ar d=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>d.classList.add("apexcharts-tooltip-z-group");v</span>ar g=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>g.classList.add("apexcharts-tooltip-text-z-label"),d.appendChild(g);v</span>ar u=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>u.classList.add("apexcharts-tooltip-text-z-value"),d.appendChild(u),o.appendChild(l),o.appendChild(d),r.appendChild(o),a.appendChild(r),i.push(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>},{key:"addSVGEvents",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.config.chart.type,</span>i=<span class="cstat-no" title="statement not covered" >this.getElTooltip(),</span>a=<span class="cstat-no" title="statement not covered" >!("bar"!==e&amp;&amp;"candlestick"!==e&amp;&amp;"rangeBar"!==e),</span>s=<span class="cstat-no" title="statement not covered" >"area"===e||"line"===e||"scatter"===e||"bubble"===e||"radar"===e,</span>r=<span class="cstat-no" title="statement not covered" >t.globals.dom.Paper.node,</span>n=<span class="cstat-no" title="statement not covered" >this.getElGrid();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(this.seriesBound=n.getBoundingClientRect());v</span>ar o,l=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >{hoverArea:r,elGrid:n,tooltipEl:i,tooltipY:l,tooltipX:h,ttItems:this.ttItems};<span class="cstat-no" title="statement not covered" ></span>if(t.globals.axisCharts&amp;&amp;(s?o=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker"):a?o=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area"):"heatmap"===e&amp;&amp;(o=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap")),o&amp;&amp;o.length))<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;o.length;d++)<span class="cstat-no" title="statement not covered" >l.push(o[d].getAttribute("cy")),h.push(o[d].getAttribute("cx"));<span class="cstat-no" title="statement not covered" >i</span></span></span>f(t.globals.xyCharts&amp;&amp;!this.showOnIntersect||t.globals.comboCharts&amp;&amp;!this.showOnIntersect||a&amp;&amp;this.tooltipUtil.hasBars()&amp;&amp;this.tConfig.shared)<span class="cstat-no" title="statement not covered" >this.addPathsEventListeners([r],c);e</span>lse <span class="cstat-no" title="statement not covered" >if(a&amp;&amp;!t.globals.comboCharts||s&amp;&amp;this.showOnIntersect)<span class="cstat-no" title="statement not covered" >this.addDatapointEventsListeners(c);e</span>lse <span class="cstat-no" title="statement not covered" >if(!t.globals.axisCharts||"heatmap"===e){var g=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");<span class="cstat-no" title="statement not covered" ></span>this.addPathsEventListeners(g,c)}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(this.showOnIntersect){var u=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");<span class="cstat-no" title="statement not covered" ></span>u.length&gt;0&amp;&amp;this.addPathsEventListeners(u,c),this.tooltipUtil.hasBars()&amp;&amp;!this.tConfig.shared&amp;&amp;this.addDatapointEventsListeners(c)}</span>}</span>},{key:"drawFixedTooltipRect",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >this.getElTooltip(),</span>i=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect(),</span>a=<span class="cstat-no" title="statement not covered" >i.width+10,</span>s=<span class="cstat-no" title="statement not covered" >i.height+10,</span>r=<span class="cstat-no" title="statement not covered" >this.tConfig.fixed.offsetX,</span>n=<span class="cstat-no" title="statement not covered" >this.tConfig.fixed.offsetY,</span>o=<span class="cstat-no" title="statement not covered" >this.tConfig.fixed.position.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>return o.indexOf("right")&gt;-1&amp;&amp;(r=r+t.globals.svgWidth-a+10),o.indexOf("bottom")&gt;-1&amp;&amp;(n=n+t.globals.svgHeight-s-10),e.style.left=r+"px",e.style.top=n+"px",{x:r,y:n,ttWidth:a,ttHeight:s}}</span>},{key:"addDatapointEventsListeners",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area");<span class="cstat-no" title="statement not covered" ></span>this.addPathsEventListeners(e,t)}</span>},{key:"addPathsEventListeners",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(a){var s=<span class="cstat-no" title="statement not covered" >{paths:t[a],tooltipEl:e.tooltipEl,tooltipY:e.tooltipY,tooltipX:e.tooltipX,elGrid:e.elGrid,hoverArea:e.hoverArea,ttItems:e.ttItems};<span class="cstat-no" title="statement not covered" ></span>["mousemove","mouseup","touchmove","mouseout","touchend"].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[a].addEventListener(e,i.seriesHover.bind(i,s),{capture:!1,passive:!0})}</span>))}</span>,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.length;s++)<span class="cstat-no" title="statement not covered" >a(s)}</span></span>},{key:"seriesHover",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>s.config.chart.group&amp;&amp;(a=this.ctx.getGroupedCharts()),s.globals.axisCharts&amp;&amp;(s.globals.minX===-1/0&amp;&amp;s.globals.maxX===1/0||0===s.globals.dataPoints)||(a.length?a.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(a){var s=<span class="cstat-no" title="statement not covered" >i.getElTooltip(a),</span>r=<span class="cstat-no" title="statement not covered" >{paths:t.paths,tooltipEl:s,tooltipY:t.tooltipY,tooltipX:t.tooltipX,elGrid:t.elGrid,hoverArea:t.hoverArea,ttItems:a.w.globals.tooltip.ttItems};<span class="cstat-no" title="statement not covered" ></span>a.w.globals.minX===i.w.globals.minX&amp;&amp;a.w.globals.maxX===i.w.globals.maxX&amp;&amp;a.w.globals.tooltip.seriesHoverByContext({chartCtx:a,ttCtx:a.w.globals.tooltip,opt:r,e:e})}</span>)):this.seriesHoverByContext({chartCtx:this.ctx,ttCtx:this.w.globals.tooltip,opt:t,e:e}))}</span>},{key:"seriesHoverByContext",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.chartCtx,</span>i=<span class="cstat-no" title="statement not covered" >t.ttCtx,</span>a=<span class="cstat-no" title="statement not covered" >t.opt,</span>s=<span class="cstat-no" title="statement not covered" >t.e,</span>r=<span class="cstat-no" title="statement not covered" >e.w,</span>n=<span class="cstat-no" title="statement not covered" >this.getElTooltip();<span class="cstat-no" title="statement not covered" ></span>(i.tooltipRect={x:0,y:0,ttWidth:n.getBoundingClientRect().width,ttHeight:n.getBoundingClientRect().height},i.e=s,!i.tooltipUtil.hasBars()||r.globals.comboCharts||i.isBarShared)||this.tConfig.onDatasetHover.highlightDataSeries&amp;&amp;new M(e).toggleSeriesOnHover(s,s.target.parentNode);<span class="cstat-no" title="statement not covered" >i</span>.fixedTooltip&amp;&amp;i.drawFixedTooltipRect(),r.globals.axisCharts?i.axisChartsTooltips({e:s,opt:a,tooltipRect:i.tooltipRect}):i.nonAxisChartsTooltips({e:s,opt:a,tooltipRect:i.tooltipRect})}</span>},{key:"axisChartsTooltips",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i,a=<span class="cstat-no" title="statement not covered" >t.e,</span>s=<span class="cstat-no" title="statement not covered" >t.opt,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >s.elGrid.getBoundingClientRect(),</span>o=<span class="cstat-no" title="statement not covered" >"touchmove"===a.type?a.touches[0].clientX:a.clientX,</span>l=<span class="cstat-no" title="statement not covered" >"touchmove"===a.type?a.touches[0].clientY:a.clientY;<span class="cstat-no" title="statement not covered" ></span>if(this.clientY=l,this.clientX=o,r.globals.capturedSeriesIndex=-1,r.globals.capturedDataPointIndex=-1,l&lt;n.top||l&gt;n.top+n.height)<span class="cstat-no" title="statement not covered" >this.handleMouseOut(s);e</span>lse{<span class="cstat-no" title="statement not covered" >if(Array.isArray(this.tConfig.enabledOnSeries)&amp;&amp;!r.config.tooltip.shared){var h=<span class="cstat-no" title="statement not covered" >parseInt(s.paths.getAttribute("index"),10);<span class="cstat-no" title="statement not covered" ></span>if(this.tConfig.enabledOnSeries.indexOf(h)&lt;0)<span class="cstat-no" title="statement not covered" >return void this.handleMouseOut(s)}</span></span>v</span>ar c=<span class="cstat-no" title="statement not covered" >this.getElTooltip(),</span>d=<span class="cstat-no" title="statement not covered" >this.getElXCrosshairs(),</span>g=<span class="cstat-no" title="statement not covered" >r.globals.xyCharts||"bar"===r.config.chart.type&amp;&amp;!r.globals.isBarHorizontal&amp;&amp;this.tooltipUtil.hasBars()&amp;&amp;this.tConfig.shared||r.globals.comboCharts&amp;&amp;this.tooltipUtil.hasBars();<span class="cstat-no" title="statement not covered" ></span>if(r.globals.isBarHorizontal&amp;&amp;this.tooltipUtil.hasBars()&amp;&amp;(g=!1),"mousemove"===a.type||"touchmove"===a.type||"mouseup"===a.type){<span class="cstat-no" title="statement not covered" >null!==d&amp;&amp;d.classList.add("apexcharts-active");v</span>ar u=<span class="cstat-no" title="statement not covered" >this.yaxisTooltips.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!0===t}</span>));<span class="cstat-no" title="statement not covered" ></span>if(null!==this.ycrosshairs&amp;&amp;u.length&amp;&amp;this.ycrosshairs.classList.add("apexcharts-active"),g&amp;&amp;!this.showOnIntersect)<span class="cstat-no" title="statement not covered" >this.handleStickyTooltip(a,o,l,s);e</span>lse <span class="cstat-no" title="statement not covered" >if("heatmap"===r.config.chart.type){var f=<span class="cstat-no" title="statement not covered" >this.intersect.handleHeatTooltip({e:a,opt:s,x:e,y:i});<span class="cstat-no" title="statement not covered" ></span>e=f.x,i=f.y,c.style.left=e+"px",c.style.top=i+"px"}</span>else <span class="cstat-no" title="statement not covered" >this.tooltipUtil.hasBars()&amp;&amp;this.intersect.handleBarTooltip({e:a,opt:s}),this.tooltipUtil.hasMarkers()&amp;&amp;this.intersect.handleMarkerTooltip({e:a,opt:s,x:e,y:i});<span class="cstat-no" title="statement not covered" >i</span></span></span>f(this.yaxisTooltips.length)<span class="cstat-no" title="statement not covered" >for(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;r.config.yaxis.length;p++)<span class="cstat-no" title="statement not covered" >this.axesTooltip.drawYaxisTooltipText(p,l,this.xyRatios);<span class="cstat-no" title="statement not covered" >s</span></span></span>.tooltipEl.classList.add("apexcharts-active")}</span>else<span class="cstat-no" title="statement not covered" >"mouseout"!==a.type&amp;&amp;"touchend"!==a.type||this.handleMouseOut(s)}</span></span>}</span>},{key:"nonAxisChartsTooltips",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.e,</span>i=<span class="cstat-no" title="statement not covered" >t.opt,</span>a=<span class="cstat-no" title="statement not covered" >t.tooltipRect,</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >i.paths.getAttribute("rel"),</span>n=<span class="cstat-no" title="statement not covered" >this.getElTooltip(),</span>o=<span class="cstat-no" title="statement not covered" >s.globals.dom.elWrap.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===e.type||"touchmove"===e.type){<span class="cstat-no" title="statement not covered" >n.classList.add("apexcharts-active"),this.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:parseInt(r,10)-1,shared:!1});v</span>ar l=<span class="cstat-no" title="statement not covered" >s.globals.clientX-o.left-a.ttWidth/2,</span>h=<span class="cstat-no" title="statement not covered" >s.globals.clientY-o.top-a.ttHeight-10;<span class="cstat-no" title="statement not covered" ></span>n.style.left=l+"px",n.style.top=h+"px"}</span>else<span class="cstat-no" title="statement not covered" >"mouseout"!==e.type&amp;&amp;"touchend"!==e.type||n.classList.remove("apexcharts-active")}</span></span>},{key:"handleStickyTooltip",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >this.tooltipUtil.getNearestValues({context:this,hoverArea:a.hoverArea,elGrid:a.elGrid,clientX:e,clientY:i}),</span>n=<span class="cstat-no" title="statement not covered" >r.j,</span>o=<span class="cstat-no" title="statement not covered" >r.capturedSeries;<span class="cstat-no" title="statement not covered" ></span>r.hoverX&lt;0||r.hoverX&gt;s.globals.gridWidth?this.handleMouseOut(a):null!==o?this.handleStickyCapturedSeries(t,o,a,n):this.tooltipUtil.isXoverlap(n)&amp;&amp;this.create(t,this,0,n,a.ttItems)}</span>},{key:"handleStickyCapturedSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>null===s.globals.series[e][a]?this.handleMouseOut(i):void 0!==s.globals.series[e][a]?this.tConfig.shared&amp;&amp;this.tooltipUtil.isXoverlap(a)&amp;&amp;this.tooltipUtil.isInitialSeriesSameLen()?this.create(t,this,e,a,i.ttItems):this.create(t,this,e,a,i.ttItems,!1):this.tooltipUtil.isXoverlap(a)&amp;&amp;this.create(t,this,0,a,i.ttItems)}</span>},{key:"deactivateHoverFilter",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>i=<span class="cstat-no" title="statement not covered" >t.globals.dom.Paper.select(".apexcharts-bar-area"),</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++)<span class="cstat-no" title="statement not covered" >e.pathMouseLeave(i[a])}</span></span>},{key:"handleMouseOut",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >this.getElXCrosshairs();<span class="cstat-no" title="statement not covered" ></span>if(t.tooltipEl.classList.remove("apexcharts-active"),this.deactivateHoverFilter(),"bubble"!==e.config.chart.type&amp;&amp;this.marker.resetPointsSize(),null!==i&amp;&amp;i.classList.remove("apexcharts-active"),null!==this.ycrosshairs&amp;&amp;this.ycrosshairs.classList.remove("apexcharts-active"),this.blxaxisTooltip&amp;&amp;this.xaxisTooltip.classList.remove("apexcharts-active"),this.yaxisTooltips.length){<span class="cstat-no" title="statement not covered" >null===this.yaxisTTEls&amp;&amp;(this.yaxisTTEls=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;this.yaxisTTEls.length;a++)<span class="cstat-no" title="statement not covered" >this.yaxisTTEls[a].classList.remove("apexcharts-active")}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.config.legend.tooltipHoverFormatter&amp;&amp;this.legendLabels.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.getAttribute("data:default-text");<span class="cstat-no" title="statement not covered" ></span>t.innerHTML=decodeURIComponent(e)}</span>))}</span>},{key:"markerClick",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>"function"==typeof a.config.chart.events.markerClick&amp;&amp;a.config.chart.events.markerClick(t,this.ctx,{seriesIndex:e,dataPointIndex:i,w:a}),this.ctx.events.fireEvent("markerClick",[t,this.ctx,{seriesIndex:e,dataPointIndex:i,w:a}])}</span>},{key:"create",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){var r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;5&amp;&amp;void 0!==arguments[5]?arguments[5]:null,</span>n=<span class="cstat-no" title="statement not covered" >this.w,</span>o=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>"mouseup"===t.type&amp;&amp;this.markerClick(t,i,a),null===r&amp;&amp;(r=this.tConfig.shared);v</span>ar l=<span class="cstat-no" title="statement not covered" >this.tooltipUtil.hasMarkers(),</span>h=<span class="cstat-no" title="statement not covered" >this.tooltipUtil.getElBars();<span class="cstat-no" title="statement not covered" ></span>if(n.config.legend.tooltipHoverFormatter){var c=<span class="cstat-no" title="statement not covered" >n.config.legend.tooltipHoverFormatter,</span>d=<span class="cstat-no" title="statement not covered" >Array.from(this.legendLabels);<span class="cstat-no" title="statement not covered" ></span>d.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.getAttribute("data:default-text");<span class="cstat-no" title="statement not covered" ></span>t.innerHTML=decodeURIComponent(e)}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;d.length;g++){var u=<span class="cstat-no" title="statement not covered" >d[g],</span>f=<span class="cstat-no" title="statement not covered" >parseInt(u.getAttribute("i"),10),</span>x=<span class="cstat-no" title="statement not covered" >decodeURIComponent(u.getAttribute("data:default-text")),</span>b=<span class="cstat-no" title="statement not covered" >c(x,{seriesIndex:r?f:i,dataPointIndex:a,w:n});<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >u.innerHTML=n.globals.collapsedSeriesIndices.indexOf(f)&lt;0?b:x;e</span>lse <span class="cstat-no" title="statement not covered" >if(u.innerHTML=f===i?b:x,i===f)<span class="cstat-no" title="statement not covered" >break}</span></span></span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r){<span class="cstat-no" title="statement not covered" >if(o.tooltipLabels.drawSeriesTexts({ttItems:s,i:i,j:a,shared:!this.showOnIntersect&amp;&amp;this.tConfig.shared}),l&amp;&amp;(n.globals.markers.largestSize&gt;0?o.marker.enlargePoints(a):o.tooltipPosition.moveDynamicPointsOnHover(a)),this.tooltipUtil.hasBars()&amp;&amp;(this.barSeriesHeight=this.tooltipUtil.getBarsHeight(h),this.barSeriesHeight&gt;0)){var m=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>v=<span class="cstat-no" title="statement not covered" >n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a,"']"));<span class="cstat-no" title="statement not covered" ></span>this.deactivateHoverFilter(),this.tooltipPosition.moveStickyTooltipOverBars(a);<span class="cstat-no" title="statement not covered" >f</span>or(var y=<span class="cstat-no" title="statement not covered" >0;</span>y&lt;v.length;y++)<span class="cstat-no" title="statement not covered" >m.pathMouseEnter(v[y])}</span></span>}</span>else <span class="cstat-no" title="statement not covered" >o.tooltipLabels.drawSeriesTexts({shared:!1,ttItems:s,i:i,j:a}),this.tooltipUtil.hasBars()&amp;&amp;o.tooltipPosition.moveStickyTooltipOverBars(a),l&amp;&amp;o.tooltipPosition.moveMarkers(i,a)}</span></span>}]),t}</span>(),</span>mt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >i(</span>){<span class="cstat-no" title="statement not covered" >return e(this,i),c(this,l(i).apply(this,arguments))}<span class="cstat-no" title="statement not covered" ></span>return o(i,t),a(i,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.graphics=new p(this.ctx),this.bar=new X(this.ctx,this.xyRatios);v</span>ar s=<span class="cstat-no" title="statement not covered" >new m(this.ctx,a);<span class="cstat-no" title="statement not covered" ></span>t=s.getLogSeries(t),this.yRatio=s.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t),"100%"===a.config.chart.stackType&amp;&amp;(t=a.globals.seriesPercent.slice()),this.series=t,this.totalItems=0,this.prevY=[],this.prevX=[],this.prevYF=[],this.prevXF=[],this.prevYVal=[],this.prevXVal=[],this.xArrj=[],this.xArrjF=[],this.xArrjVal=[],this.yArrj=[],this.yArrjF=[],this.yArrjVal=[];<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >t[r].length&gt;0&amp;&amp;(this.totalItems+=t[r].length);<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >this.graphics.group({class:"apexcharts-bar-series apexcharts-plot-series"}),</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(s,r){var c=<span class="cstat-no" title="statement not covered" >void 0,</span>d=<span class="cstat-no" title="statement not covered" >void 0,</span>u=<span class="cstat-no" title="statement not covered" >void 0,</span>f=<span class="cstat-no" title="statement not covered" >void 0,</span>p=<span class="cstat-no" title="statement not covered" >[],</span>x=<span class="cstat-no" title="statement not covered" >[],</span>b=<span class="cstat-no" title="statement not covered" >a.globals.comboCharts?e[s]:s;<span class="cstat-no" title="statement not covered" ></span>i.yRatio.length&gt;1&amp;&amp;(i.yaxisIndex=b),i.isReversed=a.config.yaxis[i.yaxisIndex]&amp;&amp;a.config.yaxis[i.yaxisIndex].reversed;v</span>ar m=<span class="cstat-no" title="statement not covered" >i.graphics.group({class:"apexcharts-series",seriesName:g.escapeString(a.globals.seriesNames[b]),rel:s+1,"data:realIndex":b});<span class="cstat-no" title="statement not covered" ></span>i.ctx.series.addCollapsedClassToSeries(m,b);v</span>ar v=<span class="cstat-no" title="statement not covered" >i.graphics.group({class:"apexcharts-datalabels","data:realIndex":b}),</span>y=<span class="cstat-no" title="statement not covered" >0,</span>w=<span class="cstat-no" title="statement not covered" >0,</span>k=<span class="cstat-no" title="statement not covered" >i.initialPositions(l,h,c,d,u,f);<span class="cstat-no" title="statement not covered" ></span>h=k.y,y=k.barHeight,d=k.yDivision,f=k.zeroW,l=k.x,w=k.barWidth,c=k.xDivision,u=k.zeroH,i.yArrj=[],i.yArrjF=[],i.yArrjVal=[],i.xArrj=[],i.xArrjF=[],i.xArrjVal=[],1===i.prevY.length&amp;&amp;i.prevY[0].every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return isNaN(t)}</span>))&amp;&amp;(i.prevY[0]=i.prevY[0].map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return u}</span>)),i.prevYF[0]=i.prevYF[0].map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0}</span>)));<span class="cstat-no" title="statement not covered" >f</span>or(var A=<span class="cstat-no" title="statement not covered" >0;</span>A&lt;a.globals.dataPoints;A++){var S=<span class="cstat-no" title="statement not covered" >i.barHelpers.getStrokeWidth(s,A,b),</span>C=<span class="cstat-no" title="statement not covered" >{indexes:{i:s,j:A,realIndex:b,bc:r},strokeWidth:S,x:l,y:h,elSeries:m},</span>L=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>i.isHorizontal?(L=i.drawStackedBarPaths(n({},C,{zeroW:f,barHeight:y,yDivision:d})),w=i.series[s][A]/i.invertedYRatio):(L=i.drawStackedColumnPaths(n({},C,{xDivision:c,barWidth:w,zeroH:u})),y=i.series[s][A]/i.yRatio[i.yaxisIndex]),h=L.y,l=L.x,p.push(l),x.push(h);v</span>ar P=<span class="cstat-no" title="statement not covered" >i.barHelpers.getPathFillColor(t,s,A,b);<span class="cstat-no" title="statement not covered" ></span>m=i.renderSeries({realIndex:b,pathFill:P,j:A,i:s,pathFrom:L.pathFrom,pathTo:L.pathTo,strokeWidth:S,elSeries:m,x:l,y:h,series:t,barHeight:y,barWidth:w,elDataLabelsWrap:v,type:"bar",visibleSeries:0})}<span class="cstat-no" title="statement not covered" ></span>a</span>.globals.seriesXvalues[b]=p,a.globals.seriesYvalues[b]=x,i.prevY.push(i.yArrj),i.prevYF.push(i.yArrjF),i.prevYVal.push(i.yArrjVal),i.prevX.push(i.xArrj),i.prevXF.push(i.xArrjF),i.prevXVal.push(i.xArrjVal),o.add(m)}</span>,</span>d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;t.length;d++,u++)<span class="cstat-no" title="statement not covered" >c(d,u);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>},{key:"initialPositions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r){var n,o,l=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal?(n=(n=a=l.globals.gridHeight/l.globals.dataPoints)*parseInt(l.config.plotOptions.bar.barHeight,10)/100,r=this.baseLineInvertedY+l.globals.padHorizontal+(this.isReversed?l.globals.gridWidth:0)-(this.isReversed?2*this.baseLineInvertedY:0),e=(a-n)/2):(o=i=l.globals.gridWidth/l.globals.dataPoints,o=l.globals.isXNumeric&amp;&amp;l.globals.dataPoints&gt;1?(i=l.globals.minXDiff/this.xRatio)*parseInt(this.barOptions.columnWidth,10)/100:o*parseInt(l.config.plotOptions.bar.columnWidth,10)/100,s=this.baseLineY[this.yaxisIndex]+(this.isReversed?l.globals.gridHeight:0)-(this.isReversed?2*this.baseLineY[this.yaxisIndex]:0),t=l.globals.padHorizontal+(i-o)/2),{x:t,y:e,yDivision:a,xDivision:i,barHeight:n,barWidth:o,zeroH:s,zeroW:r}}</span>},{key:"drawStackedBarPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e,i=<span class="cstat-no" title="statement not covered" >t.indexes,</span>a=<span class="cstat-no" title="statement not covered" >t.barHeight,</span>s=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>r=<span class="cstat-no" title="statement not covered" >t.zeroW,</span>n=<span class="cstat-no" title="statement not covered" >t.x,</span>o=<span class="cstat-no" title="statement not covered" >t.y,</span>l=<span class="cstat-no" title="statement not covered" >t.yDivision,</span>h=<span class="cstat-no" title="statement not covered" >t.elSeries,</span>c=<span class="cstat-no" title="statement not covered" >this.w,</span>d=<span class="cstat-no" title="statement not covered" >o,</span>g=<span class="cstat-no" title="statement not covered" >i.i,</span>u=<span class="cstat-no" title="statement not covered" >i.j,</span>f=<span class="cstat-no" title="statement not covered" >i.bc,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >0;</span>x&lt;this.prevXF.length;x++)<span class="cstat-no" title="statement not covered" >p+=this.prevXF[x][u];<span class="cstat-no" title="statement not covered" >i</span></span>f(g&gt;0){var b=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>this.prevXVal[g-1][u]&lt;0?b=this.series[g][u]&gt;=0?this.prevX[g-1][u]+p-2*(this.isReversed?p:0):this.prevX[g-1][u]:this.prevXVal[g-1][u]&gt;=0&amp;&amp;(b=this.series[g][u]&gt;=0?this.prevX[g-1][u]:this.prevX[g-1][u]-p+2*(this.isReversed?p:0)),e=b}</span>else <span class="cstat-no" title="statement not covered" >e=r;<span class="cstat-no" title="statement not covered" >n</span></span>=null===this.series[g][u]?e:e+this.series[g][u]/this.invertedYRatio-2*(this.isReversed?this.series[g][u]/this.invertedYRatio:0),this.xArrj.push(n),this.xArrjF.push(Math.abs(e-n)),this.xArrjVal.push(this.series[g][u]);v</span>ar m=<span class="cstat-no" title="statement not covered" >this.barHelpers.getBarpaths({barYPosition:d,barHeight:a,x1:e,x2:n,strokeWidth:s,series:this.series,realIndex:i.realIndex,i:g,j:u,w:c});<span class="cstat-no" title="statement not covered" ></span>return this.barHelpers.barBackground({bc:f,i:g,y1:d,y2:a,elSeries:h}),o+=l,{pathTo:m.pathTo,pathFrom:m.pathFrom,x:n,y:o}}</span>},{key:"drawStackedColumnPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.indexes,</span>i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=<span class="cstat-no" title="statement not covered" >t.y,</span>s=<span class="cstat-no" title="statement not covered" >t.xDivision,</span>r=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>n=<span class="cstat-no" title="statement not covered" >t.zeroH,</span>o=(<span class="cstat-no" title="statement not covered" >t.strokeWidth,t.elSeries)</span>,l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >e.i,</span>c=<span class="cstat-no" title="statement not covered" >e.j,</span>d=<span class="cstat-no" title="statement not covered" >e.bc;<span class="cstat-no" title="statement not covered" ></span>if(l.globals.isXNumeric){var g=<span class="cstat-no" title="statement not covered" >l.globals.seriesX[h][c];<span class="cstat-no" title="statement not covered" ></span>g||(g=0),i=(g-l.globals.minX)/this.xRatio-r/2}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u,f=<span class="cstat-no" title="statement not covered" >i,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >0;</span>x&lt;this.prevYF.length;x++)<span class="cstat-no" title="statement not covered" >p+=isNaN(this.prevYF[x][c])?0:this.prevYF[x][c];<span class="cstat-no" title="statement not covered" >i</span></span>f(h&gt;0&amp;&amp;!l.globals.isXNumeric||h&gt;0&amp;&amp;l.globals.isXNumeric&amp;&amp;l.globals.seriesX[h-1][c]===l.globals.seriesX[h][c]){var b,m,v=<span class="cstat-no" title="statement not covered" >Math.min(this.yRatio.length+1,h+1);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==this.prevY[h-1])<span class="cstat-no" title="statement not covered" >for(var y=<span class="cstat-no" title="statement not covered" >1;</span>y&lt;v;y++)<span class="cstat-no" title="statement not covered" >if(!isNaN(this.prevY[h-y][c])){<span class="cstat-no" title="statement not covered" >m=this.prevY[h-y][c];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(var w=<span class="cstat-no" title="statement not covered" >1;</span>w&lt;v;w++){<span class="cstat-no" title="statement not covered" >if(this.prevYVal[h-w][c]&lt;0){<span class="cstat-no" title="statement not covered" >b=this.series[h][c]&gt;=0?m-p+2*(this.isReversed?p:0):m;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.prevYVal[h-w][c]&gt;=0){<span class="cstat-no" title="statement not covered" >b=this.series[h][c]&gt;=0?m:m+p-2*(this.isReversed?p:0);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>oid 0===b&amp;&amp;(b=l.globals.gridHeight),u=this.prevYF[0].every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0===t}</span>))&amp;&amp;this.prevYF.slice(1,h).every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return isNaN(t)}</span>))}</span>))?l.globals.gridHeight-n:b}</span>else <span class="cstat-no" title="statement not covered" >u=l.globals.gridHeight-n;<span class="cstat-no" title="statement not covered" >a</span></span>=u-this.series[h][c]/this.yRatio[this.yaxisIndex]+2*(this.isReversed?this.series[h][c]/this.yRatio[this.yaxisIndex]:0),this.yArrj.push(a),this.yArrjF.push(Math.abs(u-a)),this.yArrjVal.push(this.series[h][c]);v</span>ar k=<span class="cstat-no" title="statement not covered" >this.barHelpers.getColumnPaths({barXPosition:f,barWidth:r,y1:u,y2:a,yRatio:this.yRatio[this.yaxisIndex],strokeWidth:this.strokeWidth,series:this.series,realIndex:e.realIndex,i:h,j:c,w:l});<span class="cstat-no" title="statement not covered" ></span>return this.barHelpers.barBackground({bc:d,i:h,x1:f,x2:r,elSeries:o}),i+=s,{pathTo:k.pathTo,pathFrom:k.pathFrom,x:l.globals.isXNumeric?i-s:i,y:a}}</span>}]),i}</span>(X),</span>vt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >i(</span>){<span class="cstat-no" title="statement not covered" >return e(this,i),c(this,l(i).apply(this,arguments))}<span class="cstat-no" title="statement not covered" ></span>return o(i,t),a(i,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >new L(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.candlestickOptions=this.w.config.plotOptions.candlestick;v</span>ar r=<span class="cstat-no" title="statement not covered" >new m(this.ctx,i);<span class="cstat-no" title="statement not covered" ></span>t=r.getLogSeries(t),this.series=t,this.yRatio=r.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-candlestick-series apexcharts-plot-series"}),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.length;o++){var l,h,c=<span class="cstat-no" title="statement not covered" >void 0,</span>d=<span class="cstat-no" title="statement not covered" >void 0,</span>u=<span class="cstat-no" title="statement not covered" >[],</span>f=<span class="cstat-no" title="statement not covered" >[],</span>x=<span class="cstat-no" title="statement not covered" >i.globals.comboCharts?e[o]:o,</span>b=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-series",seriesName:g.escapeString(i.globals.seriesNames[x]),rel:o+1,"data:realIndex":x});<span class="cstat-no" title="statement not covered" ></span>t[o].length&gt;0&amp;&amp;(this.visibleI=this.visibleI+1);v</span>ar v,y;<span class="cstat-no" title="statement not covered" >this.yRatio.length&gt;1&amp;&amp;(this.yaxisIndex=x);v</span>ar w=<span class="cstat-no" title="statement not covered" >this.barHelpers.initialPositions();<span class="cstat-no" title="statement not covered" ></span>d=w.y,v=w.barHeight,c=w.x,y=w.barWidth,l=w.xDivision,h=w.zeroH,f.push(c+y/2);<span class="cstat-no" title="statement not covered" >f</span>or(var k=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-datalabels","data:realIndex":x}),</span>A=<span class="cstat-no" title="statement not covered" >0;</span>A&lt;i.globals.dataPoints;A++){var S,C=<span class="cstat-no" title="statement not covered" >this.barHelpers.getStrokeWidth(o,A,x),</span>P=<span class="cstat-no" title="statement not covered" >this.drawCandleStickPaths({indexes:{i:o,j:A,realIndex:x},x:c,y:d,xDivision:l,barWidth:y,zeroH:h,strokeWidth:C,elSeries:b});<span class="cstat-no" title="statement not covered" ></span>d=P.y,c=P.x,S=P.color,A&gt;0&amp;&amp;f.push(c+y/2),u.push(d);v</span>ar T=<span class="cstat-no" title="statement not covered" >s.fillPath({seriesNumber:x,dataPointIndex:A,color:S,value:t[o][A]}),</span>z=<span class="cstat-no" title="statement not covered" >this.candlestickOptions.wick.useFillColor?S:void 0;<span class="cstat-no" title="statement not covered" ></span>this.renderSeries({realIndex:x,pathFill:T,lineFill:z,j:A,i:o,pathFrom:P.pathFrom,pathTo:P.pathTo,strokeWidth:C,elSeries:b,x:c,y:d,series:t,barHeight:v,barWidth:y,elDataLabelsWrap:k,visibleSeries:this.visibleI,type:"candlestick"})}<span class="cstat-no" title="statement not covered" ></span>i</span>.globals.seriesXvalues[x]=f,i.globals.seriesYvalues[x]=u,n.add(b)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>},{key:"drawCandleStickPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.indexes,</span>i=<span class="cstat-no" title="statement not covered" >t.x,</span>a=(<span class="cstat-no" title="statement not covered" >t.y,t.xDivision)</span>,s=<span class="cstat-no" title="statement not covered" >t.barWidth,</span>r=<span class="cstat-no" title="statement not covered" >t.zeroH,</span>n=<span class="cstat-no" title="statement not covered" >t.strokeWidth,</span>o=<span class="cstat-no" title="statement not covered" >this.w,</span>l=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>h=<span class="cstat-no" title="statement not covered" >e.i,</span>c=<span class="cstat-no" title="statement not covered" >e.j,</span>d=<span class="cstat-no" title="statement not covered" >!0,</span>g=<span class="cstat-no" title="statement not covered" >o.config.plotOptions.candlestick.colors.upward,</span>u=<span class="cstat-no" title="statement not covered" >o.config.plotOptions.candlestick.colors.downward,</span>f=<span class="cstat-no" title="statement not covered" >this.yRatio[this.yaxisIndex],</span>x=<span class="cstat-no" title="statement not covered" >e.realIndex,</span>b=<span class="cstat-no" title="statement not covered" >this.getOHLCValue(x,c),</span>m=<span class="cstat-no" title="statement not covered" >r,</span>v=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>b.o&gt;b.c&amp;&amp;(d=!1);v</span>ar y=<span class="cstat-no" title="statement not covered" >Math.min(b.o,b.c),</span>w=<span class="cstat-no" title="statement not covered" >Math.max(b.o,b.c);<span class="cstat-no" title="statement not covered" ></span>o.globals.isXNumeric&amp;&amp;(i=(o.globals.seriesX[x][c]-o.globals.minX)/this.xRatio-s/2);v</span>ar k=<span class="cstat-no" title="statement not covered" >i+s*this.visibleI;<span class="cstat-no" title="statement not covered" ></span>void 0===this.series[h][c]||null===this.series[h][c]?y=r:(y=r-y/f,w=r-w/f,m=r-b.h/f,v=r-b.l/f);v</span>ar A=<span class="cstat-no" title="statement not covered" >l.move(k,r),</span>S=<span class="cstat-no" title="statement not covered" >l.move(k,y);<span class="cstat-no" title="statement not covered" ></span>return o.globals.previousPaths.length&gt;0&amp;&amp;(S=this.getPreviousPath(x,c,!0)),A=l.move(k,w)+l.line(k+s/2,w)+l.line(k+s/2,m)+l.line(k+s/2,w)+l.line(k+s,w)+l.line(k+s,y)+l.line(k+s/2,y)+l.line(k+s/2,v)+l.line(k+s/2,y)+l.line(k,y)+l.line(k,w-n/2),S+=l.move(k,y),o.globals.isXNumeric||(i+=a),{pathTo:A,pathFrom:S,x:i,y:w,barXPosition:k,color:d?g:u}}</span>},{key:"getOHLCValue",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return{o:i.globals.seriesCandleO[t][e],h:i.globals.seriesCandleH[t][e],l:i.globals.seriesCandleL[t][e],c:i.globals.seriesCandleC[t][e]}}</span>}]),i}</span>(X),</span>yt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.xRatio=a.xRatio,this.yRatio=a.yRatio,this.negRange=!1,this.dynamicAnim=this.w.config.chart.animations.dynamicAnimation,this.rectRadius=this.w.config.plotOptions.heatmap.radius,this.strokeWidth=this.w.config.stroke.show?this.w.config.stroke.width:0}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-heatmap"});<span class="cstat-no" title="statement not covered" ></span>a.attr("clip-path","url(#gridRectMask".concat(e.globals.cuid,")"));v</span>ar s=<span class="cstat-no" title="statement not covered" >e.globals.gridWidth/e.globals.dataPoints,</span>r=<span class="cstat-no" title="statement not covered" >e.globals.gridHeight/e.globals.series.length,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>this.checkColorRange();v</span>ar l=<span class="cstat-no" title="statement not covered" >t.slice();<span class="cstat-no" title="statement not covered" ></span>e.config.yaxis[0].reversed&amp;&amp;(o=!0,l.reverse());<span class="cstat-no" title="statement not covered" >f</span>or(var h=<span class="cstat-no" title="statement not covered" >o?0:l.length-1;</span>o?h&lt;l.length:h&gt;=0;o?h++:h--){var c=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-series apexcharts-heatmap-series",seriesName:g.escapeString(e.globals.seriesNames[h]),rel:h+1,"data:realIndex":h});<span class="cstat-no" title="statement not covered" ></span>if(this.ctx.series.addCollapsedClassToSeries(c,h),e.config.chart.dropShadow.enabled){var d=<span class="cstat-no" title="statement not covered" >e.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>new u(this.ctx).dropShadow(c,d,h)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var f=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >0;</span>x&lt;l[h].length;x++){var b=<span class="cstat-no" title="statement not covered" >1,</span>m=<span class="cstat-no" title="statement not covered" >e.config.plotOptions.heatmap.shadeIntensity,</span>v=<span class="cstat-no" title="statement not covered" >this.determineHeatColor(h,x);<span class="cstat-no" title="statement not covered" ></span>b=e.globals.hasNegs||this.negRange?e.config.plotOptions.heatmap.reverseNegativeShade?v.percent&lt;0?v.percent/100*(1.25*m):(1-v.percent/100)*(1.25*m):v.percent&lt;=0?1-(1+v.percent/100)*m:(1-v.percent/100)*m:1-v.percent/100;v</span>ar y=<span class="cstat-no" title="statement not covered" >v.color,</span>w=<span class="cstat-no" title="statement not covered" >new g;<span class="cstat-no" title="statement not covered" ></span>if(e.config.plotOptions.heatmap.enableShades&amp;&amp;(b&lt;0&amp;&amp;(b=0),y=g.hexToRgba(w.shadeColor(b,v.color),e.config.fill.opacity)),"image"===e.config.fill.type)<span class="cstat-no" title="statement not covered" >y=new L(this.ctx).fillPath({seriesNumber:h,dataPointIndex:x,opacity:e.globals.hasNegs?v.percent&lt;0?1-(1+v.percent/100):m+v.percent/100:v.percent/100,patternID:g.randomId(),width:e.config.fill.image.width?e.config.fill.image.width:s,height:e.config.fill.image.height?e.config.fill.image.height:r});v</span></span>ar k=<span class="cstat-no" title="statement not covered" >this.rectRadius,</span>A=<span class="cstat-no" title="statement not covered" >i.drawRect(f,n,s,r,k);<span class="cstat-no" title="statement not covered" ></span>if(A.attr({cx:f,cy:n}),A.node.classList.add("apexcharts-heatmap-rect"),c.add(A),A.attr({fill:y,i:h,index:h,j:x,val:l[h][x],"stroke-width":this.strokeWidth,stroke:e.config.plotOptions.heatmap.useFillColorAsStroke?y:e.globals.stroke.colors[0],color:y}),A.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this,A)),A.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this,A)),A.node.addEventListener("mousedown",i.pathMouseDown.bind(this,A)),e.config.chart.animations.enabled&amp;&amp;!e.globals.dataChanged){var S=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>e.globals.resized||(S=e.config.chart.animations.speed),this.animateHeatMap(A,f,n,s,r,S)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.globals.dataChanged){var C=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(this.dynamicAnim.enabled&amp;&amp;e.globals.shouldAnimate){<span class="cstat-no" title="statement not covered" >C=this.dynamicAnim.speed;v</span>ar P=<span class="cstat-no" title="statement not covered" >e.globals.previousPaths[h]&amp;&amp;e.globals.previousPaths[h][x]&amp;&amp;e.globals.previousPaths[h][x].color;<span class="cstat-no" title="statement not covered" ></span>P||(P="rgba(255, 255, 255, 0)"),this.animateHeatColor(A,g.isColorHex(P)?P:g.rgb2hex(P),g.isColorHex(y)?y:g.rgb2hex(y),C)}</span>}</span>v</span>ar T=<span class="cstat-no" title="statement not covered" >this.calculateHeatmapDataLabels({x:f,y:n,i:h,j:x,heatColorProps:v,series:l,rectHeight:r,rectWidth:s});<span class="cstat-no" title="statement not covered" ></span>null!==T&amp;&amp;c.add(T),f+=s}<span class="cstat-no" title="statement not covered" ></span>n</span>+=r,a.add(c)}</span>v</span>ar z=<span class="cstat-no" title="statement not covered" >e.globals.yAxisScale[0].result.slice();<span class="cstat-no" title="statement not covered" ></span>e.config.yaxis[0].reversed?z.unshift(""):z.push(""),e.globals.yAxisScale[0].result=z;v</span>ar I=<span class="cstat-no" title="statement not covered" >e.globals.gridHeight/e.globals.series.length;<span class="cstat-no" title="statement not covered" ></span>return e.config.yaxis[0].labels.offsetY=-I/2,a}</span>},{key:"checkColorRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w.config.plotOptions.heatmap;<span class="cstat-no" title="statement not covered" ></span>e.colorScale.ranges.length&gt;0&amp;&amp;e.colorScale.ranges.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >e.from&lt;=0&amp;&amp;(t.negRange=!0)}</span>))}</span>},{key:"determineHeatColor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.globals.series[t][e],</span>s=<span class="cstat-no" title="statement not covered" >i.config.plotOptions.heatmap,</span>r=<span class="cstat-no" title="statement not covered" >s.colorScale.inverse?e:t,</span>n=<span class="cstat-no" title="statement not covered" >i.globals.colors[r],</span>o=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >Math.min.apply(Math,d(i.globals.series[t])),</span>h=<span class="cstat-no" title="statement not covered" >Math.max.apply(Math,d(i.globals.series[t]));<span class="cstat-no" title="statement not covered" ></span>s.distributed||(l=i.globals.minY,h=i.globals.maxY),void 0!==s.colorScale.min&amp;&amp;(l=s.colorScale.min&lt;i.globals.minY?s.colorScale.min:i.globals.minY,h=s.colorScale.max&gt;i.globals.maxY?s.colorScale.max:i.globals.maxY);v</span>ar c=<span class="cstat-no" title="statement not covered" >Math.abs(h)+Math.abs(l),</span>g=<span class="cstat-no" title="statement not covered" >100*a/(0===c?c-1e-6:c);<span class="cstat-no" title="statement not covered" ></span>s.colorScale.ranges.length&gt;0&amp;&amp;s.colorScale.ranges.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(a&gt;=t.from&amp;&amp;a&lt;=t.to){<span class="cstat-no" title="statement not covered" >n=t.color,o=t.foreColor?t.foreColor:null,l=t.from,h=t.to;v</span>ar i=<span class="cstat-no" title="statement not covered" >Math.abs(h)+Math.abs(l);<span class="cstat-no" title="statement not covered" ></span>g=100*a/(0===i?i-1e-6:i)}</span>}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn{color:n,foreColor:o,percent:g}}</span>},{key:"calculateHeatmapDataLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.x,</span>i=<span class="cstat-no" title="statement not covered" >t.y,</span>a=<span class="cstat-no" title="statement not covered" >t.i,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >t.heatColorProps,</span>n=(<span class="cstat-no" title="statement not covered" >t.series,t.rectHeight)</span>,o=<span class="cstat-no" title="statement not covered" >t.rectWidth,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >l.config.dataLabels,</span>c=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>d=<span class="cstat-no" title="statement not covered" >new z(this.ctx),</span>g=<span class="cstat-no" title="statement not covered" >h.formatter,</span>u=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(h.enabled){<span class="cstat-no" title="statement not covered" >u=c.group({class:"apexcharts-data-labels"});v</span>ar f=<span class="cstat-no" title="statement not covered" >h.offsetX,</span>x=<span class="cstat-no" title="statement not covered" >h.offsetY,</span>b=<span class="cstat-no" title="statement not covered" >e+o/2+f,</span>m=<span class="cstat-no" title="statement not covered" >i+n/2+parseFloat(h.style.fontSize)/3+x,</span>v=<span class="cstat-no" title="statement not covered" >g(l.globals.series[a][s],{seriesIndex:a,dataPointIndex:s,w:l});<span class="cstat-no" title="statement not covered" ></span>d.plotDataLabelsText({x:b,y:m,text:v,i:a,j:s,color:r.foreColor,parent:u,dataLabelsConfig:h})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u}</span>},{key:"animateHeatMap",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r){var n=<span class="cstat-no" title="statement not covered" >new f(this.ctx);<span class="cstat-no" title="statement not covered" ></span>n.animateRect(t,{x:e+a/2,y:i+s/2,width:0,height:0},{x:e,y:i,width:a,height:s},r,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.animationCompleted(t)}</span>))}</span>},{key:"animateHeatColor",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >t.attr({fill:e}).animate(a).attr({fill:i})}</span>}]),t}</span>(),</span>wt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"drawYAxisTexts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >s.config.yaxis[0],</span>n=<span class="cstat-no" title="statement not covered" >s.globals.yLabelFormatters[0];<span class="cstat-no" title="statement not covered" ></span>return new p(this.ctx).drawText({x:t+r.labels.offsetX,y:e+r.labels.offsetY,text:n(a,i),textAnchor:"middle",fontSize:r.labels.style.fontSize,fontFamily:r.labels.style.fontFamily,foreColor:Array.isArray(r.labels.style.colors)?r.labels.style.colors[i]:r.labels.style.colors})}</span>}]),t}</span>(),</span>kt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.chartType=this.w.config.chart.type,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&amp;&amp;this.w.config.chart.animations.dynamicAnimation.enabled,this.animBeginArr=[0],this.animDur=0,this.donutDataLabels=this.w.config.plotOptions.pie.donut.labels,this.lineColorArr=void 0!==a.globals.stroke.colors?a.globals.stroke.colors:a.globals.colors,this.defaultSize=a.globals.svgHeight&lt;a.globals.svgWidth?a.globals.gridHeight:a.globals.gridWidth,this.centerY=this.defaultSize/2,this.centerX=a.globals.gridWidth/2,this.fullAngle=360,a.globals.radialSize=this.defaultSize/2.05-a.config.stroke.width-(a.config.chart.sparkline.enabled?0:a.config.chart.dropShadow.blur),this.donutSize=a.globals.radialSize*parseInt(a.config.plotOptions.pie.donut.size,10)/100,this.maxY=0,this.sliceLabels=[],this.sliceSizes=[],this.prevSectorAngleArr=[]}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(this.ret=a.group({class:"apexcharts-pie"}),i.globals.noData)<span class="cstat-no" title="statement not covered" >return this.ret;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >s+=g.negToZero(t[r]);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >a.group();<span class="cstat-no" title="statement not covered" ></span>0===s&amp;&amp;(s=1e-5),t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.maxY=Math.max(e.maxY,t)}</span>)),"polarArea"===this.chartType&amp;&amp;this.drawPolarElements();<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;t.length;l++){var h=<span class="cstat-no" title="statement not covered" >this.fullAngle*g.negToZero(t[l])/s;<span class="cstat-no" title="statement not covered" ></span>n.push(h),"polarArea"===this.chartType?(n[l]=this.fullAngle/t.length,this.sliceSizes.push(i.globals.radialSize*t[l]/this.maxY)):this.sliceSizes.push(i.globals.radialSize)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i.globals.dataChanged){<span class="cstat-no" title="statement not covered" >for(var c,d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;i.globals.previousPaths.length;u++)<span class="cstat-no" title="statement not covered" >d+=g.negToZero(i.globals.previousPaths[u]);<span class="cstat-no" title="statement not covered" >f</span></span>or(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;i.globals.previousPaths.length;f++)<span class="cstat-no" title="statement not covered" >c=this.fullAngle*g.negToZero(i.globals.previousPaths[f])/d,this.prevSectorAngleArr.push(c)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.donutSize&lt;0&amp;&amp;(this.donutSize=0);v</span>ar x=<span class="cstat-no" title="statement not covered" >i.config.plotOptions.pie.customScale,</span>b=<span class="cstat-no" title="statement not covered" >i.globals.gridWidth/2,</span>m=<span class="cstat-no" title="statement not covered" >i.globals.gridHeight/2,</span>v=<span class="cstat-no" title="statement not covered" >b-i.globals.gridWidth/2*x,</span>y=<span class="cstat-no" title="statement not covered" >m-i.globals.gridHeight/2*x;<span class="cstat-no" title="statement not covered" ></span>if("donut"===this.chartType){var w=<span class="cstat-no" title="statement not covered" >a.drawCircle(this.donutSize);<span class="cstat-no" title="statement not covered" ></span>w.attr({cx:this.centerX,cy:this.centerY,fill:i.config.plotOptions.pie.donut.background?i.config.plotOptions.pie.donut.background:"transparent"}),o.add(w)}</span>v</span>ar k=<span class="cstat-no" title="statement not covered" >this.drawArcs(n,t);<span class="cstat-no" title="statement not covered" ></span>if(this.sliceLabels.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >k.add(t)}</span>)),o.attr({transform:"translate(".concat(v,", ").concat(y,") scale(").concat(x,")")}),o.add(k),this.ret.add(o),this.donutDataLabels.show){var A=<span class="cstat-no" title="statement not covered" >this.renderInnerDataLabels(this.donutDataLabels,{hollowSize:this.donutSize,centerX:this.centerX,centerY:this.centerY,opacity:this.donutDataLabels.show,translateX:v,translateY:y});<span class="cstat-no" title="statement not covered" ></span>this.ret.add(A)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.ret}</span>},{key:"drawArcs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >new L(this.ctx),</span>n=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-slices"}),</span>o=<span class="cstat-no" title="statement not covered" >i.config.plotOptions.pie.startAngle%this.fullAngle,</span>l=<span class="cstat-no" title="statement not covered" >o,</span>h=<span class="cstat-no" title="statement not covered" >o,</span>c=<span class="cstat-no" title="statement not covered" >o,</span>d=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>this.strokeWidth=i.config.stroke.show?i.config.stroke.width:0;<span class="cstat-no" title="statement not covered" >f</span>or(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;t.length;f++){var x=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-series apexcharts-pie-series",seriesName:g.escapeString(i.globals.seriesNames[f]),rel:f+1,"data:realIndex":f});<span class="cstat-no" title="statement not covered" ></span>n.add(x),h=d,c=(l=c)+t[f],d=h+this.prevSectorAngleArr[f];v</span>ar b=<span class="cstat-no" title="statement not covered" >c&lt;l?this.fullAngle+c-l:c-l,</span>m=<span class="cstat-no" title="statement not covered" >r.fillPath({seriesNumber:f,size:this.sliceSizes[f],value:e[f]}),</span>v=<span class="cstat-no" title="statement not covered" >this.getChangedPath(h,d),</span>y=<span class="cstat-no" title="statement not covered" >s.drawPath({d:v,stroke:this.lineColorArr instanceof Array?this.lineColorArr[f]:this.lineColorArr,strokeWidth:0,fill:m,fillOpacity:i.config.fill.opacity,classes:"apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(),"-slice-").concat(f)});<span class="cstat-no" title="statement not covered" ></span>if(y.attr({index:0,j:f}),i.config.chart.dropShadow.enabled){var w=<span class="cstat-no" title="statement not covered" >i.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>a.dropShadow(y,w,f)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.addListeners(y,this.donutDataLabels),p.setAttrs(y.node,{"data:angle":b,"data:startAngle":l,"data:strokeWidth":this.strokeWidth,"data:value":e[f]});v</span>ar k=<span class="cstat-no" title="statement not covered" >{x:0,y:0};<span class="cstat-no" title="statement not covered" ></span>"pie"===this.chartType||"polarArea"===this.chartType?k=g.polarToCartesian(this.centerX,this.centerY,i.globals.radialSize/1.25+i.config.plotOptions.pie.dataLabels.offset,(l+b/2)%this.fullAngle):"donut"===this.chartType&amp;&amp;(k=g.polarToCartesian(this.centerX,this.centerY,(i.globals.radialSize+this.donutSize)/2+i.config.plotOptions.pie.dataLabels.offset,(l+b/2)%this.fullAngle)),x.add(y);v</span>ar A=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(!this.initialAnim||i.globals.resized||i.globals.dataChanged?this.animBeginArr.push(0):(0===(A=b/this.fullAngle*i.config.chart.animations.speed)&amp;&amp;(A=1),this.animDur=A+this.animDur,this.animBeginArr.push(this.animDur)),this.dynamicAnim&amp;&amp;i.globals.dataChanged?this.animatePaths(y,{size:this.sliceSizes[f],endAngle:c,startAngle:l,prevStartAngle:h,prevEndAngle:d,animateStartingPos:!0,i:f,animBeginArr:this.animBeginArr,shouldSetPrevPaths:!0,dur:i.config.chart.animations.dynamicAnimation.speed}):this.animatePaths(y,{size:this.sliceSizes[f],endAngle:c,startAngle:l,i:f,totalItems:t.length-1,animBeginArr:this.animBeginArr,dur:A}),i.config.plotOptions.pie.expandOnClick&amp;&amp;"polarArea"!==this.chartType&amp;&amp;y.click(this.pieClicked.bind(this,f)),i.config.dataLabels.enabled){var S=<span class="cstat-no" title="statement not covered" >k.x,</span>C=<span class="cstat-no" title="statement not covered" >k.y,</span>P=<span class="cstat-no" title="statement not covered" >100*b/this.fullAngle+"%";<span class="cstat-no" title="statement not covered" ></span>if(0!==b&amp;&amp;i.config.plotOptions.pie.dataLabels.minAngleToShowLabel&lt;t[f]){var T=<span class="cstat-no" title="statement not covered" >i.config.dataLabels.formatter;<span class="cstat-no" title="statement not covered" ></span>void 0!==T&amp;&amp;(P=T(i.globals.seriesPercent[f][0],{seriesIndex:f,w:i}));v</span>ar z=<span class="cstat-no" title="statement not covered" >i.globals.dataLabels.style.colors[f],</span>I=<span class="cstat-no" title="statement not covered" >s.drawText({x:S,y:C,text:P,textAnchor:"middle",fontSize:i.config.dataLabels.style.fontSize,fontFamily:i.config.dataLabels.style.fontFamily,fontWeight:i.config.dataLabels.style.fontWeight,foreColor:z});<span class="cstat-no" title="statement not covered" ></span>if(i.config.dataLabels.dropShadow.enabled){var M=<span class="cstat-no" title="statement not covered" >i.config.dataLabels.dropShadow;<span class="cstat-no" title="statement not covered" ></span>a.dropShadow(I,M)}<span class="cstat-no" title="statement not covered" ></span>I</span>.node.classList.add("apexcharts-pie-label"),i.config.chart.animations.animate&amp;&amp;!1===i.globals.resized&amp;&amp;(I.node.classList.add("apexcharts-pie-label-delay"),I.node.style.animationDelay=i.config.chart.animations.speed/940+"s"),this.sliceLabels.push(I)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>},{key:"addListeners",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>t.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this,t)),t.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this,t)),t.node.addEventListener("mouseleave",this.revertDataLabelsInner.bind(this,t.node,e)),t.node.addEventListener("mousedown",i.pathMouseDown.bind(this,t)),this.donutDataLabels.total.showAlways||(t.node.addEventListener("mouseenter",this.printDataLabelsInner.bind(this,t.node,e)),t.node.addEventListener("mousedown",this.printDataLabelsInner.bind(this,t.node,e)))}</span>},{key:"animatePaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >e.endAngle&lt;e.startAngle?this.fullAngle+e.endAngle-e.startAngle:e.endAngle-e.startAngle,</span>s=<span class="cstat-no" title="statement not covered" >a,</span>r=<span class="cstat-no" title="statement not covered" >e.startAngle,</span>n=<span class="cstat-no" title="statement not covered" >e.startAngle;<span class="cstat-no" title="statement not covered" ></span>void 0!==e.prevStartAngle&amp;&amp;void 0!==e.prevEndAngle&amp;&amp;(r=e.prevEndAngle,s=e.prevEndAngle&lt;e.prevStartAngle?this.fullAngle+e.prevEndAngle-e.prevStartAngle:e.prevEndAngle-e.prevStartAngle),e.i===i.config.series.length-1&amp;&amp;(a+n&gt;this.fullAngle?e.endAngle=e.endAngle-(a+n):a+n&lt;this.fullAngle&amp;&amp;(e.endAngle=e.endAngle+(this.fullAngle-(a+n)))),a===this.fullAngle&amp;&amp;(a=this.fullAngle-.01),this.animateArc(t,r,n,a,s,e)}</span>},{key:"animateArc",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r){var n,o=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >new f(this.ctx),</span>c=<span class="cstat-no" title="statement not covered" >r.size;<span class="cstat-no" title="statement not covered" ></span>(isNaN(e)||isNaN(s))&amp;&amp;(e=i,s=a,r.dur=0);v</span>ar d=<span class="cstat-no" title="statement not covered" >a,</span>g=<span class="cstat-no" title="statement not covered" >i,</span>u=<span class="cstat-no" title="statement not covered" >e&lt;i?this.fullAngle+e-i:e-i;<span class="cstat-no" title="statement not covered" ></span>l.globals.dataChanged&amp;&amp;r.shouldSetPrevPaths&amp;&amp;r.prevEndAngle&amp;&amp;(n=o.getPiePath({me:o,startAngle:r.prevStartAngle,angle:r.prevEndAngle&lt;r.prevStartAngle?this.fullAngle+r.prevEndAngle-r.prevStartAngle:r.prevEndAngle-r.prevStartAngle,size:c}),t.attr({d:n})),0!==r.dur?t.animate(r.dur,l.globals.easing,r.animBeginArr[r.i]).afterAll((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"pie"!==o.chartType&amp;&amp;"donut"!==o.chartType&amp;&amp;"polarArea"!==o.chartType||this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({"stroke-width":o.strokeWidth}),r.i===l.config.series.length-1&amp;&amp;h.animationCompleted(t)}</span>)).during((<span class="fstat-no" title="function not covered" >fu</span>nction(l){<span class="cstat-no" title="statement not covered" >d=u+(a-u)*l,r.animateStartingPos&amp;&amp;(d=s+(a-s)*l,g=e-s+(i-(e-s))*l),n=o.getPiePath({me:o,startAngle:g,angle:d,size:c}),t.node.setAttribute("data:pathOrig",n),t.attr({d:n})}</span>)):(n=o.getPiePath({me:o,startAngle:g,angle:a,size:c}),r.isTrack||(l.globals.animationEnded=!0),t.node.setAttribute("data:pathOrig",n),t.attr({d:n,"stroke-width":o.strokeWidth}))}</span>},{key:"pieClicked",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this.sliceSizes[t]+(i.config.plotOptions.pie.expandOnClick?4:0),</span>s=<span class="cstat-no" title="statement not covered" >i.globals.dom.Paper.select(".apexcharts-".concat(this.chartType.toLowerCase(),"-slice-").concat(t)).members[0];<span class="cstat-no" title="statement not covered" ></span>if("true"!==s.attr("data:pieClicked")){var r=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");<span class="cstat-no" title="statement not covered" ></span>Array.prototype.forEach.call(r,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.setAttribute("data:pieClicked","false");v</span>ar e=<span class="cstat-no" title="statement not covered" >t.getAttribute("data:pathOrig");<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("d",e)}</span>)),s.attr("data:pieClicked","true");v</span>ar n=<span class="cstat-no" title="statement not covered" >parseInt(s.attr("data:startAngle"),10),</span>o=<span class="cstat-no" title="statement not covered" >parseInt(s.attr("data:angle"),10);<span class="cstat-no" title="statement not covered" ></span>e=this.getPiePath({me:this,startAngle:n,angle:o,size:a}),360!==o&amp;&amp;s.plot(e)}</span>else{<span class="cstat-no" title="statement not covered" >s.attr({"data:pieClicked":"false"}),this.revertDataLabelsInner(s.node,this.donutDataLabels);v</span>ar l=<span class="cstat-no" title="statement not covered" >s.attr("data:pathOrig");<span class="cstat-no" title="statement not covered" ></span>s.attr({d:l})}</span>}</span>},{key:"getChangedPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return this.dynamicAnim&amp;&amp;this.w.globals.dataChanged&amp;&amp;(i=this.getPiePath({me:this,startAngle:t,angle:e-t,size:this.size})),i}</span>},{key:"getPiePath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.me,</span>i=<span class="cstat-no" title="statement not covered" >t.startAngle,</span>a=<span class="cstat-no" title="statement not covered" >t.angle,</span>s=<span class="cstat-no" title="statement not covered" >t.size,</span>r=<span class="cstat-no" title="statement not covered" >i,</span>n=<span class="cstat-no" title="statement not covered" >Math.PI*(r-90)/180,</span>o=<span class="cstat-no" title="statement not covered" >a+i;<span class="cstat-no" title="statement not covered" ></span>Math.ceil(o)&gt;=this.fullAngle+this.w.config.plotOptions.pie.startAngle%this.fullAngle&amp;&amp;(o=this.fullAngle+this.w.config.plotOptions.pie.startAngle%this.fullAngle-.01),Math.ceil(o)&gt;this.fullAngle&amp;&amp;(o-=this.fullAngle);v</span>ar l=<span class="cstat-no" title="statement not covered" >Math.PI*(o-90)/180,</span>h=<span class="cstat-no" title="statement not covered" >e.centerX+s*Math.cos(n),</span>c=<span class="cstat-no" title="statement not covered" >e.centerY+s*Math.sin(n),</span>d=<span class="cstat-no" title="statement not covered" >e.centerX+s*Math.cos(l),</span>u=<span class="cstat-no" title="statement not covered" >e.centerY+s*Math.sin(l),</span>f=<span class="cstat-no" title="statement not covered" >g.polarToCartesian(e.centerX,e.centerY,e.donutSize,o),</span>p=<span class="cstat-no" title="statement not covered" >g.polarToCartesian(e.centerX,e.centerY,e.donutSize,r),</span>x=<span class="cstat-no" title="statement not covered" >a&gt;180?1:0,</span>b=<span class="cstat-no" title="statement not covered" >["M",h,c,"A",s,s,0,x,1,d,u];<span class="cstat-no" title="statement not covered" ></span>return"donut"===e.chartType?[].concat(b,["L",f.x,f.y,"A",e.donutSize,e.donutSize,0,x,0,p.x,p.y,"L",h,c,"z"]).join(" "):"pie"===e.chartType||"polarArea"===e.chartType?[].concat(b,["L",e.centerX,e.centerY,"L",h,c]).join(" "):[].concat(b).join(" ")}</span>},{key:"drawPolarElements",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >new j(this.ctx),</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >new wt(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >i.group(),</span>r=<span class="cstat-no" title="statement not covered" >i.group(),</span>n=<span class="cstat-no" title="statement not covered" >void 0===t.config.yaxis[0].max&amp;&amp;void 0===t.config.yaxis[0].min,</span>o=<span class="cstat-no" title="statement not covered" >e.niceScale(0,Math.ceil(this.maxY),t.config.yaxis[0].tickAmount,0,n),</span>l=<span class="cstat-no" title="statement not covered" >o.result.reverse(),</span>h=<span class="cstat-no" title="statement not covered" >o.result.length;<span class="cstat-no" title="statement not covered" ></span>this.maxY=o.niceMax;<span class="cstat-no" title="statement not covered" >f</span>or(var c=<span class="cstat-no" title="statement not covered" >t.globals.radialSize,</span>d=<span class="cstat-no" title="statement not covered" >c/(h-1),</span>g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;h-1;g++){var u=<span class="cstat-no" title="statement not covered" >i.drawCircle(c);<span class="cstat-no" title="statement not covered" ></span>if(u.attr({cx:this.centerX,cy:this.centerY,fill:"none","stroke-width":t.config.plotOptions.polarArea.rings.strokeWidth,stroke:t.config.plotOptions.polarArea.rings.strokeColor}),t.config.yaxis[0].show){var f=<span class="cstat-no" title="statement not covered" >a.drawYAxisTexts(this.centerX,this.centerY-c+parseInt(t.config.yaxis[0].labels.style.fontSize,10)/2,g,l[g]);<span class="cstat-no" title="statement not covered" ></span>r.add(f)}<span class="cstat-no" title="statement not covered" ></span>s</span>.add(u),c-=d}<span class="cstat-no" title="statement not covered" ></span>t</span>his.ret.add(s),this.ret.add(r)}</span>},{key:"renderInnerDataLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >a.group({class:"apexcharts-datalabels-group",transform:"translate(".concat(e.translateX?e.translateX:0,", ").concat(e.translateY?e.translateY:0,") scale(").concat(i.config.plotOptions.pie.customScale,")")}),</span>r=<span class="cstat-no" title="statement not covered" >t.total.show;<span class="cstat-no" title="statement not covered" ></span>s.node.style.opacity=e.opacity;v</span>ar n,o,l=<span class="cstat-no" title="statement not covered" >e.centerX,</span>h=<span class="cstat-no" title="statement not covered" >e.centerY;<span class="cstat-no" title="statement not covered" ></span>n=void 0===t.name.color?i.globals.colors[0]:t.name.color;v</span>ar c=<span class="cstat-no" title="statement not covered" >t.name.fontSize,</span>d=<span class="cstat-no" title="statement not covered" >t.name.fontFamily,</span>g=<span class="cstat-no" title="statement not covered" >t.value.fontWeight;<span class="cstat-no" title="statement not covered" ></span>o=void 0===t.value.color?i.config.chart.foreColor:t.value.color;v</span>ar u=<span class="cstat-no" title="statement not covered" >t.value.formatter,</span>f=<span class="cstat-no" title="statement not covered" >"",</span>x=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(r?(n=t.total.color,c=t.total.fontSize,d=t.total.fontFamily,g=t.total.fontWeight,x=t.total.label,f=t.total.formatter(i)):1===i.globals.series.length&amp;&amp;(f=u(i.globals.series[0],i),x=i.globals.seriesNames[0]),x&amp;&amp;(x=t.name.formatter(x,t.total.show,i)),t.name.show){var b=<span class="cstat-no" title="statement not covered" >a.drawText({x:l,y:h+parseFloat(t.name.offsetY),text:x,textAnchor:"middle",foreColor:n,fontSize:c,fontWeight:g,fontFamily:d});<span class="cstat-no" title="statement not covered" ></span>b.node.classList.add("apexcharts-datalabel-label"),s.add(b)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.value.show){var m=<span class="cstat-no" title="statement not covered" >t.name.show?parseFloat(t.value.offsetY)+16:t.value.offsetY,</span>v=<span class="cstat-no" title="statement not covered" >a.drawText({x:l,y:h+m,text:f,textAnchor:"middle",foreColor:o,fontWeight:t.value.fontWeight,fontSize:t.value.fontSize,fontFamily:t.value.fontFamily});<span class="cstat-no" title="statement not covered" ></span>v.node.classList.add("apexcharts-datalabel-value"),s.add(v)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>},{key:"printInnerLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s,r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>a?s=void 0===t.name.color?r.globals.colors[parseInt(a.parentNode.getAttribute("rel"),10)-1]:t.name.color:r.globals.series.length&gt;1&amp;&amp;t.total.show&amp;&amp;(s=t.total.color);v</span>ar n=<span class="cstat-no" title="statement not covered" >r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),</span>o=<span class="cstat-no" title="statement not covered" >r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");<span class="cstat-no" title="statement not covered" ></span>i=(0,t.value.formatter)(i,r),a||"function"!=typeof t.total.formatter||(i=t.total.formatter(r));v</span>ar l=<span class="cstat-no" title="statement not covered" >e===t.total.label;<span class="cstat-no" title="statement not covered" ></span>e=t.name.formatter(e,l,r),null!==n&amp;&amp;(n.textContent=e),null!==o&amp;&amp;(o.textContent=i),null!==n&amp;&amp;(n.style.fill=s)}</span>},{key:"printDataLabelsInner",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >t.getAttribute("data:value"),</span>s=<span class="cstat-no" title="statement not covered" >i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"),10)-1];<span class="cstat-no" title="statement not covered" ></span>i.globals.series.length&gt;1&amp;&amp;this.printInnerLabels(e,s,a,t);v</span>ar r=<span class="cstat-no" title="statement not covered" >i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");<span class="cstat-no" title="statement not covered" ></span>null!==r&amp;&amp;(r.style.opacity=1)}</span>},{key:"revertDataLabelsInner",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),</span>n=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.makeSliceOut,</span>s=<span class="cstat-no" title="statement not covered" >t.printLabel;<span class="cstat-no" title="statement not covered" ></span>Array.prototype.forEach.call(o,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"true"===t.getAttribute("data:pieClicked")&amp;&amp;(i&amp;&amp;(n=!0),s&amp;&amp;a.printDataLabelsInner(t,e))}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>if(l({makeSliceOut:!0,printLabel:!1}),e.total.show&amp;&amp;s.globals.series.length&gt;1)<span class="cstat-no" title="statement not covered" >n&amp;&amp;!e.total.showAlways?l({makeSliceOut:!1,printLabel:!0}):this.printInnerLabels(e,e.total.label,e.total.formatter(s));e</span>lse <span class="cstat-no" title="statement not covered" >if(l({makeSliceOut:!1,printLabel:!0}),!n)<span class="cstat-no" title="statement not covered" >if(s.globals.selectedDataPoints.length&amp;&amp;s.globals.series.length&gt;1)<span class="cstat-no" title="statement not covered" >if(s.globals.selectedDataPoints[0].length&gt;0){var h=<span class="cstat-no" title="statement not covered" >s.globals.selectedDataPoints[0],</span>c=<span class="cstat-no" title="statement not covered" >s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(),"-slice-").concat(h));<span class="cstat-no" title="statement not covered" ></span>this.printDataLabelsInner(c,e)}</span>else <span class="cstat-no" title="statement not covered" >r&amp;&amp;s.globals.selectedDataPoints.length&amp;&amp;0===s.globals.selectedDataPoints[0].length&amp;&amp;(r.style.opacity=0);e</span></span>lse <span class="cstat-no" title="statement not covered" >r&amp;&amp;s.globals.series.length&gt;1&amp;&amp;(r.style.opacity=0)}</span></span></span></span>}]),t}</span>(),</span>At=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.chartType=this.w.config.chart.type,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&amp;&amp;this.w.config.chart.animations.dynamicAnimation.enabled,this.animDur=0;v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>this.graphics=new p(this.ctx),this.lineColorArr=void 0!==a.globals.stroke.colors?a.globals.stroke.colors:a.globals.colors,this.defaultSize=a.globals.svgHeight&lt;a.globals.svgWidth?a.globals.gridHeight+1.5*a.globals.goldenPadding:a.globals.gridWidth,this.maxValue=this.w.globals.maxY,this.minValue=this.w.globals.minY,this.polygons=a.config.plotOptions.radar.polygons;v</span>ar s=<span class="cstat-no" title="statement not covered" >a.globals.labels.slice().sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.length-t.length}</span>))[0],</span>r=<span class="cstat-no" title="statement not covered" >this.graphics.getTextRects(s,a.config.xaxis.labels.style.fontSize);<span class="cstat-no" title="statement not covered" ></span>this.strokeWidth=a.config.stroke.show?a.config.stroke.width:0,this.size=this.defaultSize/2.1-this.strokeWidth-a.config.chart.dropShadow.blur,a.config.xaxis.labels.show&amp;&amp;(this.size=this.size-r.width/1.75),void 0!==a.config.plotOptions.radar.size&amp;&amp;(this.size=a.config.plotOptions.radar.size),this.dataRadiusOfPercent=[],this.dataRadius=[],this.angleArr=[],this.yaxisLabelsTextsPos=[]}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >new L(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >new z(this.ctx);<span class="cstat-no" title="statement not covered" ></span>t.length&amp;&amp;(this.dataPointsLen=t[i.globals.maxValsInArrayIndex].length),this.disAngle=2*Math.PI/this.dataPointsLen;v</span>ar o=<span class="cstat-no" title="statement not covered" >i.globals.gridWidth/2,</span>l=<span class="cstat-no" title="statement not covered" >i.globals.gridHeight/2,</span>h=<span class="cstat-no" title="statement not covered" >o+i.config.plotOptions.radar.offsetX,</span>c=<span class="cstat-no" title="statement not covered" >l+i.config.plotOptions.radar.offsetY,</span>d=<span class="cstat-no" title="statement not covered" >this.graphics.group({class:"apexcharts-radar-series apexcharts-plot-series",transform:"translate(".concat(h||0,", ").concat(c||0,")")}),</span>f=<span class="cstat-no" title="statement not covered" >[],</span>p=<span class="cstat-no" title="statement not covered" >null,</span>x=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.yaxisLabels=this.graphics.group({class:"apexcharts-yaxis"}),t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,o){var l=<span class="cstat-no" title="statement not covered" >t.length===i.globals.dataPoints,</span>h=<span class="cstat-no" title="statement not covered" >e.graphics.group().attr({class:"apexcharts-series","data:longestSeries":l,seriesName:g.escapeString(i.globals.seriesNames[o]),rel:o+1,"data:realIndex":o});<span class="cstat-no" title="statement not covered" ></span>e.dataRadiusOfPercent[o]=[],e.dataRadius[o]=[],e.angleArr[o]=[],t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var a=<span class="cstat-no" title="statement not covered" >Math.abs(e.maxValue-e.minValue);<span class="cstat-no" title="statement not covered" ></span>t+=Math.abs(e.minValue),e.dataRadiusOfPercent[o][i]=t/a,e.dataRadius[o][i]=e.dataRadiusOfPercent[o][i]*e.size,e.angleArr[o][i]=i*e.disAngle}</span>)),f=e.getDataPointsPos(e.dataRadius[o],e.angleArr[o]);v</span>ar c=<span class="cstat-no" title="statement not covered" >e.createPaths(f,{x:0,y:0});<span class="cstat-no" title="statement not covered" ></span>p=e.graphics.group({class:"apexcharts-series-markers-wrap apexcharts-element-hidden"}),x=e.graphics.group({class:"apexcharts-datalabels","data:realIndex":o}),i.globals.delayedElements.push({el:p.node,index:o});v</span>ar d=<span class="cstat-no" title="statement not covered" >{i:o,realIndex:o,animationDelay:o,initialSpeed:i.config.chart.animations.speed,dataChangeSpeed:i.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-radar",shouldClipToGrid:!1,bindEventsOnPaths:!1,stroke:i.globals.stroke.colors[o],strokeLineCap:i.config.stroke.lineCap},</span>b=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>i.globals.previousPaths.length&gt;0&amp;&amp;(b=e.getPreviousPath(o));<span class="cstat-no" title="statement not covered" >f</span>or(var m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;c.linePathsTo.length;m++){var v=<span class="cstat-no" title="statement not covered" >e.graphics.renderPaths(n({},d,{pathFrom:null===b?c.linePathsFrom[m]:b,pathTo:c.linePathsTo[m],strokeWidth:Array.isArray(e.strokeWidth)?e.strokeWidth[o]:e.strokeWidth,fill:"none",drawShadow:!1}));<span class="cstat-no" title="statement not covered" ></span>h.add(v);v</span>ar y=<span class="cstat-no" title="statement not covered" >a.fillPath({seriesNumber:o}),</span>w=<span class="cstat-no" title="statement not covered" >e.graphics.renderPaths(n({},d,{pathFrom:null===b?c.areaPathsFrom[m]:b,pathTo:c.areaPathsTo[m],strokeWidth:0,fill:y,drawShadow:!1}));<span class="cstat-no" title="statement not covered" ></span>if(i.config.chart.dropShadow.enabled){var k=<span class="cstat-no" title="statement not covered" >new u(e.ctx),</span>A=<span class="cstat-no" title="statement not covered" >i.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>k.dropShadow(w,Object.assign({},A,{noUserSpaceOnUse:!0}),o)}<span class="cstat-no" title="statement not covered" ></span>h</span>.add(w)}<span class="cstat-no" title="statement not covered" ></span>t</span>.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,a){var s=<span class="cstat-no" title="statement not covered" >new P(e.ctx).getMarkerConfig("apexcharts-marker",o,a),</span>l=<span class="cstat-no" title="statement not covered" >e.graphics.drawMarker(f[a].x,f[a].y,s);<span class="cstat-no" title="statement not covered" ></span>l.attr("rel",a),l.attr("j",a),l.attr("index",o),l.node.setAttribute("default-marker-size",s.pSize);v</span>ar c=<span class="cstat-no" title="statement not covered" >e.graphics.group({class:"apexcharts-series-markers"});<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;c.add(l),p.add(c),h.add(p);v</span>ar d=<span class="cstat-no" title="statement not covered" >i.config.dataLabels;<span class="cstat-no" title="statement not covered" ></span>if(d.enabled){var g=<span class="cstat-no" title="statement not covered" >d.formatter(i.globals.series[o][a],{seriesIndex:o,dataPointIndex:a,w:i});<span class="cstat-no" title="statement not covered" ></span>r.plotDataLabelsText({x:f[a].x,y:f[a].y,text:g,textAnchor:"middle",i:o,j:o,parent:x,offsetCorrection:!1,dataLabelsConfig:n({},d)})}<span class="cstat-no" title="statement not covered" ></span>h</span>.add(x)}</span>)),s.push(h)}</span>)),this.drawPolygons({parent:d}),i.config.xaxis.labels.show){var b=<span class="cstat-no" title="statement not covered" >this.drawXAxisTexts();<span class="cstat-no" title="statement not covered" ></span>d.add(b)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn d.add(this.yaxisLabels),s.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >d.add(t)}</span>)),d}</span>},{key:"drawPolygons",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >t.parent,</span>s=<span class="cstat-no" title="statement not covered" >new wt(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >i.globals.yAxisScale[0].result.reverse(),</span>n=<span class="cstat-no" title="statement not covered" >r.length,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >this.size/(n-1),</span>h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;n;h++)<span class="cstat-no" title="statement not covered" >o[h]=l*h;<span class="cstat-no" title="statement not covered" >o</span></span>.reverse();v</span>ar c=<span class="cstat-no" title="statement not covered" >[],</span>d=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var a=<span class="cstat-no" title="statement not covered" >e.getPolygonPos(t),</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>a.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >if(0===i){var r=<span class="cstat-no" title="statement not covered" >e.graphics.drawLine(t.x,t.y,0,0,Array.isArray(e.polygons.connectorColors)?e.polygons.connectorColors[a]:e.polygons.connectorColors);<span class="cstat-no" title="statement not covered" ></span>d.push(r)}<span class="cstat-no" title="statement not covered" ></span>0</span>===a&amp;&amp;e.yaxisLabelsTextsPos.push({x:t.x,y:t.y}),s+=t.x+","+t.y+" "}</span>)),c.push(s)}</span>)),c.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){var r=<span class="cstat-no" title="statement not covered" >e.polygons.strokeColors,</span>n=<span class="cstat-no" title="statement not covered" >e.polygons.strokeWidth,</span>o=<span class="cstat-no" title="statement not covered" >e.graphics.drawPolygon(t,Array.isArray(r)?r[s]:r,Array.isArray(n)?n[s]:n,i.globals.radarPolygons.fill.colors[s]);<span class="cstat-no" title="statement not covered" ></span>a.add(o)}</span>)),d.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.add(t)}</span>)),i.config.yaxis[0].show&amp;&amp;this.yaxisLabelsTextsPos.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var a=<span class="cstat-no" title="statement not covered" >s.drawYAxisTexts(t.x,t.y,i,r[i]);<span class="cstat-no" title="statement not covered" ></span>e.yaxisLabels.add(a)}</span>))}</span>},{key:"drawXAxisTexts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >e.config.xaxis.labels,</span>a=<span class="cstat-no" title="statement not covered" >this.graphics.group({class:"apexcharts-xaxis"}),</span>s=<span class="cstat-no" title="statement not covered" >this.getPolygonPos(this.size);<span class="cstat-no" title="statement not covered" ></span>return e.globals.labels.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r,o){var l=<span class="cstat-no" title="statement not covered" >e.config.xaxis.labels.formatter,</span>h=<span class="cstat-no" title="statement not covered" >new z(t.ctx);<span class="cstat-no" title="statement not covered" ></span>if(s[o]){var c=<span class="cstat-no" title="statement not covered" >t.getTextPos(s[o],t.size),</span>d=<span class="cstat-no" title="statement not covered" >l(r,{seriesIndex:-1,dataPointIndex:o,w:e});<span class="cstat-no" title="statement not covered" ></span>h.plotDataLabelsText({x:c.newX,y:c.newY,text:d,textAnchor:c.textAnchor,i:o,j:o,parent:a,color:i.style.colors[o]?i.style.colors[o]:"#a8a8a8",dataLabelsConfig:n({textAnchor:c.textAnchor,dropShadow:{enabled:!1}},i),offsetCorrection:!1})}</span>}</span>)),a}</span>},{key:"createPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t.length){<span class="cstat-no" title="statement not covered" >s=[this.graphics.move(e.x,e.y)],n=[this.graphics.move(e.x,e.y)];v</span>ar o=<span class="cstat-no" title="statement not covered" >this.graphics.move(t[0].x,t[0].y),</span>l=<span class="cstat-no" title="statement not covered" >this.graphics.move(t[0].x,t[0].y);<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,a){<span class="cstat-no" title="statement not covered" >o+=i.graphics.line(e.x,e.y),l+=i.graphics.line(e.x,e.y),a===t.length-1&amp;&amp;(o+="Z",l+="Z")}</span>)),a.push(o),r.push(l)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{linePathsFrom:s,linePathsTo:a,areaPathsFrom:n,areaPathsTo:r}}</span>},{key:"getTextPos",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >"middle",</span>a=<span class="cstat-no" title="statement not covered" >t.x,</span>s=<span class="cstat-no" title="statement not covered" >t.y;<span class="cstat-no" title="statement not covered" ></span>return Math.abs(t.x)&gt;=10?t.x&gt;0?(i="start",a+=10):t.x&lt;0&amp;&amp;(i="end",a-=10):i="middle",Math.abs(t.y)&gt;=e-10&amp;&amp;(t.y&lt;0?s-=10:t.y&gt;0&amp;&amp;(s+=10)),{textAnchor:i,newX:a,newY:s}}</span>},{key:"getPreviousPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >null,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;e.globals.previousPaths.length;a++){var s=<span class="cstat-no" title="statement not covered" >e.globals.previousPaths[a];<span class="cstat-no" title="statement not covered" ></span>s.paths.length&gt;0&amp;&amp;parseInt(s.realIndex,10)===parseInt(t,10)&amp;&amp;void 0!==e.globals.previousPaths[a].paths[0]&amp;&amp;(i=e.globals.previousPaths[a].paths[0].d)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>},{key:"getDataPointsPos",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:this.dataPointsLen;<span class="cstat-no" title="statement not covered" ></span>t=t||[],e=e||[];<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i;s++){var r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>r.x=t[s]*Math.sin(e[s]),r.y=-t[s]*Math.cos(e[s]),a.push(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>},{key:"getPolygonPos",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >2*Math.PI/this.dataPointsLen,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;this.dataPointsLen;a++){var s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>s.x=t*Math.sin(a*i),s.y=-t*Math.cos(a*i),e.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>}]),t}</span>(),</span>St=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >i(</span>t){var a;<span class="cstat-no" title="statement not covered" >e(this,i),(a=c(this,l(i).call(this,t))).ctx=t,a.w=t.w,a.animBeginArr=[0],a.animDur=0;v</span>ar s=<span class="cstat-no" title="statement not covered" >a.w;<span class="cstat-no" title="statement not covered" ></span>return a.startAngle=s.config.plotOptions.radialBar.startAngle,a.endAngle=s.config.plotOptions.radialBar.endAngle,a.totalAngle=Math.abs(s.config.plotOptions.radialBar.endAngle-s.config.plotOptions.radialBar.startAngle),a.trackStartAngle=s.config.plotOptions.radialBar.track.startAngle,a.trackEndAngle=s.config.plotOptions.radialBar.track.endAngle,a.radialDataLabels=s.config.plotOptions.radialBar.dataLabels,a.trackStartAngle||(a.trackStartAngle=a.startAngle),a.trackEndAngle||(a.trackEndAngle=a.endAngle),360===a.endAngle&amp;&amp;(a.endAngle=359.99),a.margin=parseInt(s.config.plotOptions.radialBar.track.margin,10),a}<span class="cstat-no" title="statement not covered" ></span>return o(i,t),a(i,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-radialbar"});<span class="cstat-no" title="statement not covered" ></span>if(e.globals.noData)<span class="cstat-no" title="statement not covered" >return a;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >i.group(),</span>r=<span class="cstat-no" title="statement not covered" >this.defaultSize/2,</span>n=<span class="cstat-no" title="statement not covered" >e.globals.gridWidth/2,</span>o=<span class="cstat-no" title="statement not covered" >this.defaultSize/2.05;<span class="cstat-no" title="statement not covered" ></span>e.config.chart.sparkline.enabled||(o=o-e.config.stroke.width-e.config.chart.dropShadow.blur);v</span>ar l=<span class="cstat-no" title="statement not covered" >e.globals.fill.colors;<span class="cstat-no" title="statement not covered" ></span>if(e.config.plotOptions.radialBar.track.show){var h=<span class="cstat-no" title="statement not covered" >this.drawTracks({size:o,centerX:n,centerY:r,colorArr:l,series:t});<span class="cstat-no" title="statement not covered" ></span>s.add(h)}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >this.drawArcs({size:o,centerX:n,centerY:r,colorArr:l,series:t}),</span>d=<span class="cstat-no" title="statement not covered" >360;<span class="cstat-no" title="statement not covered" ></span>e.config.plotOptions.radialBar.startAngle&lt;0&amp;&amp;(d=this.totalAngle);v</span>ar g=<span class="cstat-no" title="statement not covered" >(360-d)/360;<span class="cstat-no" title="statement not covered" ></span>if(e.globals.radialSize=o-o*g,this.radialDataLabels.value.show){var u=<span class="cstat-no" title="statement not covered" >Math.max(this.radialDataLabels.value.offsetY,this.radialDataLabels.name.offsetY);<span class="cstat-no" title="statement not covered" ></span>e.globals.radialSize+=u*g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.add(c.g),"front"===e.config.plotOptions.radialBar.hollow.position&amp;&amp;(c.g.add(c.elHollow),c.dataLabels&amp;&amp;c.g.add(c.dataLabels)),a.add(s),a}</span>},{key:"drawTracks",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-tracks"}),</span>s=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >new L(this.ctx),</span>n=<span class="cstat-no" title="statement not covered" >this.getStrokeWidth(t);<span class="cstat-no" title="statement not covered" ></span>t.size=t.size-n/2;<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.series.length;o++){var l=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-radialbar-track apexcharts-track"});<span class="cstat-no" title="statement not covered" ></span>a.add(l),l.attr({rel:o+1}),t.size=t.size-n-this.margin;v</span>ar h=<span class="cstat-no" title="statement not covered" >e.config.plotOptions.radialBar.track,</span>c=<span class="cstat-no" title="statement not covered" >r.fillPath({seriesNumber:0,size:t.size,fillColors:Array.isArray(h.background)?h.background[o]:h.background,solid:!0}),</span>d=<span class="cstat-no" title="statement not covered" >this.trackStartAngle,</span>g=<span class="cstat-no" title="statement not covered" >this.trackEndAngle;<span class="cstat-no" title="statement not covered" ></span>Math.abs(g)+Math.abs(d)&gt;=360&amp;&amp;(g=360-Math.abs(this.startAngle)-.1);v</span>ar f=<span class="cstat-no" title="statement not covered" >i.drawPath({d:"",stroke:c,strokeWidth:n*parseInt(h.strokeWidth,10)/100,fill:"none",strokeOpacity:h.opacity,classes:"apexcharts-radialbar-area"});<span class="cstat-no" title="statement not covered" ></span>if(h.dropShadow.enabled){var x=<span class="cstat-no" title="statement not covered" >h.dropShadow;<span class="cstat-no" title="statement not covered" ></span>s.dropShadow(f,x)}<span class="cstat-no" title="statement not covered" ></span>l</span>.add(f),f.attr("id","apexcharts-radialbarTrack-"+o),this.animatePaths(f,{centerX:t.centerX,centerY:t.centerY,endAngle:g,startAngle:d,size:t.size,i:o,totalItems:2,animBeginArr:0,dur:0,isTrack:!0,easing:e.globals.easing})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>},{key:"drawArcs",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w,</span>i=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >new L(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >new u(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >i.group(),</span>n=<span class="cstat-no" title="statement not covered" >this.getStrokeWidth(t);<span class="cstat-no" title="statement not covered" ></span>t.size=t.size-n/2;v</span>ar o=<span class="cstat-no" title="statement not covered" >e.config.plotOptions.radialBar.hollow.background,</span>l=<span class="cstat-no" title="statement not covered" >t.size-n*t.series.length-this.margin*t.series.length-n*parseInt(e.config.plotOptions.radialBar.track.strokeWidth,10)/100/2,</span>h=<span class="cstat-no" title="statement not covered" >l-e.config.plotOptions.radialBar.hollow.margin;<span class="cstat-no" title="statement not covered" ></span>void 0!==e.config.plotOptions.radialBar.hollow.image&amp;&amp;(o=this.drawHollowImage(t,r,l,o));v</span>ar c=<span class="cstat-no" title="statement not covered" >this.drawHollow({size:h,centerX:t.centerX,centerY:t.centerY,fill:o||"transparent"});<span class="cstat-no" title="statement not covered" ></span>if(e.config.plotOptions.radialBar.hollow.dropShadow.enabled){var d=<span class="cstat-no" title="statement not covered" >e.config.plotOptions.radialBar.hollow.dropShadow;<span class="cstat-no" title="statement not covered" ></span>s.dropShadow(c,d)}</span>v</span>ar f=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>!this.radialDataLabels.total.show&amp;&amp;e.globals.series.length&gt;1&amp;&amp;(f=0);v</span>ar x=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>this.radialDataLabels.show&amp;&amp;(x=this.renderInnerDataLabels(this.radialDataLabels,{hollowSize:l,centerX:t.centerX,centerY:t.centerY,opacity:f})),"back"===e.config.plotOptions.radialBar.hollow.position&amp;&amp;(r.add(c),x&amp;&amp;r.add(x));v</span>ar b=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>e.config.plotOptions.radialBar.inverseOrder&amp;&amp;(b=!0);<span class="cstat-no" title="statement not covered" >f</span>or(var m=<span class="cstat-no" title="statement not covered" >b?t.series.length-1:0;</span>b?m&gt;=0:m&lt;t.series.length;b?m--:m++){var v=<span class="cstat-no" title="statement not covered" >i.group({class:"apexcharts-series apexcharts-radial-series",seriesName:g.escapeString(e.globals.seriesNames[m])});<span class="cstat-no" title="statement not covered" ></span>r.add(v),v.attr({rel:m+1,"data:realIndex":m}),this.ctx.series.addCollapsedClassToSeries(v,m),t.size=t.size-n-this.margin;v</span>ar y=<span class="cstat-no" title="statement not covered" >a.fillPath({seriesNumber:m,size:t.size,value:t.series[m]}),</span>w=<span class="cstat-no" title="statement not covered" >this.startAngle,</span>k=<span class="cstat-no" title="statement not covered" >void 0,</span>A=<span class="cstat-no" title="statement not covered" >g.negToZero(t.series[m]&gt;100?100:t.series[m])/100,</span>S=<span class="cstat-no" title="statement not covered" >Math.round(this.totalAngle*A)+this.startAngle,</span>C=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>e.globals.dataChanged&amp;&amp;(k=this.startAngle,C=Math.round(this.totalAngle*g.negToZero(e.globals.previousPaths[m])/100)+k),Math.abs(S)+Math.abs(w)&gt;=360&amp;&amp;(S-=.01),Math.abs(C)+Math.abs(k)&gt;=360&amp;&amp;(C-=.01);v</span>ar P=<span class="cstat-no" title="statement not covered" >S-w,</span>T=<span class="cstat-no" title="statement not covered" >Array.isArray(e.config.stroke.dashArray)?e.config.stroke.dashArray[m]:e.config.stroke.dashArray,</span>z=<span class="cstat-no" title="statement not covered" >i.drawPath({d:"",stroke:y,strokeWidth:n,fill:"none",fillOpacity:e.config.fill.opacity,classes:"apexcharts-radialbar-area apexcharts-radialbar-slice-"+m,strokeDashArray:T});<span class="cstat-no" title="statement not covered" ></span>if(p.setAttrs(z.node,{"data:angle":P,"data:value":t.series[m]}),e.config.chart.dropShadow.enabled){var I=<span class="cstat-no" title="statement not covered" >e.config.chart.dropShadow;<span class="cstat-no" title="statement not covered" ></span>s.dropShadow(z,I,m)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.addListeners(z,this.radialDataLabels),v.add(z),z.attr({index:0,j:m});v</span>ar M=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>!this.initialAnim||e.globals.resized||e.globals.dataChanged||(M=(S-w)/360*e.config.chart.animations.speed,this.animDur=M/(1.2*t.series.length)+this.animDur,this.animBeginArr.push(this.animDur)),e.globals.dataChanged&amp;&amp;(M=(S-w)/360*e.config.chart.animations.dynamicAnimation.speed,this.animDur=M/(1.2*t.series.length)+this.animDur,this.animBeginArr.push(this.animDur)),this.animatePaths(z,{centerX:t.centerX,centerY:t.centerY,endAngle:S,startAngle:w,prevEndAngle:C,prevStartAngle:k,size:t.size,i:m,totalItems:2,animBeginArr:this.animBeginArr,dur:M,shouldSetPrevPaths:!0,easing:e.globals.easing})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{g:r,elHollow:c,dataLabels:x}}</span>},{key:"drawHollow",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new p(this.ctx).drawCircle(2*t.size);<span class="cstat-no" title="statement not covered" ></span>return e.attr({class:"apexcharts-radialbar-hollow",cx:t.centerX,cy:t.centerY,r:t.size,fill:t.fill}),e}</span>},{key:"drawHollowImage",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >new L(this.ctx),</span>n=<span class="cstat-no" title="statement not covered" >g.randomId(),</span>o=<span class="cstat-no" title="statement not covered" >s.config.plotOptions.radialBar.hollow.image;<span class="cstat-no" title="statement not covered" ></span>if(s.config.plotOptions.radialBar.hollow.imageClipped)<span class="cstat-no" title="statement not covered" >r.clippedImgArea({width:i,height:i,image:o,patternID:"pattern".concat(s.globals.cuid).concat(n)}),a="url(#pattern".concat(s.globals.cuid).concat(n,")");e</span>lse{var l=<span class="cstat-no" title="statement not covered" >s.config.plotOptions.radialBar.hollow.imageWidth,</span>h=<span class="cstat-no" title="statement not covered" >s.config.plotOptions.radialBar.hollow.imageHeight;<span class="cstat-no" title="statement not covered" ></span>if(void 0===l&amp;&amp;void 0===h){var c=<span class="cstat-no" title="statement not covered" >s.globals.dom.Paper.image(o).loaded((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.move(t.centerX-e.width/2+s.config.plotOptions.radialBar.hollow.imageOffsetX,t.centerY-e.height/2+s.config.plotOptions.radialBar.hollow.imageOffsetY)}</span>));<span class="cstat-no" title="statement not covered" ></span>e.add(c)}</span>else{var d=<span class="cstat-no" title="statement not covered" >s.globals.dom.Paper.image(o).loaded((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.move(t.centerX-l/2+s.config.plotOptions.radialBar.hollow.imageOffsetX,t.centerY-h/2+s.config.plotOptions.radialBar.hollow.imageOffsetY),this.size(l,h)}</span>));<span class="cstat-no" title="statement not covered" ></span>e.add(d)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>},{key:"getStrokeWidth",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return t.size*(100-parseInt(e.config.plotOptions.radialBar.hollow.size,10))/100/(t.series.length+1)-this.margin}</span>}]),i}</span>(kt),</span>Ct=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.w=i.w,this.lineCtx=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"sameValueSeriesFix",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if("line"===i.config.chart.type&amp;&amp;("gradient"===i.config.fill.type||"gradient"===i.config.fill.type[t])&amp;&amp;new m(this.lineCtx.ctx,i).seriesHaveSameValues(t)){var a=<span class="cstat-no" title="statement not covered" >e[t].slice();<span class="cstat-no" title="statement not covered" ></span>a[a.length-1]=a[a.length-1]+1e-6,e[t]=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>},{key:"calculatePoints",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.series,</span>i=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>a=<span class="cstat-no" title="statement not covered" >t.x,</span>s=<span class="cstat-no" title="statement not covered" >t.y,</span>r=<span class="cstat-no" title="statement not covered" >t.i,</span>n=<span class="cstat-no" title="statement not covered" >t.j,</span>o=<span class="cstat-no" title="statement not covered" >t.prevY,</span>l=<span class="cstat-no" title="statement not covered" >this.w,</span>h=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0===n){var d=<span class="cstat-no" title="statement not covered" >this.lineCtx.categoryAxisCorrection+l.config.markers.offsetX;<span class="cstat-no" title="statement not covered" ></span>l.globals.isXNumeric&amp;&amp;(d=(l.globals.seriesX[i][0]-l.globals.minX)/this.lineCtx.xRatio+l.config.markers.offsetX),h.push(d),c.push(g.isNumber(e[r][0])?o+l.config.markers.offsetY:null),h.push(a+l.config.markers.offsetX),c.push(g.isNumber(e[r][n+1])?s+l.config.markers.offsetY:null)}</span>else <span class="cstat-no" title="statement not covered" >h.push(a+l.config.markers.offsetX),c.push(g.isNumber(e[r][n+1])?s+l.config.markers.offsetY:null);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{x:h,y:c}}</span>},{key:"checkPreviousPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.pathFromLine,</span>i=<span class="cstat-no" title="statement not covered" >t.pathFromArea,</span>a=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>s=<span class="cstat-no" title="statement not covered" >this.w,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;s.globals.previousPaths.length;r++){var n=<span class="cstat-no" title="statement not covered" >s.globals.previousPaths[r];<span class="cstat-no" title="statement not covered" ></span>("line"===n.type||"area"===n.type)&amp;&amp;n.paths.length&gt;0&amp;&amp;parseInt(n.realIndex,10)===parseInt(a,10)&amp;&amp;("line"===n.type?(this.lineCtx.appendPathFrom=!1,e=s.globals.previousPaths[r].paths[0].d):"area"===n.type&amp;&amp;(this.lineCtx.appendPathFrom=!1,i=s.globals.previousPaths[r].paths[0].d,s.config.stroke.show&amp;&amp;s.globals.previousPaths[r].paths[1]&amp;&amp;(e=s.globals.previousPaths[r].paths[1].d)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{pathFromLine:e,pathFromArea:i}}</span>},{key:"determineFirstPrevY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.i,</span>i=<span class="cstat-no" title="statement not covered" >t.series,</span>a=<span class="cstat-no" title="statement not covered" >t.prevY,</span>s=<span class="cstat-no" title="statement not covered" >t.lineYPosition,</span>r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i[e][0])<span class="cstat-no" title="statement not covered" >a=(s=r.config.chart.stacked&amp;&amp;e&gt;0?this.lineCtx.prevSeriesY[e-1][0]:this.lineCtx.zeroY)-i[e][0]/this.lineCtx.yRatio[this.lineCtx.yaxisIndex]+2*(this.lineCtx.isReversed?i[e][0]/this.lineCtx.yRatio[this.lineCtx.yaxisIndex]:0);e</span>lse <span class="cstat-no" title="statement not covered" >if(r.config.chart.stacked&amp;&amp;e&gt;0&amp;&amp;void 0===i[e][0])<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >e-1;</span>n&gt;=0;n--)<span class="cstat-no" title="statement not covered" >if(null!==i[n][0]&amp;&amp;void 0!==i[n][0]){<span class="cstat-no" title="statement not covered" >a=s=this.lineCtx.prevSeriesY[n][0];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn{prevY:a,lineYPosition:s}}</span>}]),t}</span>(),</span>Lt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a,s){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.xyRatios=a,this.pointsChart=!("bubble"!==this.w.config.chart.type&amp;&amp;"scatter"!==this.w.config.chart.type)||s,this.scatter=new T(this.ctx),this.noNegatives=this.w.globals.minX===Number.MAX_VALUE,this.lineHelpers=new Ct(this),this.markers=new P(this.ctx),this.prevSeriesY=[],this.categoryAxisCorrection=0,this.yaxisIndex=0}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"draw",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >a.globals.comboCharts?e:a.config.chart.type,</span>n=<span class="cstat-no" title="statement not covered" >s.group({class:"apexcharts-".concat(r,"-series apexcharts-plot-series")}),</span>o=<span class="cstat-no" title="statement not covered" >new m(this.ctx,a);<span class="cstat-no" title="statement not covered" ></span>this.yRatio=this.xyRatios.yRatio,this.zRatio=this.xyRatios.zRatio,this.xRatio=this.xyRatios.xRatio,this.baseLineY=this.xyRatios.baseLineY,t=o.getLogSeries(t),this.yRatio=o.getLogYRatios(this.yRatio);<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;t.length;h++){<span class="cstat-no" title="statement not covered" >t=this.lineHelpers.sameValueSeriesFix(h,t);v</span>ar c=<span class="cstat-no" title="statement not covered" >a.globals.comboCharts?i[h]:h;<span class="cstat-no" title="statement not covered" ></span>this._initSerieVariables(t,h,c);v</span>ar d=<span class="cstat-no" title="statement not covered" >[],</span>g=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >a.globals.padHorizontal+this.categoryAxisCorrection;<span class="cstat-no" title="statement not covered" ></span>this.ctx.series.addCollapsedClassToSeries(this.elSeries,c),a.globals.isXNumeric&amp;&amp;a.globals.seriesX.length&gt;0&amp;&amp;(u=(a.globals.seriesX[c][0]-a.globals.minX)/this.xRatio),g.push(u);v</span>ar f,x=<span class="cstat-no" title="statement not covered" >u,</span>b=<span class="cstat-no" title="statement not covered" >x,</span>v=<span class="cstat-no" title="statement not covered" >this.zeroY;<span class="cstat-no" title="statement not covered" ></span>v=this.lineHelpers.determineFirstPrevY({i:h,series:t,prevY:v,lineYPosition:0}).prevY,d.push(v),f=v;v</span>ar y=<span class="cstat-no" title="statement not covered" >this._calculatePathsFrom({series:t,i:h,realIndex:c,prevX:b,prevY:v}),</span>w=<span class="cstat-no" title="statement not covered" >this._iterateOverDataPoints({series:t,realIndex:c,i:h,x:u,y:1,pX:x,pY:f,pathsFrom:y,linePaths:[],areaPaths:[],seriesIndex:i,lineYPosition:0,xArrj:g,yArrj:d});<span class="cstat-no" title="statement not covered" ></span>this._handlePaths({type:r,realIndex:c,i:h,paths:w}),this.elSeries.add(this.elPointsMain),this.elSeries.add(this.elDataLabelsWrap),l.push(this.elSeries)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var k=<span class="cstat-no" title="statement not covered" >l.length;</span>k&gt;0;k--)<span class="cstat-no" title="statement not covered" >n.add(l[k-1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>},{key:"_initSerieVariables",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.w,</span>s=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.xDivision=a.globals.gridWidth/(a.globals.dataPoints-("on"===a.config.xaxis.tickPlacement?1:0)),this.strokeWidth=Array.isArray(a.config.stroke.width)?a.config.stroke.width[i]:a.config.stroke.width,this.yRatio.length&gt;1&amp;&amp;(this.yaxisIndex=i),this.isReversed=a.config.yaxis[this.yaxisIndex]&amp;&amp;a.config.yaxis[this.yaxisIndex].reversed,this.zeroY=a.globals.gridHeight-this.baseLineY[this.yaxisIndex]-(this.isReversed?a.globals.gridHeight:0)+(this.isReversed?2*this.baseLineY[this.yaxisIndex]:0),this.areaBottomY=this.zeroY,this.zeroY&gt;a.globals.gridHeight&amp;&amp;(this.areaBottomY=a.globals.gridHeight),this.categoryAxisCorrection=this.xDivision/2,this.elSeries=s.group({class:"apexcharts-series",seriesName:g.escapeString(a.globals.seriesNames[i])}),this.elPointsMain=s.group({class:"apexcharts-series-markers-wrap","data:realIndex":i}),this.elDataLabelsWrap=s.group({class:"apexcharts-datalabels","data:realIndex":i});v</span>ar r=<span class="cstat-no" title="statement not covered" >t[e].length===a.globals.dataPoints;<span class="cstat-no" title="statement not covered" ></span>this.elSeries.attr({"data:longestSeries":r,rel:e+1,"data:realIndex":i}),this.appendPathFrom=!0}</span>},{key:"_calculatePathsFrom",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i,a,s,r=<span class="cstat-no" title="statement not covered" >t.series,</span>n=<span class="cstat-no" title="statement not covered" >t.i,</span>o=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>l=<span class="cstat-no" title="statement not covered" >t.prevX,</span>h=<span class="cstat-no" title="statement not covered" >t.prevY,</span>c=<span class="cstat-no" title="statement not covered" >this.w,</span>d=<span class="cstat-no" title="statement not covered" >new p(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(null===r[n][0]){<span class="cstat-no" title="statement not covered" >for(var g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;r[n].length;g++)<span class="cstat-no" title="statement not covered" >if(null!==r[n][g]){<span class="cstat-no" title="statement not covered" >l=this.xDivision*g,h=this.zeroY-r[n][g]/this.yRatio[this.yaxisIndex],e=d.move(l,h),i=d.move(l,this.areaBottomY);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >e=d.move(l,h),i=d.move(l,this.areaBottomY)+d.line(l,h);<span class="cstat-no" title="statement not covered" >i</span></span>f(a=d.move(-1,this.zeroY)+d.line(-1,this.zeroY),s=d.move(-1,this.zeroY)+d.line(-1,this.zeroY),c.globals.previousPaths.length&gt;0){var u=<span class="cstat-no" title="statement not covered" >this.lineHelpers.checkPreviousPaths({pathFromLine:a,pathFromArea:s,realIndex:o});<span class="cstat-no" title="statement not covered" ></span>a=u.pathFromLine,s=u.pathFromArea}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{prevX:l,prevY:h,linePath:e,areaPath:i,pathFromLine:a,pathFromArea:s}}</span>},{key:"_handlePaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.type,</span>i=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>a=<span class="cstat-no" title="statement not covered" >t.i,</span>s=<span class="cstat-no" title="statement not covered" >t.paths,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>o=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>l=<span class="cstat-no" title="statement not covered" >new L(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.prevSeriesY.push(s.yArrj),r.globals.seriesXvalues[i]=s.xArrj,r.globals.seriesYvalues[i]=s.yArrj,this.pointsChart||r.globals.delayedElements.push({el:this.elPointsMain.node,index:i});v</span>ar h=<span class="cstat-no" title="statement not covered" >{i:a,realIndex:i,animationDelay:a,initialSpeed:r.config.chart.animations.speed,dataChangeSpeed:r.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-".concat(e)};<span class="cstat-no" title="statement not covered" ></span>if("area"===e)<span class="cstat-no" title="statement not covered" >for(var c=<span class="cstat-no" title="statement not covered" >l.fillPath({seriesNumber:i}),</span>d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;s.areaPaths.length;d++){var g=<span class="cstat-no" title="statement not covered" >o.renderPaths(n({},h,{pathFrom:s.pathFromArea,pathTo:s.areaPaths[d],stroke:"none",strokeWidth:0,strokeLineCap:null,fill:c}));<span class="cstat-no" title="statement not covered" ></span>this.elSeries.add(g)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(r.config.stroke.show&amp;&amp;!this.pointsChart){var u=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>u="line"===e?l.fillPath({seriesNumber:i,i:a}):r.globals.stroke.colors[i];<span class="cstat-no" title="statement not covered" >f</span>or(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;s.linePaths.length;f++){var x=<span class="cstat-no" title="statement not covered" >o.renderPaths(n({},h,{pathFrom:s.pathFromLine,pathTo:s.linePaths[f],stroke:u,strokeWidth:this.strokeWidth,strokeLineCap:r.config.stroke.lineCap,fill:"none"}));<span class="cstat-no" title="statement not covered" ></span>this.elSeries.add(x)}</span>}</span>}</span>},{key:"_iterateOverDataPoints",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.series,</span>i=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>a=<span class="cstat-no" title="statement not covered" >t.i,</span>s=<span class="cstat-no" title="statement not covered" >t.x,</span>r=<span class="cstat-no" title="statement not covered" >t.y,</span>n=<span class="cstat-no" title="statement not covered" >t.pX,</span>o=<span class="cstat-no" title="statement not covered" >t.pY,</span>l=<span class="cstat-no" title="statement not covered" >t.pathsFrom,</span>h=<span class="cstat-no" title="statement not covered" >t.linePaths,</span>c=<span class="cstat-no" title="statement not covered" >t.areaPaths,</span>d=<span class="cstat-no" title="statement not covered" >t.seriesIndex,</span>u=<span class="cstat-no" title="statement not covered" >t.lineYPosition,</span>f=<span class="cstat-no" title="statement not covered" >t.xArrj,</span>x=<span class="cstat-no" title="statement not covered" >t.yArrj,</span>b=<span class="cstat-no" title="statement not covered" >this.w,</span>m=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>v=<span class="cstat-no" title="statement not covered" >this.yRatio,</span>y=<span class="cstat-no" title="statement not covered" >l.prevY,</span>w=<span class="cstat-no" title="statement not covered" >l.linePath,</span>k=<span class="cstat-no" title="statement not covered" >l.areaPath,</span>A=<span class="cstat-no" title="statement not covered" >l.pathFromLine,</span>S=<span class="cstat-no" title="statement not covered" >l.pathFromArea,</span>C=<span class="cstat-no" title="statement not covered" >g.isNumber(b.globals.minYArr[i])?b.globals.minYArr[i]:b.globals.minY,</span>L=<span class="cstat-no" title="statement not covered" >b.globals.dataPoints&gt;1?b.globals.dataPoints-1:b.globals.dataPoints,</span>P=<span class="cstat-no" title="statement not covered" >0;</span>P&lt;L;P++){var T=<span class="cstat-no" title="statement not covered" >void 0===e[a][P+1]||null===e[a][P+1];<span class="cstat-no" title="statement not covered" ></span>if(b.globals.isXNumeric){var z=<span class="cstat-no" title="statement not covered" >b.globals.seriesX[i][P+1];<span class="cstat-no" title="statement not covered" ></span>void 0===b.globals.seriesX[i][P+1]&amp;&amp;(z=b.globals.seriesX[i][L-1]),s=(z-b.globals.minX)/this.xRatio}</span>else <span class="cstat-no" title="statement not covered" >s+=this.xDivision;<span class="cstat-no" title="statement not covered" >i</span></span>f(b.config.chart.stacked)<span class="cstat-no" title="statement not covered" >if(a&gt;0&amp;&amp;b.globals.collapsedSeries.length&lt;b.config.series.length-1){<span class="cstat-no" title="statement not covered" >u=this.prevSeriesY[<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;b.globals.series.length;i++)<span class="cstat-no" title="statement not covered" >if(b.globals.collapsedSeriesIndices.indexOf(t)&gt;-1){<span class="cstat-no" title="statement not covered" >e--;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e&gt;=0?e:0}</span>(a-1)][P+1]}</span>else <span class="cstat-no" title="statement not covered" >u=this.zeroY;e</span></span>lse <span class="cstat-no" title="statement not covered" >u=this.zeroY;<span class="cstat-no" title="statement not covered" >r</span></span>=T?u-C/v[this.yaxisIndex]+2*(this.isReversed?C/v[this.yaxisIndex]:0):u-e[a][P+1]/v[this.yaxisIndex]+2*(this.isReversed?e[a][P+1]/v[this.yaxisIndex]:0),f.push(s),x.push(r);v</span>ar I=<span class="cstat-no" title="statement not covered" >this.lineHelpers.calculatePoints({series:e,x:s,y:r,realIndex:i,i:a,j:P,prevY:y}),</span>M=<span class="cstat-no" title="statement not covered" >this._createPaths({series:e,i:a,realIndex:i,j:P,x:s,y:r,pX:n,pY:o,linePath:w,areaPath:k,linePaths:h,areaPaths:c,seriesIndex:d});<span class="cstat-no" title="statement not covered" ></span>c=M.areaPaths,h=M.linePaths,n=M.pX,o=M.pY,k=M.areaPath,w=M.linePath,this.appendPathFrom&amp;&amp;(A+=m.line(s,this.zeroY),S+=m.line(s,this.zeroY)),this.handleNullDataPoints(e,I,a,P,i),this._handleMarkersAndLabels({pointsPos:I,series:e,x:s,y:r,prevY:y,i:a,j:P,realIndex:i})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{yArrj:x,xArrj:f,pathFromArea:S,areaPaths:c,pathFromLine:A,linePaths:h}}</span>},{key:"_handleMarkersAndLabels",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.pointsPos,</span>i=(<span class="cstat-no" title="statement not covered" >t.series,t.x,t.y,t.prevY,t.i)</span>,a=<span class="cstat-no" title="statement not covered" >t.j,</span>s=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>r=<span class="cstat-no" title="statement not covered" >this.w,</span>n=<span class="cstat-no" title="statement not covered" >new z(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(this.pointsChart)<span class="cstat-no" title="statement not covered" >this.scatter.draw(this.elSeries,a,{realIndex:s,pointsPos:e,zRatio:this.zRatio,elParent:this.elPointsMain});e</span>lse{<span class="cstat-no" title="statement not covered" >r.globals.series[i].length&gt;1&amp;&amp;this.elPointsMain.node.classList.add("apexcharts-element-hidden");v</span>ar o=<span class="cstat-no" title="statement not covered" >this.markers.plotChartMarkers(e,s,a+1);<span class="cstat-no" title="statement not covered" ></span>null!==o&amp;&amp;this.elPointsMain.add(o)}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >n.drawDataLabel(e,s,a+1,null);<span class="cstat-no" title="statement not covered" ></span>null!==l&amp;&amp;this.elDataLabelsWrap.add(l)}</span>},{key:"_createPaths",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.series,</span>i=<span class="cstat-no" title="statement not covered" >t.i,</span>a=<span class="cstat-no" title="statement not covered" >t.realIndex,</span>s=<span class="cstat-no" title="statement not covered" >t.j,</span>r=<span class="cstat-no" title="statement not covered" >t.x,</span>n=<span class="cstat-no" title="statement not covered" >t.y,</span>o=<span class="cstat-no" title="statement not covered" >t.pX,</span>l=<span class="cstat-no" title="statement not covered" >t.pY,</span>h=<span class="cstat-no" title="statement not covered" >t.linePath,</span>c=<span class="cstat-no" title="statement not covered" >t.areaPath,</span>d=<span class="cstat-no" title="statement not covered" >t.linePaths,</span>g=<span class="cstat-no" title="statement not covered" >t.areaPaths,</span>u=<span class="cstat-no" title="statement not covered" >t.seriesIndex,</span>f=<span class="cstat-no" title="statement not covered" >this.w,</span>x=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>b=<span class="cstat-no" title="statement not covered" >f.config.stroke.curve,</span>m=<span class="cstat-no" title="statement not covered" >this.areaBottomY;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(f.config.stroke.curve)&amp;&amp;(b=Array.isArray(u)?f.config.stroke.curve[u[i]]:f.config.stroke.curve[i]),"smooth"===b){var v=<span class="cstat-no" title="statement not covered" >.35*(r-o);<span class="cstat-no" title="statement not covered" ></span>f.globals.hasNullValues?(null!==e[i][s]&amp;&amp;(null!==e[i][s+1]?(h=x.move(o,l)+x.curve(o+v,l,r-v,n,r+1,n),c=x.move(o+1,l)+x.curve(o+v,l,r-v,n,r+1,n)+x.line(r,m)+x.line(o,m)+"z"):(h=x.move(o,l),c=x.move(o,l)+"z")),d.push(h),g.push(c)):(h+=x.curve(o+v,l,r-v,n,r,n),c+=x.curve(o+v,l,r-v,n,r,n)),o=r,l=n,s===e[i].length-2&amp;&amp;(c=c+x.curve(o,l,r,n,r,m)+x.move(r,n)+"z",f.globals.hasNullValues||(d.push(h),g.push(c)))}</span>else{<span class="cstat-no" title="statement not covered" >if(null===e[i][s+1]){<span class="cstat-no" title="statement not covered" >h+=x.move(r,n);v</span>ar y=<span class="cstat-no" title="statement not covered" >f.globals.isXNumeric?(f.globals.seriesX[a][s]-f.globals.minX)/this.xRatio:r-this.xDivision;<span class="cstat-no" title="statement not covered" ></span>c=c+x.line(y,m)+x.move(r,n)+"z"}<span class="cstat-no" title="statement not covered" ></span>n</span>ull===e[i][s]&amp;&amp;(h+=x.move(r,n),c+=x.move(r,m)),"stepline"===b?(h=h+x.line(r,null,"H")+x.line(null,n,"V"),c=c+x.line(r,null,"H")+x.line(null,n,"V")):"straight"===b&amp;&amp;(h+=x.line(r,n),c+=x.line(r,n)),s===e[i].length-2&amp;&amp;(c=c+x.line(r,m)+x.move(r,n)+"z",d.push(h),g.push(c))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{linePaths:d,areaPaths:g,pX:o,pY:l,linePath:h,areaPath:c}}</span>},{key:"handleNullDataPoints",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){var r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(null===t[i][a]&amp;&amp;r.config.markers.showNullDataPoints||1===t[i].length){var n=<span class="cstat-no" title="statement not covered" >this.markers.plotChartMarkers(e,s,a+1,this.strokeWidth-r.config.markers.strokeWidth/2,!0);<span class="cstat-no" title="statement not covered" ></span>null!==n&amp;&amp;this.elPointsMain.add(n)}</span>}</span>}]),t}</span>(),</span>Pt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w,this.timeScaleArray=[],this.utc=this.w.config.xaxis.labels.datetimeUTC}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"calculateTimeScaleTicks",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(a.globals.allSeriesCollapsed)<span class="cstat-no" title="statement not covered" >return a.globals.labels=[],a.globals.timescaleLabels=[],[];v</span></span>ar s=<span class="cstat-no" title="statement not covered" >new Y(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >(e-t)/864e5;<span class="cstat-no" title="statement not covered" ></span>this.determineInterval(r),a.globals.disableZoomIn=!1,a.globals.disableZoomOut=!1,r&lt;.005?a.globals.disableZoomIn=!0:r&gt;5e4&amp;&amp;(a.globals.disableZoomOut=!0);v</span>ar o=<span class="cstat-no" title="statement not covered" >s.getTimeUnitsfromTimestamp(t,e,this.utc),</span>l=<span class="cstat-no" title="statement not covered" >a.globals.gridWidth/r,</span>h=<span class="cstat-no" title="statement not covered" >l/24,</span>c=<span class="cstat-no" title="statement not covered" >h/60,</span>d=<span class="cstat-no" title="statement not covered" >Math.floor(24*r),</span>g=<span class="cstat-no" title="statement not covered" >Math.floor(24*r*60),</span>u=<span class="cstat-no" title="statement not covered" >Math.floor(r),</span>f=<span class="cstat-no" title="statement not covered" >Math.floor(r/30),</span>p=<span class="cstat-no" title="statement not covered" >Math.floor(r/365),</span>x=<span class="cstat-no" title="statement not covered" >{minMinute:o.minMinute,minHour:o.minHour,minDate:o.minDate,minMonth:o.minMonth,minYear:o.minYear},</span>b=<span class="cstat-no" title="statement not covered" >{firstVal:x,currentMinute:x.minMinute,currentHour:x.minHour,currentMonthDate:x.minDate,currentDate:x.minDate,currentMonth:x.minMonth,currentYear:x.minYear,daysWidthOnXAxis:l,hoursWidthOnXAxis:h,minutesWidthOnXAxis:c,numberOfMinutes:g,numberOfHours:d,numberOfDays:u,numberOfMonths:f,numberOfYears:p};<span class="cstat-no" title="statement not covered" ></span>switch(this.tickInterval){case"years":<span class="cstat-no" title="statement not covered" >this.generateYearScale(b);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"months":case"half_year":<span class="cstat-no" title="statement not covered" >this.generateMonthScale(b);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"months_days":case"months_fortnight":case"days":case"week_days":<span class="cstat-no" title="statement not covered" >this.generateDayScale(b);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"hours":<span class="cstat-no" title="statement not covered" >this.generateHourScale(b);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"minutes":<span class="cstat-no" title="statement not covered" >this.generateMinuteScale(b)}</span>v</span>ar m=<span class="cstat-no" title="statement not covered" >this.timeScaleArray.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >{position:t.position,unit:t.unit,year:t.year,day:t.day?t.day:1,hour:t.hour?t.hour:0,month:t.month+1};<span class="cstat-no" title="statement not covered" ></span>return"month"===t.unit?n({},e,{day:1,value:t.value+1}):"day"===t.unit||"hour"===t.unit?n({},e,{value:t.value}):"minute"===t.unit?n({},e,{value:t.value,minute:t.value}):t}</span>));<span class="cstat-no" title="statement not covered" ></span>return m.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >1,</span>s=<span class="cstat-no" title="statement not covered" >Math.ceil(a.globals.gridWidth/120),</span>r=<span class="cstat-no" title="statement not covered" >t.value;<span class="cstat-no" title="statement not covered" ></span>void 0!==a.config.xaxis.tickAmount&amp;&amp;(s=a.config.xaxis.tickAmount),m.length&gt;s&amp;&amp;(e=Math.floor(m.length/s));v</span>ar n=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>switch(i.tickInterval){case"years":<span class="cstat-no" title="statement not covered" >"year"===t.unit&amp;&amp;(n=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"half_year":<span class="cstat-no" title="statement not covered" >e=7,"year"===t.unit&amp;&amp;(n=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"months":<span class="cstat-no" title="statement not covered" >e=1,"year"===t.unit&amp;&amp;(n=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"months_fortnight":<span class="cstat-no" title="statement not covered" >e=15,"year"!==t.unit&amp;&amp;"month"!==t.unit||(n=!0),30===r&amp;&amp;(o=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"months_days":<span class="cstat-no" title="statement not covered" >e=10,"month"===t.unit&amp;&amp;(n=!0),30===r&amp;&amp;(o=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"week_days":<span class="cstat-no" title="statement not covered" >e=8,"month"===t.unit&amp;&amp;(n=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"days":<span class="cstat-no" title="statement not covered" >e=1,"month"===t.unit&amp;&amp;(n=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"hours":<span class="cstat-no" title="statement not covered" >"day"===t.unit&amp;&amp;(n=!0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"minutes":<span class="cstat-no" title="statement not covered" >r%5!=0&amp;&amp;(o=!0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("minutes"===i.tickInterval||"hours"===i.tickInterval){<span class="cstat-no" title="statement not covered" >if(!o)<span class="cstat-no" title="statement not covered" >return!0}</span></span>else <span class="cstat-no" title="statement not covered" >if((r%e==0||n)&amp;&amp;!o)<span class="cstat-no" title="statement not covered" >return!0}</span></span></span>))}</span>},{key:"recalcDimensionsBasedOnFormat",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >this.formatDates(t),</span>s=<span class="cstat-no" title="statement not covered" >this.removeOverlappingTS(a);<span class="cstat-no" title="statement not covered" ></span>i.globals.timescaleLabels=s.slice(),new nt(this.ctx).plotCoords()}</span>},{key:"determineInterval",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(!0){case t&gt;1825:<span class="cstat-no" title="statement not covered" >this.tickInterval="years";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;800&amp;&amp;t&lt;=1825:<span class="cstat-no" title="statement not covered" >this.tickInterval="half_year";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;180&amp;&amp;t&lt;=800:<span class="cstat-no" title="statement not covered" >this.tickInterval="months";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;90&amp;&amp;t&lt;=180:<span class="cstat-no" title="statement not covered" >this.tickInterval="months_fortnight";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;60&amp;&amp;t&lt;=90:<span class="cstat-no" title="statement not covered" >this.tickInterval="months_days";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;30&amp;&amp;t&lt;=60:<span class="cstat-no" title="statement not covered" >this.tickInterval="week_days";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;2&amp;&amp;t&lt;=30:<span class="cstat-no" title="statement not covered" >this.tickInterval="days";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&gt;.1&amp;&amp;t&lt;=2:<span class="cstat-no" title="statement not covered" >this.tickInterval="hours";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase t&lt;.1:<span class="cstat-no" title="statement not covered" >this.tickInterval="minutes";<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.tickInterval="days"}</span>}</span>},{key:"generateYearScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.firstVal,</span>i=<span class="cstat-no" title="statement not covered" >t.currentMonth,</span>a=<span class="cstat-no" title="statement not covered" >t.currentYear,</span>s=<span class="cstat-no" title="statement not covered" >t.daysWidthOnXAxis,</span>r=<span class="cstat-no" title="statement not covered" >t.numberOfYears,</span>n=<span class="cstat-no" title="statement not covered" >e.minYear,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >new Y(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(e.minDate&gt;1||e.minMonth&gt;0){var h=<span class="cstat-no" title="statement not covered" >l.determineRemainingDaysOfYear(e.minYear,e.minMonth,e.minDate);<span class="cstat-no" title="statement not covered" ></span>o=(l.determineDaysOfYear(e.minYear)-h+1)*s,n=e.minYear+1,this.timeScaleArray.push({position:o,value:n,unit:"year",year:n,month:g.monthMod(i+1)})}</span>else <span class="cstat-no" title="statement not covered" >1===e.minDate&amp;&amp;0===e.minMonth&amp;&amp;this.timeScaleArray.push({position:o,value:n,unit:"year",year:a,month:g.monthMod(i+1)});<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=<span class="cstat-no" title="statement not covered" >n,</span>d=<span class="cstat-no" title="statement not covered" >o,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;r;u++)<span class="cstat-no" title="statement not covered" >c++,d=l.determineDaysOfYear(c-1)*s+d,this.timeScaleArray.push({position:d,value:c,unit:"year",year:c,month:1})}</span></span>},{key:"generateMonthScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.firstVal,</span>i=<span class="cstat-no" title="statement not covered" >t.currentMonthDate,</span>a=<span class="cstat-no" title="statement not covered" >t.currentMonth,</span>s=<span class="cstat-no" title="statement not covered" >t.currentYear,</span>r=<span class="cstat-no" title="statement not covered" >t.daysWidthOnXAxis,</span>n=<span class="cstat-no" title="statement not covered" >t.numberOfMonths,</span>o=<span class="cstat-no" title="statement not covered" >a,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >new Y(this.ctx),</span>c=<span class="cstat-no" title="statement not covered" >"month",</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e.minDate&gt;1){<span class="cstat-no" title="statement not covered" >l=(h.determineDaysOfMonths(a+1,e.minYear)-i+1)*r,o=g.monthMod(a+1);v</span>ar u=<span class="cstat-no" title="statement not covered" >s+d,</span>f=<span class="cstat-no" title="statement not covered" >g.monthMod(o),</span>p=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>0===o&amp;&amp;(c="year",p=u,f=1,u+=d+=1),this.timeScaleArray.push({position:l,value:p,unit:c,year:u,month:f})}</span>else <span class="cstat-no" title="statement not covered" >this.timeScaleArray.push({position:l,value:o,unit:c,year:s,month:g.monthMod(a)});<span class="cstat-no" title="statement not covered" >f</span></span>or(var x=<span class="cstat-no" title="statement not covered" >o+1,</span>b=<span class="cstat-no" title="statement not covered" >l,</span>m=<span class="cstat-no" title="statement not covered" >0,</span>v=<span class="cstat-no" title="statement not covered" >1;</span>m&lt;n;m++,v++){<span class="cstat-no" title="statement not covered" >0===(x=g.monthMod(x))?(c="year",d+=1):c="month";v</span>ar y=<span class="cstat-no" title="statement not covered" >this._getYear(s,x,d);<span class="cstat-no" title="statement not covered" ></span>b=h.determineDaysOfMonths(x,y)*r+b;v</span>ar w=<span class="cstat-no" title="statement not covered" >0===x?y:x;<span class="cstat-no" title="statement not covered" ></span>this.timeScaleArray.push({position:b,value:w,unit:c,year:y,month:0===x?1:x}),x++}</span>}</span>},{key:"generateDayScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.firstVal,</span>i=<span class="cstat-no" title="statement not covered" >t.currentMonth,</span>a=<span class="cstat-no" title="statement not covered" >t.currentYear,</span>s=<span class="cstat-no" title="statement not covered" >t.hoursWidthOnXAxis,</span>r=<span class="cstat-no" title="statement not covered" >t.numberOfDays,</span>n=<span class="cstat-no" title="statement not covered" >new Y(this.ctx),</span>o=<span class="cstat-no" title="statement not covered" >"day",</span>l=<span class="cstat-no" title="statement not covered" >e.minDate+1,</span>h=<span class="cstat-no" title="statement not covered" >l,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return t&gt;n.determineDaysOfMonths(e+1,i)?(h=1,o="month",u=e+=1,e):e}</span>,</span>d=<span class="cstat-no" title="statement not covered" >(24-e.minHour)*s,</span>u=<span class="cstat-no" title="statement not covered" >l,</span>f=<span class="cstat-no" title="statement not covered" >c(h,i,a);<span class="cstat-no" title="statement not covered" ></span>0===e.minHour&amp;&amp;1===e.minDate&amp;&amp;(d=0,u=g.monthMod(e.minMonth),o="month",h=e.minDate,r++),this.timeScaleArray.push({position:d,value:u,unit:o,year:this._getYear(a,f,0),month:g.monthMod(f),day:h});<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >d,</span>x=<span class="cstat-no" title="statement not covered" >0;</span>x&lt;r;x++){<span class="cstat-no" title="statement not covered" >o="day",f=c(h+=1,f,this._getYear(a,f,0));v</span>ar b=<span class="cstat-no" title="statement not covered" >this._getYear(a,f,0);<span class="cstat-no" title="statement not covered" ></span>p=24*s+p;v</span>ar m=<span class="cstat-no" title="statement not covered" >1===h?g.monthMod(f):h;<span class="cstat-no" title="statement not covered" ></span>this.timeScaleArray.push({position:p,value:m,unit:o,year:b,month:g.monthMod(f),day:m})}</span>}</span>},{key:"generateHourScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.firstVal,</span>i=<span class="cstat-no" title="statement not covered" >t.currentDate,</span>a=<span class="cstat-no" title="statement not covered" >t.currentMonth,</span>s=<span class="cstat-no" title="statement not covered" >t.currentYear,</span>r=<span class="cstat-no" title="statement not covered" >t.minutesWidthOnXAxis,</span>n=<span class="cstat-no" title="statement not covered" >t.numberOfHours,</span>o=<span class="cstat-no" title="statement not covered" >new Y(this.ctx),</span>l=<span class="cstat-no" title="statement not covered" >"hour",</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t&gt;o.determineDaysOfMonths(e+1,s)&amp;&amp;(x=1,e+=1),{month:e,date:x}}</span>,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t&gt;o.determineDaysOfMonths(e+1,s)?e+=1:e}</span>,</span>d=<span class="cstat-no" title="statement not covered" >60-e.minMinute,</span>u=<span class="cstat-no" title="statement not covered" >d*r,</span>f=<span class="cstat-no" title="statement not covered" >e.minHour+1,</span>p=<span class="cstat-no" title="statement not covered" >f+1;<span class="cstat-no" title="statement not covered" ></span>60===d&amp;&amp;(u=0,p=(f=e.minHour)+1);v</span>ar x=<span class="cstat-no" title="statement not covered" >i,</span>b=<span class="cstat-no" title="statement not covered" >c(x,a);<span class="cstat-no" title="statement not covered" ></span>this.timeScaleArray.push({position:u,value:f,unit:l,day:x,hour:p,year:s,month:g.monthMod(b)});<span class="cstat-no" title="statement not covered" >f</span>or(var m=<span class="cstat-no" title="statement not covered" >u,</span>v=<span class="cstat-no" title="statement not covered" >0;</span>v&lt;n;v++){<span class="cstat-no" title="statement not covered" >if(l="hour",p&gt;=24)<span class="cstat-no" title="statement not covered" >p=0,l="day",b=h(x+=1,b).month,b=c(x,b);v</span></span>ar y=<span class="cstat-no" title="statement not covered" >this._getYear(s,b,0);<span class="cstat-no" title="statement not covered" ></span>m=0===p&amp;&amp;0===v?d*r:60*r+m;v</span>ar w=<span class="cstat-no" title="statement not covered" >0===p?x:p;<span class="cstat-no" title="statement not covered" ></span>this.timeScaleArray.push({position:m,value:w,unit:l,hour:p,day:x,year:y,month:g.monthMod(b)}),p++}</span>}</span>},{key:"generateMinuteScale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.firstVal,</span>i=<span class="cstat-no" title="statement not covered" >t.currentMinute,</span>a=<span class="cstat-no" title="statement not covered" >t.currentHour,</span>s=<span class="cstat-no" title="statement not covered" >t.currentDate,</span>r=<span class="cstat-no" title="statement not covered" >t.currentMonth,</span>n=<span class="cstat-no" title="statement not covered" >t.currentYear,</span>o=<span class="cstat-no" title="statement not covered" >t.minutesWidthOnXAxis,</span>l=<span class="cstat-no" title="statement not covered" >t.numberOfMinutes,</span>h=<span class="cstat-no" title="statement not covered" >o-(i-e.minMinute),</span>c=<span class="cstat-no" title="statement not covered" >e.minMinute+1,</span>d=<span class="cstat-no" title="statement not covered" >c+1,</span>u=<span class="cstat-no" title="statement not covered" >s,</span>f=<span class="cstat-no" title="statement not covered" >r,</span>p=<span class="cstat-no" title="statement not covered" >n,</span>x=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>this.timeScaleArray.push({position:h,value:c,unit:"minute",day:u,hour:x,minute:d,year:p,month:g.monthMod(f)});<span class="cstat-no" title="statement not covered" >f</span>or(var b=<span class="cstat-no" title="statement not covered" >h,</span>m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;l;m++)<span class="cstat-no" title="statement not covered" >d&gt;=60&amp;&amp;(d=0,24===(x+=1)&amp;&amp;(x=0)),b=o+b,this.timeScaleArray.push({position:b,value:d,unit:"minute",hour:x,minute:d,day:u,year:this._getYear(n,f,0),month:g.monthMod(f)}),d++}</span></span>},{key:"createRawDateString",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >t.year;<span class="cstat-no" title="statement not covered" ></span>return i+="-"+("0"+t.month.toString()).slice(-2),"day"===t.unit?i+="day"===t.unit?"-"+("0"+e).slice(-2):"-01":i+="-"+("0"+(t.day?t.day:"1")).slice(-2),"hour"===t.unit?i+="hour"===t.unit?"T"+("0"+e).slice(-2):"T00":i+="T"+("0"+(t.hour?t.hour:"0")).slice(-2),i+="minute"===t.unit?":"+("0"+e).slice(-2)+":00":":00:00",this.utc&amp;&amp;(i+=".000Z"),i}</span>},{key:"formatDates",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var a=<span class="cstat-no" title="statement not covered" >t.value.toString(),</span>s=<span class="cstat-no" title="statement not covered" >new Y(e.ctx),</span>r=<span class="cstat-no" title="statement not covered" >e.createRawDateString(t,a),</span>n=<span class="cstat-no" title="statement not covered" >s.getDate(r);<span class="cstat-no" title="statement not covered" ></span>if(void 0===i.config.xaxis.labels.format){var o=<span class="cstat-no" title="statement not covered" >"dd MMM",</span>l=<span class="cstat-no" title="statement not covered" >i.config.xaxis.labels.datetimeFormatter;<span class="cstat-no" title="statement not covered" ></span>"year"===t.unit&amp;&amp;(o=l.year),"month"===t.unit&amp;&amp;(o=l.month),"day"===t.unit&amp;&amp;(o=l.day),"hour"===t.unit&amp;&amp;(o=l.hour),"minute"===t.unit&amp;&amp;(o=l.minute),a=s.formatDate(n,o)}</span>else <span class="cstat-no" title="statement not covered" >a=s.formatDate(n,i.config.xaxis.labels.format);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{dateString:r,position:t.position,value:a,unit:t.unit,year:t.year,month:t.month}}</span>))}</span>},{key:"removeOverlappingTS",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >new p(this.ctx),</span>s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.length&gt;0&amp;&amp;t[0].value&amp;&amp;t.every((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.value.length===t[0].value.length}</span>))&amp;&amp;(s=!0,e=a.getTextRects(t[0].value).width);v</span>ar r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(n,o){<span class="cstat-no" title="statement not covered" >if(o&gt;0&amp;&amp;i.w.config.xaxis.labels.hideOverlappingLabels){var l=<span class="cstat-no" title="statement not covered" >s?e:a.getTextRects(t[r].value).width,</span>h=<span class="cstat-no" title="statement not covered" >t[r].position;<span class="cstat-no" title="statement not covered" ></span>return n.position&gt;h+l+10?(r=o,n):null}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>));<span class="cstat-no" title="statement not covered" ></span>return n=n.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==t}</span>))}</span>},{key:"_getYear",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return t+Math.floor(e/12)+i}</span>}]),t}</span>(),</span>Tt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=a,this.w=a.w,this.el=i}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"setupElements",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >this.w.config,</span>i=<span class="cstat-no" title="statement not covered" >e.chart.type;<span class="cstat-no" title="statement not covered" ></span>t.axisCharts=["line","area","bar","rangeBar","candlestick","scatter","bubble","radar","heatmap"].indexOf(i)&gt;-1,t.xyCharts=["line","area","bar","rangeBar","candlestick","scatter","bubble"].indexOf(i)&gt;-1,t.isBarHorizontal=("bar"===e.chart.type||"rangeBar"===e.chart.type)&amp;&amp;e.plotOptions.bar.horizontal,t.chartClass=".apexcharts"+t.cuid,t.dom.baseEl=this.el,t.dom.elWrap=document.createElement("div"),p.setAttrs(t.dom.elWrap,{id:t.chartClass.substring(1),class:"apexcharts-canvas "+t.chartClass.substring(1)}),this.el.appendChild(t.dom.elWrap),t.dom.Paper=new window.SVG.Doc(t.dom.elWrap),t.dom.Paper.attr({class:"apexcharts-svg","xmlns:data":"ApexChartsNS",transform:"translate(".concat(e.chart.offsetX,", ").concat(e.chart.offsetY,")")}),t.dom.Paper.node.style.background=e.chart.background,this.setSVGDimensions(),t.dom.elGraphical=t.dom.Paper.group().attr({class:"apexcharts-inner apexcharts-graphical"}),t.dom.elAnnotations=t.dom.Paper.group().attr({class:"apexcharts-annotations"}),t.dom.elDefs=t.dom.Paper.defs(),t.dom.elLegendWrap=document.createElement("div"),t.dom.elLegendWrap.classList.add("apexcharts-legend"),t.dom.elWrap.appendChild(t.dom.elLegendWrap),t.dom.Paper.add(t.dom.elGraphical),t.dom.elGraphical.add(t.dom.elDefs)}</span>},{key:"plotChartType",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >i.config,</span>s=<span class="cstat-no" title="statement not covered" >i.globals,</span>r=<span class="cstat-no" title="statement not covered" >{series:[],i:[]},</span>n=<span class="cstat-no" title="statement not covered" >{series:[],i:[]},</span>o=<span class="cstat-no" title="statement not covered" >{series:[],i:[]},</span>l=<span class="cstat-no" title="statement not covered" >{series:[],i:[]},</span>h=<span class="cstat-no" title="statement not covered" >{series:[],i:[]},</span>c=<span class="cstat-no" title="statement not covered" >{series:[],i:[]};<span class="cstat-no" title="statement not covered" ></span>s.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,d){<span class="cstat-no" title="statement not covered" >void 0!==t[d].type?("column"===t[d].type||"bar"===t[d].type?(s.series.length&gt;1&amp;&amp;a.plotOptions.bar.horizontal&amp;&amp;console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"),h.series.push(e),h.i.push(d),i.globals.columnSeries=h.series):"area"===t[d].type?(n.series.push(e),n.i.push(d)):"line"===t[d].type?(r.series.push(e),r.i.push(d)):"scatter"===t[d].type?(o.series.push(e),o.i.push(d)):"bubble"===t[d].type?(l.series.push(e),l.i.push(d)):"candlestick"===t[d].type?(c.series.push(e),c.i.push(d)):console.warn("You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble"),s.comboCharts=!0):(r.series.push(e),r.i.push(d))}</span>));v</span>ar d=<span class="cstat-no" title="statement not covered" >new Lt(this.ctx,e),</span>g=<span class="cstat-no" title="statement not covered" >new vt(this.ctx,e);<span class="cstat-no" title="statement not covered" ></span>this.ctx.pie=new kt(this.ctx);v</span>ar u=<span class="cstat-no" title="statement not covered" >new St(this.ctx),</span>f=<span class="cstat-no" title="statement not covered" >new F(this.ctx,e),</span>p=<span class="cstat-no" title="statement not covered" >new At(this.ctx),</span>x=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.comboCharts){<span class="cstat-no" title="statement not covered" >if(n.series.length&gt;0&amp;&amp;x.push(d.draw(n.series,"area",n.i)),h.series.length&gt;0)<span class="cstat-no" title="statement not covered" >if(i.config.chart.stacked){var b=<span class="cstat-no" title="statement not covered" >new mt(this.ctx,e);<span class="cstat-no" title="statement not covered" ></span>x.push(b.draw(h.series,h.i))}</span>else{var m=<span class="cstat-no" title="statement not covered" >new X(this.ctx,e);<span class="cstat-no" title="statement not covered" ></span>x.push(m.draw(h.series,h.i))}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(r.series.length&gt;0&amp;&amp;x.push(d.draw(r.series,"line",r.i)),c.series.length&gt;0&amp;&amp;x.push(g.draw(c.series,c.i)),o.series.length&gt;0){var v=<span class="cstat-no" title="statement not covered" >new Lt(this.ctx,e,!0);<span class="cstat-no" title="statement not covered" ></span>x.push(v.draw(o.series,"scatter",o.i))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.series.length&gt;0){var y=<span class="cstat-no" title="statement not covered" >new Lt(this.ctx,e,!0);<span class="cstat-no" title="statement not covered" ></span>x.push(y.draw(l.series,"bubble",l.i))}</span>}</span>else <span class="cstat-no" title="statement not covered" >switch(a.chart.type){case"line":<span class="cstat-no" title="statement not covered" >x=d.draw(s.series,"line");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"area":<span class="cstat-no" title="statement not covered" >x=d.draw(s.series,"area");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bar":<span class="cstat-no" title="statement not covered" >if(a.chart.stacked)<span class="cstat-no" title="statement not covered" >x=new mt(this.ctx,e).draw(s.series);e</span>lse <span class="cstat-no" title="statement not covered" >x=new X(this.ctx,e).draw(s.series);<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"candlestick":<span class="cstat-no" title="statement not covered" >x=new vt(this.ctx,e).draw(s.series);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rangeBar":<span class="cstat-no" title="statement not covered" >x=f.draw(s.series);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"heatmap":<span class="cstat-no" title="statement not covered" >x=new yt(this.ctx,e).draw(s.series);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"pie":case"donut":case"polarArea":<span class="cstat-no" title="statement not covered" >x=this.ctx.pie.draw(s.series);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"radialBar":<span class="cstat-no" title="statement not covered" >x=u.draw(s.series);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"radar":<span class="cstat-no" title="statement not covered" >x=p.draw(s.series);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >x=d.draw(s.series)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn x}</span>},{key:"setSVGDimensions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >this.w.config;<span class="cstat-no" title="statement not covered" ></span>t.svgWidth=e.chart.width,t.svgHeight=e.chart.height;v</span>ar i=<span class="cstat-no" title="statement not covered" >g.getDimensions(this.el),</span>a=<span class="cstat-no" title="statement not covered" >e.chart.width.toString().split(/[0-9]+/g).pop();<span class="cstat-no" title="statement not covered" ></span>if("%"===a?g.isNumber(i[0])&amp;&amp;(0===i[0].width&amp;&amp;(i=g.getDimensions(this.el.parentNode)),t.svgWidth=i[0]*parseInt(e.chart.width,10)/100):"px"!==a&amp;&amp;""!==a||(t.svgWidth=parseInt(e.chart.width,10)),"auto"!==t.svgHeight&amp;&amp;""!==t.svgHeight)<span class="cstat-no" title="statement not covered" >if("%"===e.chart.height.toString().split(/[0-9]+/g).pop()){var s=<span class="cstat-no" title="statement not covered" >g.getDimensions(this.el.parentNode);<span class="cstat-no" title="statement not covered" ></span>t.svgHeight=s[1]*parseInt(e.chart.height,10)/100}</span>else <span class="cstat-no" title="statement not covered" >t.svgHeight=parseInt(e.chart.height,10);e</span></span>lse <span class="cstat-no" title="statement not covered" >t.axisCharts?t.svgHeight=t.svgWidth/1.61:t.svgHeight=t.svgWidth/1.2;<span class="cstat-no" title="statement not covered" >t</span></span>.svgWidth&lt;0&amp;&amp;(t.svgWidth=0),t.svgHeight&lt;0&amp;&amp;(t.svgHeight=0),p.setAttrs(t.dom.Paper.node,{width:t.svgWidth,height:t.svgHeight});v</span>ar r=<span class="cstat-no" title="statement not covered" >e.chart.sparkline.enabled?0:t.axisCharts?e.chart.parentHeightOffset:0;<span class="cstat-no" title="statement not covered" ></span>t.dom.Paper.node.parentNode.parentNode.style.minHeight=t.svgHeight+r+"px",t.dom.elWrap.style.width=t.svgWidth+"px",t.dom.elWrap.style.height=t.svgHeight+"px"}</span>},{key:"shiftGraphPosition",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w.globals,</span>e=<span class="cstat-no" title="statement not covered" >t.translateY,</span>i=<span class="cstat-no" title="statement not covered" >{transform:"translate("+t.translateX+", "+e+")"};<span class="cstat-no" title="statement not covered" ></span>p.setAttrs(t.dom.elGraphical.node,i)}</span>},{key:"resizeNonAxisCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.w,</span>e=<span class="cstat-no" title="statement not covered" >t.globals,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >t.config.chart.sparkline.enabled?1:15;<span class="cstat-no" title="statement not covered" ></span>a+=t.config.grid.padding.bottom,"top"!==t.config.legend.position&amp;&amp;"bottom"!==t.config.legend.position||!t.config.legend.show||t.config.legend.floating||(i=new lt(this.ctx).legendHelpers.getLegendBBox().clwh+10);v</span>ar s=<span class="cstat-no" title="statement not covered" >t.globals.dom.baseEl.querySelector(".apexcharts-radialbar"),</span>r=<span class="cstat-no" title="statement not covered" >2.05*t.globals.radialSize;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!t.config.chart.sparkline.enabled){var n=<span class="cstat-no" title="statement not covered" >g.getBoundingClientRect(s);<span class="cstat-no" title="statement not covered" ></span>r=n.bottom;v</span>ar o=<span class="cstat-no" title="statement not covered" >n.bottom-n.top;<span class="cstat-no" title="statement not covered" ></span>r=Math.max(2.05*t.globals.radialSize,o)}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >r+e.translateY+i+a;<span class="cstat-no" title="statement not covered" ></span>e.dom.elLegendForeign&amp;&amp;e.dom.elLegendForeign.setAttribute("height",l),e.dom.elWrap.style.height=l+"px",p.setAttrs(e.dom.Paper.node,{height:l}),e.dom.Paper.node.parentNode.parentNode.style.minHeight=l+"px"}</span>},{key:"coreCalculations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >new U(this.ctx).init()}</span>},{key:"resetGlobals",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.w.config.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[]}</span>))}</span>,</span>i=<span class="cstat-no" title="statement not covered" >new H,</span>a=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>i.initGlobalVars(a),a.seriesXvalues=e(),a.seriesYvalues=e()}</span>},{key:"isMultipleY",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.w.config.yaxis.constructor===Array&amp;&amp;this.w.config.yaxis.length&gt;1)<span class="cstat-no" title="statement not covered" >return this.w.globals.isMultipleYAxis=!0,!0}</span></span>},{key:"xySettings",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >null,</span>e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(e.globals.axisCharts){<span class="cstat-no" title="statement not covered" >if("back"===e.config.xaxis.crosshairs.position)<span class="cstat-no" title="statement not covered" >new Q(this.ctx).drawXCrosshairs();<span class="cstat-no" title="statement not covered" >i</span></span>f("back"===e.config.yaxis[0].crosshairs.position)<span class="cstat-no" title="statement not covered" >new Q(this.ctx).drawYCrosshairs();<span class="cstat-no" title="statement not covered" >i</span></span>f("datetime"===e.config.xaxis.type&amp;&amp;void 0===e.config.xaxis.labels.formatter){var i=<span class="cstat-no" title="statement not covered" >new Pt(this.ctx),</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>isFinite(e.globals.minX)&amp;&amp;isFinite(e.globals.maxX)&amp;&amp;!e.globals.isBarHorizontal?a=i.calculateTimeScaleTicks(e.globals.minX,e.globals.maxX):e.globals.isBarHorizontal&amp;&amp;(a=i.calculateTimeScaleTicks(e.globals.minY,e.globals.maxY)),i.recalcDimensionsBasedOnFormat(a)}<span class="cstat-no" title="statement not covered" ></span>t</span>=new m(this.ctx).getCalculatedRatios()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>},{key:"updateSourceChart",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.ctx.w.globals.selection=void 0,this.ctx.updateHelpers._updateOptions({chart:{selection:{xaxis:{min:t.w.globals.minX,max:t.w.globals.maxX}}}},!1,!1)}</span>},{key:"setupBrushHandler",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(e.config.chart.brush.enabled&amp;&amp;"function"!=typeof e.config.chart.events.selection){var i=<span class="cstat-no" title="statement not covered" >e.config.chart.brush.targets||[e.config.chart.brush.target];<span class="cstat-no" title="statement not covered" ></span>i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >ApexCharts.getChartByID(e);<span class="cstat-no" title="statement not covered" ></span>i.w.globals.brushSource=t.ctx,"function"!=typeof i.w.config.chart.events.zoomed&amp;&amp;(i.w.config.chart.events.zoomed=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.updateSourceChart(i)}</span>),"function"!=typeof i.w.config.chart.events.scrolled&amp;&amp;(i.w.config.chart.events.scrolled=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.updateSourceChart(i)}</span>)}</span>)),e.config.chart.events.selection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >ApexCharts.getChartByID(t),</span>s=<span class="cstat-no" title="statement not covered" >g.clone(e.config.yaxis);<span class="cstat-no" title="statement not covered" ></span>if(e.config.chart.brush.autoScaleYaxis&amp;&amp;1===i.w.globals.series.length){var r=<span class="cstat-no" title="statement not covered" >new j(i);<span class="cstat-no" title="statement not covered" ></span>s=r.autoScaleY(i,s,a)}</span>v</span>ar o=<span class="cstat-no" title="statement not covered" >i.w.config.yaxis.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,a){<span class="cstat-no" title="statement not covered" >return[].concat(d(t),[n({},i.w.config.yaxis[a],{min:s[0].min,max:s[0].max})])}</span>),[]);<span class="cstat-no" title="statement not covered" ></span>i.ctx.updateHelpers._updateOptions({xaxis:{min:a.xaxis.min,max:a.xaxis.max},yaxis:o},!1,!1,!1,!1)}</span>))}</span>}</span>}</span>}]),t}</span>(),</span>zt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >i(</span>t){<span class="cstat-no" title="statement not covered" >e(this,i),this.ctx=t,this.w=t.w}<span class="cstat-no" title="statement not covered" ></span>return a(i,[{key:"_updateOptions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]&amp;&amp;arguments[1],</span>s=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;2&amp;&amp;void 0!==arguments[2])||arguments[2],</span>r=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;3&amp;&amp;void 0!==arguments[3])||arguments[3],</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]&amp;&amp;arguments[4],</span>o=<span class="cstat-no" title="statement not covered" >[this.ctx];<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(o=this.ctx.getSyncedCharts()),this.ctx.w.globals.isExecCalled&amp;&amp;(o=[this.ctx],this.ctx.w.globals.isExecCalled=!1),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){var o=<span class="cstat-no" title="statement not covered" >r.w;<span class="cstat-no" title="statement not covered" ></span>return o.globals.shouldAnimate=s,a||(o.globals.resized=!0,o.globals.dataChanged=!0,s&amp;&amp;r.series.getPreviousPaths()),e&amp;&amp;"object"===t(e)&amp;&amp;(r.config=new D(e),e=m.extendArrayProps(r.config,e,o),r.w.globals.chartID!==i.ctx.w.globals.chartID&amp;&amp;delete e.series,o.config=g.extend(o.config,e),n&amp;&amp;(o.globals.lastXAxis=[],o.globals.lastYAxis=[],o.globals.initialConfig=g.extend({},o.config),o.globals.initialSeries=JSON.parse(JSON.stringify(o.config.series)))),r.update(e)}</span>))}</span>},{key:"_updateSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i,a=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]&amp;&amp;arguments[2],</span>r=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return r.globals.shouldAnimate=e,r.globals.dataChanged=!0,e&amp;&amp;this.ctx.series.getPreviousPaths(),r.globals.axisCharts?(0===(i=t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return a._extendSeries(t,e)}</span>))).length&amp;&amp;(i=[{data:[]}]),r.config.series=i):r.config.series=t.slice(),s&amp;&amp;(r.globals.initialConfig.series=JSON.parse(JSON.stringify(r.config.series)),r.globals.initialSeries=JSON.parse(JSON.stringify(r.config.series))),this.ctx.update()}</span>},{key:"_extendSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return n({},i.config.series[e],{name:t.name?t.name:i.config.series[e]&amp;&amp;i.config.series[e].name,type:t.type?t.type:i.config.series[e]&amp;&amp;i.config.series[e].type,data:t.data?t.data:i.config.series[e]&amp;&amp;i.config.series[e].data})}</span>},{key:"toggleDataPointSelection",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w,</span>a=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >".apexcharts-series[data\\:realIndex='".concat(t,"']");<span class="cstat-no" title="statement not covered" ></span>return i.globals.axisCharts?a=i.globals.dom.Paper.select("".concat(s," path[j='").concat(e,"'], ").concat(s," circle[j='").concat(e,"'], ").concat(s," rect[j='").concat(e,"']")).members[0]:void 0===e&amp;&amp;(a=i.globals.dom.Paper.select("".concat(s," path[j='").concat(t,"']")).members[0],"pie"!==i.config.chart.type&amp;&amp;"polarArea"!==i.config.chart.type&amp;&amp;"donut"!==i.config.chart.type||this.ctx.pie.pieClicked(t)),a?(new p(this.ctx).pathMouseDown(a,null),a.node?a.node:null):(console.warn("toggleDataPointSelection: Element not found"),null)}</span>},{key:"forceXAxisUpdate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>if(["min","max"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >void 0!==t.xaxis[i]&amp;&amp;(e.config.xaxis[i]=t.xaxis[i],e.globals.lastXAxis[i]=t.xaxis[i])}</span>)),t.xaxis.categories&amp;&amp;t.xaxis.categories.length&amp;&amp;(e.config.xaxis.categories=t.xaxis.categories),e.config.xaxis.convertedCatToNumeric){var i=<span class="cstat-no" title="statement not covered" >new R(t);<span class="cstat-no" title="statement not covered" ></span>t=i.convertCatToNumericXaxis(t,this.ctx)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>},{key:"forceYAxisUpdate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return e.config.chart.stacked&amp;&amp;"100%"===e.config.chart.stackType&amp;&amp;(Array.isArray(t.yaxis)?t.yaxis.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >t.yaxis[i].min=0,t.yaxis[i].max=100}</span>)):(t.yaxis.min=0,t.yaxis.max=100)),t}</span>},{key:"revertDefaultAxisMinMax",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>e.config.xaxis.min=e.globals.lastXAxis.min,e.config.xaxis.max=e.globals.lastXAxis.max,e.config.yaxis.map((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){<span class="cstat-no" title="statement not covered" >e.globals.zoomed?void 0!==e.globals.lastYAxis[a]&amp;&amp;(i.min=e.globals.lastYAxis[a].min,i.max=e.globals.lastYAxis[a].max):void 0!==t.ctx.opts.yaxis[a]&amp;&amp;(i.min=t.ctx.opts.yaxis[a].min,i.max=t.ctx.opts.yaxis[a].max)}</span>))}</span>}]),i}</span>();<span class="cstat-no" title="statement not covered" ></span>w="undefined"!=typeof window?window:void 0,k=<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){var a=<span class="cstat-no" title="statement not covered" >(void 0!==this?this:e).SVG=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(a.supported)<span class="cstat-no" title="statement not covered" >return t=new a.Doc(t),a.parser.draw||a.prepare(),t}</span></span>;<span class="cstat-no" title="statement not covered" ></span>if(a.ns="http://www.w3.org/2000/svg",a.xmlns="http://www.w3.org/2000/xmlns/",a.xlink="http://www.w3.org/1999/xlink",a.svgjs="http://svgjs.com/svgjs",a.supported=!0,!a.supported)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >a</span></span>.did=1e3,a.eid=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"Svgjs"+d(t)+a.did++}</span>,a.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >i.createElementNS(this.ns,t);<span class="cstat-no" title="statement not covered" ></span>return e.setAttribute("id",this.eid(t)),e}</span>,a.extend=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e;<span class="cstat-no" title="statement not covered" >e=(t=[].slice.call(arguments)).pop();<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.length-1;</span>i&gt;=0;i--)<span class="cstat-no" title="statement not covered" >if(t[i])<span class="cstat-no" title="statement not covered" >for(var s in e)<span class="cstat-no" title="statement not covered" >t[i].prototype[s]=e[s];<span class="cstat-no" title="statement not covered" >a</span></span></span></span>.Set&amp;&amp;a.Set.inherit&amp;&amp;a.Set.inherit()}</span>,a.invent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >"function"==typeof t.create?t.create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,a.create(t.create))}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.inherit&amp;&amp;(e.prototype=new t.inherit),t.extend&amp;&amp;a.extend(e,t.extend),t.construct&amp;&amp;a.extend(t.parent||a.Container,t.construct),e}</span>,a.adopt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t?t.instance?t.instance:((i="svg"==t.nodeName?t.parentNode instanceof e.SVGElement?new a.Nested:new a.Doc:"linearGradient"==t.nodeName?new a.Gradient("linear"):"radialGradient"==t.nodeName?new a.Gradient("radial"):a[d(t.nodeName)]?new(a[d(t.nodeName)]):new a.Element(t)).type=t.nodeName,i.node=t,t.instance=i,i instanceof a.Doc&amp;&amp;i.namespace().defs(),i.setData(JSON.parse(t.getAttribute("svgjs:data"))||{}),i):null;v</span>ar i},a.prepare=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >i.getElementsByTagName("body")[0],</span>e=<span class="cstat-no" title="statement not covered" >(t?new a.Doc(t):a.adopt(i.documentElement).nested()).size(2,0);<span class="cstat-no" title="statement not covered" ></span>a.parser={body:t||i.documentElement,draw:e.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,poly:e.polyline().node,path:e.path().node,native:a.create("svg")}}</span>,a.parser={native:a.create("svg")},i.addEventListener("DOMContentLoaded",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.parser.draw||a.prepare()}</span>),!1),a.regex={numberAndUnit:/^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,hex:/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,rgb:/rgb\((\d+),(\d+),(\d+)\)/,reference:/#([a-z0-9\-_]+)/i,transforms:/\)\s*,?\s*/,whitespace:/\s/g,isHex:/^#[a-f0-9]{3,6}$/i,isRgb:/^rgb\(/,isCss:/[^:]+:[^;]+;?/,isBlank:/^(\s+)?$/,isNumber:/^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,isPercent:/^-?[\d\.]+%$/,isImage:/\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,delimiter:/[\s,]+/,hyphen:/([^e])\-/gi,pathLetters:/[MLHVCSQTAZ]/gi,isPathLetter:/[MLHVCSQTAZ]/i,numbersWithDots:/((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,dots:/\./g},a.utils={map:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >t.length,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i;s++)<span class="cstat-no" title="statement not covered" >a.push(e(t[s]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>,filter:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >t.length,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i;s++)<span class="cstat-no" title="statement not covered" >e(t[s])&amp;&amp;a.push(t[s]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>,filterSVGElements:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.filter(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e.SVGElement}</span>))}</span>},a.defaults={attrs:{"fill-opacity":1,"stroke-opacity":1,"stroke-width":0,"stroke-linejoin":"miter","stroke-linecap":"butt",fill:"#000000",stroke:"#000000",opacity:1,x:0,y:0,cx:0,cy:0,width:0,height:0,r:0,rx:0,ry:0,offset:0,"stop-opacity":1,"stop-color":"#000000","font-size":16,"font-family":"Helvetica, Arial, sans-serif","text-anchor":"start"}},a.Color=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i,s;<span class="cstat-no" title="statement not covered" >this.r=0,this.g=0,this.b=0,e&amp;&amp;("string"==typeof e?a.regex.isRgb.test(e)?(i=a.regex.rgb.exec(e.replace(a.regex.whitespace,"")),this.r=parseInt(i[1]),this.g=parseInt(i[2]),this.b=parseInt(i[3])):a.regex.isHex.test(e)&amp;&amp;(i=a.regex.hex.exec(4==(s=e).length?["#",s.substring(1,2),s.substring(1,2),s.substring(2,3),s.substring(2,3),s.substring(3,4),s.substring(3,4)].join(""):s),this.r=parseInt(i[1],16),this.g=parseInt(i[2],16),this.b=parseInt(i[3],16)):"object"===t(e)&amp;&amp;(this.r=e.r,this.g=e.g,this.b=e.b))}</span>,a.extend(a.Color,{toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.toHex()}</span>,toHex:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"#"+g(this.r)+g(this.g)+g(this.b)}</span>,toRgb:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"rgb("+[this.r,this.g,this.b].join()+")"}</span>,brightness:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.r/255*.3+this.g/255*.59+this.b/255*.11}</span>,morph:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.destination=new a.Color(t),this}</span>,at:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.destination?(t=t&lt;0?0:t&gt;1?1:t,new a.Color({r:~~(this.r+(this.destination.r-this.r)*t),g:~~(this.g+(this.destination.g-this.g)*t),b:~~(this.b+(this.destination.b-this.b)*t)})):this}</span>}),a.Color.test=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t+="",a.regex.isHex.test(t)||a.regex.isRgb.test(t)}</span>,a.Color.isRgb=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"number"==typeof t.r&amp;&amp;"number"==typeof t.g&amp;&amp;"number"==typeof t.b}</span>,a.Color.isColor=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.Color.isRgb(t)||a.Color.test(t)}</span>,a.Array=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >0==(t=(t||[]).valueOf()).length&amp;&amp;e&amp;&amp;(t=e.valueOf()),this.value=this.parse(t)}</span>,a.extend(a.Array,{toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.value.join(" ")}</span>,valueOf:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.value}</span>,parse:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=t.valueOf(),Array.isArray(t)?t:this.split(t)}</span>}),a.PointArray=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >a.Array.call(this,t,e||[[0,0]])}</span>,a.PointArray.prototype=new a.Array,a.PointArray.prototype.constructor=a.PointArray;<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >{M:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return e.x=i.x=t[0],e.y=i.y=t[1],["M",e.x,e.y]}</span>,L:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.x=t[0],e.y=t[1],["L",t[0],t[1]]}</span>,H:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.x=t[0],["H",t[0]]}</span>,V:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.y=t[0],["V",t[0]]}</span>,C:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.x=t[4],e.y=t[5],["C",t[0],t[1],t[2],t[3],t[4],t[5]]}</span>,Q:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.x=t[2],e.y=t[3],["Q",t[0],t[1],t[2],t[3]]}</span>,Z:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return e.x=i.x,e.y=i.y,["Z"]}</span>},</span>r=<span class="cstat-no" title="statement not covered" >"mlhvqtcsaz".split(""),</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >r.length;</span>n&lt;o;++n)<span class="cstat-no" title="statement not covered" >s[r[n]]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,i,a){<span class="cstat-no" title="statement not covered" >if("H"==t)<span class="cstat-no" title="statement not covered" >e[0]=e[0]+i.x;e</span>lse <span class="cstat-no" title="statement not covered" >if("V"==t)<span class="cstat-no" title="statement not covered" >e[0]=e[0]+i.y;e</span>lse <span class="cstat-no" title="statement not covered" >if("A"==t)<span class="cstat-no" title="statement not covered" >e[5]=e[5]+i.x,e[6]=e[6]+i.y;e</span>lse <span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.length;</span>r&lt;n;++r)<span class="cstat-no" title="statement not covered" >e[r]=e[r]+(r%2?i.y:i.x);<span class="cstat-no" title="statement not covered" >r</span></span></span></span></span>eturn s[t](e,i,a)}</span>}</span>(r[n].toUpperCase());<span class="cstat-no" title="statement not covered" >a</span></span>.PathArray=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >a.Array.call(this,t,e||[["M",0,0]])}</span>,a.PathArray.prototype=new a.Array,a.PathArray.prototype.constructor=a.PathArray,a.extend(a.PathArray,{toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length,</span>a=<span class="cstat-no" title="statement not covered" >"";</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >a+=t[e][0],null!=t[e][1]&amp;&amp;(a+=t[e][1],null!=t[e][2]&amp;&amp;(a+=" ",a+=t[e][2],null!=t[e][3]&amp;&amp;(a+=" ",a+=t[e][3],a+=" ",a+=t[e][4],null!=t[e][5]&amp;&amp;(a+=" ",a+=t[e][5],a+=" ",a+=t[e][6],null!=t[e][7]&amp;&amp;(a+=" ",a+=t[e][7])))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn a+" "}</span>(this.value)}</span>,move:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.bbox();<span class="cstat-no" title="statement not covered" ></span>return i.x,i.y,this}</span>,at:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.destination)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >this.value,</span>i=<span class="cstat-no" title="statement not covered" >this.destination.value,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >new a.PathArray,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >e.length;</span>n&lt;o;n++){<span class="cstat-no" title="statement not covered" >s[n]=[e[n][0]];<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >1,</span>h=<span class="cstat-no" title="statement not covered" >e[n].length;</span>l&lt;h;l++)<span class="cstat-no" title="statement not covered" >s[n][l]=e[n][l]+(i[n][l]-e[n][l])*t;<span class="cstat-no" title="statement not covered" >"</span></span>A"===s[n][0]&amp;&amp;(s[n][4]=+(0!=s[n][4]),s[n][5]=+(0!=s[n][5]))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.value=s,r}</span>,parse:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t instanceof a.PathArray)<span class="cstat-no" title="statement not covered" >return t.valueOf();v</span></span>ar e,i=<span class="cstat-no" title="statement not covered" >{M:2,L:2,H:1,V:1,C:6,S:4,Q:4,T:2,A:7,Z:0};<span class="cstat-no" title="statement not covered" ></span>t="string"==typeof t?t.replace(a.regex.numbersWithDots,h).replace(a.regex.pathLetters," $&amp; ").replace(a.regex.hyphen,"$1 -").trim().split(a.regex.delimiter):t.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return[].concat.call(t,e)}</span>),[]);v</span>ar r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >new a.Point,</span>o=<span class="cstat-no" title="statement not covered" >new a.Point,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >a.regex.isPathLetter.test(t[l])?(e=t[l],++l):"M"==e?e="L":"m"==e&amp;&amp;(e="l"),r.push(s[e].call(null,t.slice(l,l+=i[e.toUpperCase()]).map(parseFloat),n,o))}</span>while(c&gt;l);<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>,bbox:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.parser.draw||a.prepare(),a.parser.path.setAttribute("d",this.toString()),a.parser.path.getBBox()}</span>}),a.Number=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.value=0,this.unit=e||"","number"==typeof t?this.value=isNaN(t)?0:isFinite(t)?t:t&lt;0?-34e37:34e37:"string"==typeof t?(e=t.match(a.regex.numberAndUnit))&amp;&amp;(this.value=parseFloat(e[1]),"%"==e[5]?this.value/=100:"s"==e[5]&amp;&amp;(this.value*=1e3),this.unit=e[5]):t instanceof a.Number&amp;&amp;(this.value=t.valueOf(),this.unit=t.unit)}</span>,extend:{toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return("%"==this.unit?~~(1e8*this.value)/1e6:"s"==this.unit?this.value/1e3:this.value)+this.unit}</span>,toJSON:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.toString()}</span>,valueOf:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.value}</span>,plus:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=new a.Number(t),new a.Number(this+t,this.unit||t.unit)}</span>,minus:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=new a.Number(t),new a.Number(this-t,this.unit||t.unit)}</span>,times:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=new a.Number(t),new a.Number(this*t,this.unit||t.unit)}</span>,divide:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=new a.Number(t),new a.Number(this/t,this.unit||t.unit)}</span>,to:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >new a.Number(this);<span class="cstat-no" title="statement not covered" ></span>return"string"==typeof t&amp;&amp;(e.unit=t),e}</span>,morph:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.destination=new a.Number(t),t.relative&amp;&amp;(this.destination.value+=this.value),this}</span>,at:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.destination?new a.Number(this.destination).minus(this).times(t).plus(this):this}</span>}}),a.Element=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._stroke=a.defaults.attrs.stroke,this._event=null,this.dom={},(this.node=t)&amp;&amp;(this.type=t.nodeName,this.node.instance=this,this._stroke=t.getAttribute("stroke")||this._stroke)}</span>,extend:{x:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("x",t)}</span>,y:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("y",t)}</span>,cx:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.x()+this.width()/2:this.x(t-this.width()/2)}</span>,cy:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.y()+this.height()/2:this.y(t-this.height()/2)}</span>,move:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.x(t).y(e)}</span>,center:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.cx(t).cy(e)}</span>,width:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("width",t)}</span>,height:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("height",t)}</span>,size:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >u(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return this.width(new a.Number(i.width)).height(new a.Number(i.height))}</span>,clone:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.writeDataToDom();v</span>ar e=<span class="cstat-no" title="statement not covered" >x(this.node.cloneNode(!0));<span class="cstat-no" title="statement not covered" ></span>return t?t.add(e):this.after(e),e}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().removeElement(this),this}</span>,replace:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.after(t).remove(),t}</span>,addTo:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.put(this)}</span>,putIn:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.add(this)}</span>,id:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("id",t)}</span>,show:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.style("display","")}</span>,hide:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.style("display","none")}</span>,visible:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"none"!=this.style("display")}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.attr("id")}</span>,classes:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.attr("class");<span class="cstat-no" title="statement not covered" ></span>return null==t?[]:t.trim().split(a.regex.delimiter)}</span>,hasClass:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return-1!=this.classes().indexOf(t)}</span>,addClass:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.hasClass(t)){var e=<span class="cstat-no" title="statement not covered" >this.classes();<span class="cstat-no" title="statement not covered" ></span>e.push(t),this.attr("class",e.join(" "))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,removeClass:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.hasClass(t)&amp;&amp;this.attr("class",this.classes().filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e!=t}</span>)).join(" ")),this}</span>,toggleClass:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.hasClass(t)?this.removeClass(t):this.addClass(t)}</span>,reference:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.get(this.attr(t))}</span>,parent:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!i.node.parentNode)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(i=a.adopt(i.node.parentNode),!t)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >f</span></span>or(;i&amp;&amp;i.node instanceof e.SVGElement;){<span class="cstat-no" title="statement not covered" >if("string"==typeof t?i.matches(t):i instanceof t)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f(!i.node.parentNode||"#document"==i.node.parentNode.nodeName)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>=a.adopt(i.node.parentNode)}</span>}</span>,doc:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this instanceof a.Doc?this:this.parent(a.Doc)}</span>,parents:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >if(!(i=i.parent(t))||!i.node)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >e</span></span>.push(i)}</span>while(i.parent);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>,matches:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return(t.matches||t.matchesSelector||t.msMatchesSelector||t.mozMatchesSelector||t.webkitMatchesSelector||t.oMatchesSelector).call(t,e)}</span>(this.node,t)}</span>,native:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node}</span>,svg:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >i.createElement("svg");<span class="cstat-no" title="statement not covered" ></span>if(!(t&amp;&amp;this instanceof a.Parent))<span class="cstat-no" title="statement not covered" >return e.appendChild(t=i.createElement("svg")),this.writeDataToDom(),t.appendChild(this.node.cloneNode(!0)),e.innerHTML.replace(/^&lt;svg&gt;/,"").replace(/&lt;\/svg&gt;$/,"");<span class="cstat-no" title="statement not covered" >e</span></span>.innerHTML="&lt;svg&gt;"+t.replace(/\n/,"").replace(/&lt;([\w:-]+)([^&lt;]+?)\/&gt;/g,"&lt;$1$2&gt;&lt;/$1&gt;")+"&lt;/svg&gt;";<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >e.firstChild.childNodes.length;</span>s&lt;r;s++)<span class="cstat-no" title="statement not covered" >this.node.appendChild(e.firstChild.firstChild);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,writeDataToDom:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.each||this.lines)&amp;&amp;(this.each?this:this.lines()).each((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.writeDataToDom()}</span>)),this.node.removeAttribute("svgjs:data"),Object.keys(this.dom).length&amp;&amp;this.node.setAttribute("svgjs:data",JSON.stringify(this.dom)),this}</span>,setData:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.dom=t,this}</span>,is:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t instanceof e}</span>(this,t)}</span>}}),a.easing={"-":<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>,"&lt;&gt;":<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return-Math.cos(t*Math.PI)/2+.5}</span>,"&gt;":<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Math.sin(t*Math.PI/2)}</span>,"&lt;":<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 1-Math.cos(t*Math.PI/2)}</span>},a.morph=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >return new a.MorphObj(e,i).at(t)}</span>}</span>,a.Situation=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.init=!1,this.reversed=!1,this.reversing=!1,this.duration=new a.Number(t.duration).valueOf(),this.delay=new a.Number(t.delay).valueOf(),this.start=+new Date+this.delay,this.finish=this.start+this.duration,this.ease=t.ease,this.loop=0,this.loops=!1,this.animations={},this.attrs={},this.styles={},this.transforms=[],this.once={}}</span>}),a.FX=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._target=t,this.situations=[],this.active=!1,this.situation=null,this.paused=!1,this.lastPos=0,this.pos=0,this.absPos=0,this._speed=1}</span>,extend:{animate:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s){<span class="cstat-no" title="statement not covered" >"object"===t(e)&amp;&amp;(i=e.ease,s=e.delay,e=e.duration);v</span>ar r=<span class="cstat-no" title="statement not covered" >new a.Situation({duration:e||1e3,delay:s||0,ease:a.easing[i||"-"]||i});<span class="cstat-no" title="statement not covered" ></span>return this.queue(r),this}</span>,target:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t instanceof a.Element?(this._target=t,this):this._target}</span>,timeToAbsPos:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(t-this.situation.start)/(this.situation.duration/this._speed)}</span>,absPosToTime:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.situation.duration/this._speed*t+this.situation.start}</span>,startAnimFrame:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.stopAnimFrame(),this.animationFrame=e.requestAnimationFrame(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.step()}</span>.bind(this))}</span>,stopAnimFrame:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.cancelAnimationFrame(this.animationFrame)}</span>,start:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!this.active&amp;&amp;this.situation&amp;&amp;(this.active=!0,this.startCurrent()),this}</span>,startCurrent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.situation.start=+new Date+this.situation.delay/this._speed,this.situation.finish=this.situation.start+this.situation.duration/this._speed,this.initAnimations().step()}</span>,queue:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return("function"==typeof t||t instanceof a.Situation)&amp;&amp;this.situations.push(t),this.situation||(this.situation=this.situations.shift()),this}</span>,dequeue:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.stop(),this.situation=this.situations.shift(),this.situation&amp;&amp;(this.situation instanceof a.Situation?this.start():this.situation.call(this)),this}</span>,initAnimations:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e=<span class="cstat-no" title="statement not covered" >this.situation;<span class="cstat-no" title="statement not covered" ></span>if(e.init)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i in e.animations){<span class="cstat-no" title="statement not covered" >t=this.target()[i](),Array.isArray(t)||(t=[t]),Array.isArray(e.animations[i])||(e.animations[i]=[e.animations[i]]);<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >t.length;</span>s--;)<span class="cstat-no" title="statement not covered" >e.animations[i][s]instanceof a.Number&amp;&amp;(t[s]=new a.Number(t[s])),e.animations[i][s]=t[s].morph(e.animations[i][s])}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var i in e.attrs)<span class="cstat-no" title="statement not covered" >e.attrs[i]=new a.MorphObj(this.target().attr(i),e.attrs[i]);<span class="cstat-no" title="statement not covered" >f</span></span>or(var i in e.styles)<span class="cstat-no" title="statement not covered" >e.styles[i]=new a.MorphObj(this.target().style(i),e.styles[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.initialTransformation=this.target().matrixify(),e.init=!0,this}</span>,clearQueue:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.situations=[],this}</span>,clearCurrent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.situation=null,this}</span>,stop:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.active;<span class="cstat-no" title="statement not covered" ></span>return this.active=!1,e&amp;&amp;this.clearQueue(),t&amp;&amp;this.situation&amp;&amp;(!i&amp;&amp;this.startCurrent(),this.atEnd()),this.stopAnimFrame(),this.clearCurrent()}</span>,after:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.last();<span class="cstat-no" title="statement not covered" ></span>return this.target().on("finished.fx",(function <span class="fstat-no" title="function not covered" >i(</span>a){<span class="cstat-no" title="statement not covered" >a.detail.situation==e&amp;&amp;(t.call(this,e),this.off("finished.fx",i))}</span>)),this._callStart()}</span>,during:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.last(),</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i.detail.situation==e&amp;&amp;t.call(this,i.detail.pos,a.morph(i.detail.pos),i.detail.eased,e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return this.target().off("during.fx",i).on("during.fx",i),this.after((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.off("during.fx",i)}</span>)),this._callStart()}</span>,afterAll:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >e(</span>i){<span class="cstat-no" title="statement not covered" >t.call(this),this.off("allfinished.fx",e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return this.target().off("allfinished.fx",e).on("allfinished.fx",e),this._callStart()}</span>,last:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.situations.length?this.situations[this.situations.length-1]:this.situation}</span>,add:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.last()[i||"animations"][t]=e,this._callStart()}</span>,step:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i,a;<span class="cstat-no" title="statement not covered" >t||(this.absPos=this.timeToAbsPos(+new Date)),!1!==this.situation.loops?(e=Math.max(this.absPos,0),i=Math.floor(e),!0===this.situation.loops||i&lt;this.situation.loops?(this.pos=e-i,a=this.situation.loop,this.situation.loop=i):(this.absPos=this.situation.loops,this.pos=1,a=this.situation.loop-1,this.situation.loop=this.situation.loops),this.situation.reversing&amp;&amp;(this.situation.reversed=this.situation.reversed!=Boolean((this.situation.loop-a)%2))):(this.absPos=Math.min(this.absPos,1),this.pos=this.absPos),this.pos&lt;0&amp;&amp;(this.pos=0),this.situation.reversed&amp;&amp;(this.pos=1-this.pos);v</span>ar s=<span class="cstat-no" title="statement not covered" >this.situation.ease(this.pos);<span class="cstat-no" title="statement not covered" ></span>for(var r in this.situation.once)<span class="cstat-no" title="statement not covered" >r&gt;this.lastPos&amp;&amp;r&lt;=s&amp;&amp;(this.situation.once[r].call(this.target(),this.pos,s),delete this.situation.once[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.active&amp;&amp;this.target().fire("during",{pos:this.pos,eased:s,fx:this,situation:this.situation}),this.situation?(this.eachAt(),1==this.pos&amp;&amp;!this.situation.reversed||this.situation.reversed&amp;&amp;0==this.pos?(this.stopAnimFrame(),this.target().fire("finished",{fx:this,situation:this.situation}),this.situations.length||(this.target().fire("allfinished"),this.situations.length||(this.target().off(".fx"),this.active=!1)),this.active?this.dequeue():this.clearCurrent()):!this.paused&amp;&amp;this.active&amp;&amp;this.startAnimFrame(),this.lastPos=s,this):this}</span>,eachAt:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.target(),</span>s=<span class="cstat-no" title="statement not covered" >this.situation;<span class="cstat-no" title="statement not covered" ></span>for(var r in s.animations)<span class="cstat-no" title="statement not covered" >t=[].concat(s.animations[r]).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"string"!=typeof t&amp;&amp;t.at?t.at(s.ease(e.pos),e.pos):t}</span>)),i[r].apply(i,t);<span class="cstat-no" title="statement not covered" >f</span></span>or(var r in s.attrs)<span class="cstat-no" title="statement not covered" >t=[r].concat(s.attrs[r]).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"string"!=typeof t&amp;&amp;t.at?t.at(s.ease(e.pos),e.pos):t}</span>)),i.attr.apply(i,t);<span class="cstat-no" title="statement not covered" >f</span></span>or(var r in s.styles)<span class="cstat-no" title="statement not covered" >t=[r].concat(s.styles[r]).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"string"!=typeof t&amp;&amp;t.at?t.at(s.ease(e.pos),e.pos):t}</span>)),i.style.apply(i,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(s.transforms.length){<span class="cstat-no" title="statement not covered" >t=s.initialTransformation,r=0;<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >s.transforms.length;</span>r&lt;n;r++){var o=<span class="cstat-no" title="statement not covered" >s.transforms[r];<span class="cstat-no" title="statement not covered" ></span>o instanceof a.Matrix?t=o.relative?t.multiply((new a.Matrix).morph(o).at(s.ease(this.pos))):t.morph(o).at(s.ease(this.pos)):(o.relative||o.undo(t.extract()),t=t.multiply(o.at(s.ease(this.pos))))}<span class="cstat-no" title="statement not covered" ></span>i</span>.matrix(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,once:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >this.last();<span class="cstat-no" title="statement not covered" ></span>return i||(t=a.ease(t)),a.once[t]=e,this}</span>,_callStart:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.start()}</span>.bind(this),0),this}</span>},parent:a.Element,construct:{animate:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return(this.fx||(this.fx=new a.FX(this))).animate(t,e,i)}</span>,delay:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(this.fx||(this.fx=new a.FX(this))).delay(t)}</span>,stop:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.fx&amp;&amp;this.fx.stop(t,e),this}</span>,finish:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.fx&amp;&amp;this.fx.finish(),this}</span>}}),a.MorphObj=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return a.Color.isColor(e)?new a.Color(t).morph(e):a.regex.delimiter.test(t)?a.regex.pathLetters.test(t)?new a.PathArray(t).morph(e):new a.Array(t).morph(e):a.regex.numberAndUnit.test(e)?new a.Number(t).morph(e):(this.value=t,void(this.destination=e))}</span>,extend:{at:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e&lt;1?this.value:this.destination}</span>,valueOf:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.value}</span>}}),a.extend(a.FX,{attr:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,a){<span class="cstat-no" title="statement not covered" >if("object"===t(e))<span class="cstat-no" title="statement not covered" >for(var s in e)<span class="cstat-no" title="statement not covered" >this.attr(s,e[s]);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.add(e,i,"attrs");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,plot:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >return 4==arguments.length?this.plot([t,e,i,a]):this.add("plot",new(this.target().morphArray)(t))}</span>}),a.Box=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s,r){<span class="cstat-no" title="statement not covered" >if(!("object"!==t(e)||e instanceof a.Element))<span class="cstat-no" title="statement not covered" >return a.Box.call(this,null!=e.left?e.left:e.x,null!=e.top?e.top:e.y,e.width,e.height);<span class="cstat-no" title="statement not covered" >4</span></span>==arguments.length&amp;&amp;(this.x=e,this.y=i,this.width=s,this.height=r),b(this)}</span>}),a.BBox=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(a.Box.apply(this,[].slice.call(arguments)),t instanceof a.Element){var e;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!i.documentElement.contains){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >t.node;</span>s.parentNode;)<span class="cstat-no" title="statement not covered" >s=s.parentNode;<span class="cstat-no" title="statement not covered" >i</span></span>f(s!=i)<span class="cstat-no" title="statement not covered" >throw new Error("Element not in the dom")}<span class="cstat-no" title="statement not covered" ></span></span>e</span>=t.node.getBBox()}</span>catch(i){<span class="cstat-no" title="statement not covered" >if(t instanceof a.Shape){<span class="cstat-no" title="statement not covered" >a.parser.draw||a.prepare();v</span>ar r=<span class="cstat-no" title="statement not covered" >t.clone(a.parser.draw.instance).show();<span class="cstat-no" title="statement not covered" ></span>e=r.node.getBBox(),r.remove()}</span>else <span class="cstat-no" title="statement not covered" >e={x:t.node.clientLeft,y:t.node.clientTop,width:t.node.clientWidth,height:t.node.clientHeight}}<span class="cstat-no" title="statement not covered" ></span></span>a</span>.Box.call(this,e)}</span>}</span>,inherit:a.Box,parent:a.Element,construct:{bbox:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new a.BBox(this)}</span>}}),a.BBox.prototype.constructor=a.BBox,a.Matrix=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >p([1,0,0,1,0,0]);<span class="cstat-no" title="statement not covered" ></span>e=e instanceof a.Element?e.matrixify():"string"==typeof e?p(e.split(a.regex.delimiter).map(parseFloat)):6==arguments.length?p([].slice.call(arguments)):Array.isArray(e)?p(e):"object"===t(e)?e:i;<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >v.length-1;</span>s&gt;=0;--s)<span class="cstat-no" title="statement not covered" >this[v[s]]=null!=e[v[s]]?e[v[s]]:i[v[s]]}</span></span>,extend:{extract:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >f(this,0,1),</span>e=(<span class="cstat-no" title="statement not covered" >f(this,1,0),180/Math.PI*Math.atan2(t.y,t.x)-90)</span>;<span class="cstat-no" title="statement not covered" >return{x:this.e,y:this.f,transformedX:(this.e*Math.cos(e*Math.PI/180)+this.f*Math.sin(e*Math.PI/180))/Math.sqrt(this.a*this.a+this.b*this.b),transformedY:(this.f*Math.cos(e*Math.PI/180)+this.e*Math.sin(-e*Math.PI/180))/Math.sqrt(this.c*this.c+this.d*this.d),rotation:e,a:this.a,b:this.b,c:this.c,d:this.d,e:this.e,f:this.f,matrix:new a.Matrix(this)}}</span>,clone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new a.Matrix(this)}</span>,morph:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.destination=new a.Matrix(t),this}</span>,multiply:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new a.Matrix(this.native().multiply(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof a.Matrix||(t=new a.Matrix(t)),t}</span>(t).native()))}</span>,inverse:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new a.Matrix(this.native().inverse())}</span>,translate:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new a.Matrix(this.native().translate(t||0,e||0))}</span>,native:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >a.parser.native.createSVGMatrix(),</span>e=<span class="cstat-no" title="statement not covered" >v.length-1;</span>e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >t[v[e]]=this[v[e]];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"matrix("+m(this.a)+","+m(this.b)+","+m(this.c)+","+m(this.d)+","+m(this.e)+","+m(this.f)+")"}</span>},parent:a.Element,construct:{ctm:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new a.Matrix(this.node.getCTM())}</span>,screenCTM:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this instanceof a.Nested){var t=<span class="cstat-no" title="statement not covered" >this.rect(1,1),</span>e=<span class="cstat-no" title="statement not covered" >t.node.getScreenCTM();<span class="cstat-no" title="statement not covered" ></span>return t.remove(),new a.Matrix(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new a.Matrix(this.node.getScreenCTM())}</span>}}),a.Point=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){var a;<span class="cstat-no" title="statement not covered" >a=Array.isArray(e)?{x:e[0],y:e[1]}:"object"===t(e)?{x:e.x,y:e.y}:null!=e?{x:e,y:null!=i?i:e}:{x:0,y:0},this.x=a.x,this.y=a.y}</span>,extend:{clone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new a.Point(this)}</span>,morph:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.destination=new a.Point(t,e),this}</span>}}),a.extend(a.Element,{point:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new a.Point(t,e).transform(this.screenCTM().inverse())}</span>}),a.extend(a.Element,{attr:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s){<span class="cstat-no" title="statement not covered" >if(null==e){<span class="cstat-no" title="statement not covered" >for(e={},s=(i=this.node.attributes).length-1;s&gt;=0;s--)<span class="cstat-no" title="statement not covered" >e[i[s].nodeName]=a.regex.isNumber.test(i[s].nodeValue)?parseFloat(i[s].nodeValue):i[s].nodeValue;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>i</span>f("object"===t(e))<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >this.attr(r,e[r]);e</span></span>lse <span class="cstat-no" title="statement not covered" >if(null===i)<span class="cstat-no" title="statement not covered" >this.node.removeAttribute(e);e</span>lse{<span class="cstat-no" title="statement not covered" >if(null==i)<span class="cstat-no" title="statement not covered" >return null==(i=this.node.getAttribute(e))?a.defaults.attrs[e]:a.regex.isNumber.test(i)?parseFloat(i):i;<span class="cstat-no" title="statement not covered" >"</span></span>stroke-width"==e?this.attr("stroke",parseFloat(i)&gt;0?this._stroke:null):"stroke"==e&amp;&amp;(this._stroke=i),"fill"!=e&amp;&amp;"stroke"!=e||(a.regex.isImage.test(i)&amp;&amp;(i=this.doc().defs().image(i,0,0)),i instanceof a.Image&amp;&amp;(i=this.doc().defs().pattern(0,0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.add(i)}</span>)))),"number"==typeof i?i=new a.Number(i):a.Color.isColor(i)?i=new a.Color(i):Array.isArray(i)&amp;&amp;(i=new a.Array(i)),"leading"==e?this.leading&amp;&amp;this.leading(i):"string"==typeof s?this.node.setAttributeNS(s,e,i.toString()):this.node.setAttribute(e,i.toString()),!this.rebuild||"font-size"!=e&amp;&amp;"x"!=e||this.rebuild(e,i)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this}</span>}),a.extend(a.Element,{transform:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){var s;<span class="cstat-no" title="statement not covered" >return"object"!==t(e)?(s=new a.Matrix(this).extract(),"string"==typeof e?s[e]:s):(s=new a.Matrix(this),i=!!i||!!e.relative,null!=e.a&amp;&amp;(s=i?s.multiply(new a.Matrix(e)):new a.Matrix(e)),this.attr("transform",s))}</span>}),a.extend(a.Element,{untransform:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.attr("transform",null)}</span>,matrixify:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.attr("transform")||"").split(a.regex.transforms).slice(0,-1).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.trim().split("(");<span class="cstat-no" title="statement not covered" ></span>return[e[0],e[1].split(a.regex.delimiter).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseFloat(t)}</span>))]}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return"matrix"==e[0]?t.multiply(p(e[1])):t[e[0]].apply(t,e[1])}</span>),new a.Matrix)}</span>,toParent:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this==t)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.screenCTM(),</span>i=<span class="cstat-no" title="statement not covered" >t.screenCTM().inverse();<span class="cstat-no" title="statement not covered" ></span>return this.addTo(t).untransform().transform(i.multiply(e)),this}</span>,toDoc:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.toParent(this.doc())}</span>}),a.Transformation=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >if(arguments.length&gt;1&amp;&amp;"boolean"!=typeof i)<span class="cstat-no" title="statement not covered" >return this.constructor.call(this,[].slice.call(arguments));<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >this.arguments.length;</span>a&lt;s;++a)<span class="cstat-no" title="statement not covered" >this[this.arguments[a]]=e[a];e</span></span>lse <span class="cstat-no" title="statement not covered" >if("object"===t(e))<span class="cstat-no" title="statement not covered" >for(a=0,s=this.arguments.length;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >this[this.arguments[a]]=e[this.arguments[a]];<span class="cstat-no" title="statement not covered" >t</span></span></span></span>his.inversed=!1,!0===i&amp;&amp;(this.inversed=!0)}</span>}),a.Translate=a.invent({parent:a.Matrix,inherit:a.Transformation,create:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.constructor.apply(this,[].slice.call(arguments))}</span>,extend:{arguments:["transformedX","transformedY"],method:"translate"}}),a.extend(a.Element,{style:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >if(0==arguments.length)<span class="cstat-no" title="statement not covered" >return this.node.style.cssText||"";<span class="cstat-no" title="statement not covered" >i</span></span>f(arguments.length&lt;2)<span class="cstat-no" title="statement not covered" >if("object"===t(e))<span class="cstat-no" title="statement not covered" >for(var s in e)<span class="cstat-no" title="statement not covered" >this.style(s,e[s]);e</span></span>lse{<span class="cstat-no" title="statement not covered" >if(!a.regex.isCss.test(e))<span class="cstat-no" title="statement not covered" >return this.node.style[c(e)];<span class="cstat-no" title="statement not covered" >f</span></span>or(e=e.split(/\s*;\s*/).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!!t}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.split(/\s*:\s*/)}</span>));i=e.pop();)<span class="cstat-no" title="statement not covered" >this.style(i[0],i[1])}</span></span>e</span>lse <span class="cstat-no" title="statement not covered" >this.node.style[c(e)]=null===i||a.regex.isBlank.test(i)?"":i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>}),a.Parent=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,t)}</span>,inherit:a.Element,extend:{children:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.utils.map(a.utils.filterSVGElements(this.node.childNodes),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.adopt(t)}</span>))}</span>,add:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return null==e?this.node.appendChild(t.node):t.node!=this.node.childNodes[e]&amp;&amp;this.node.insertBefore(t.node,this.node.childNodes[e]),this}</span>,put:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.add(t,e),t}</span>,has:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.index(t)&gt;=0}</span>,index:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[].slice.call(this.node.childNodes).indexOf(t.node)}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.adopt(this.node.childNodes[t])}</span>,first:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.get(0)}</span>,last:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.get(this.node.childNodes.length-1)}</span>,each:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >this.children(),</span>s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >i.length;</span>s&lt;r;s++)<span class="cstat-no" title="statement not covered" >i[s]instanceof a.Element&amp;&amp;t.apply(i[s],[s,i]),e&amp;&amp;i[s]instanceof a.Container&amp;&amp;i[s].each(t,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,removeElement:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.node.removeChild(t.node),this}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(;this.node.hasChildNodes();)<span class="cstat-no" title="statement not covered" >this.node.removeChild(this.node.lastChild);<span class="cstat-no" title="statement not covered" >r</span></span>eturn delete this._defs,this}</span>,defs:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.doc().defs()}</span>}}),a.extend(a.Parent,{ungroup:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return 0===e||this instanceof a.Defs||this.node==a.parser.draw?this:(t=t||(this instanceof a.Doc?this:this.parent(a.Parent)),e=e||1/0,this.each((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this instanceof a.Defs?this:this instanceof a.Parent?this.ungroup(t,e-1):this.toParent(t)}</span>)),this.node.firstChild||this.remove(),this)}</span>,flatten:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.ungroup(t,e)}</span>}),a.Container=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,t)}</span>,inherit:a.Parent}),a.ViewBox=a.invent({parent:a.Container,construct:{}}),["click","dblclick","mousedown","mouseup","mouseover","mouseout","mousemove","touchstart","touchmove","touchleave","touchend","touchcancel"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.Element.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return a.on(this.node,t,e),this}</span>}</span>)),a.listeners=[],a.handlerMap=[],a.listenerId=0,a.on=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,r){var n=<span class="cstat-no" title="statement not covered" >i.bind(s||t.instance||t),</span>o=<span class="cstat-no" title="statement not covered" >(a.handlerMap.indexOf(t)+1||a.handlerMap.push(t))-1,</span>l=<span class="cstat-no" title="statement not covered" >e.split(".")[0],</span>h=<span class="cstat-no" title="statement not covered" >e.split(".")[1]||"*";<span class="cstat-no" title="statement not covered" ></span>a.listeners[o]=a.listeners[o]||{},a.listeners[o][l]=a.listeners[o][l]||{},a.listeners[o][l][h]=a.listeners[o][l][h]||{},i._svgjsListenerId||(i._svgjsListenerId=++a.listenerId),a.listeners[o][l][h][i._svgjsListenerId]=n,t.addEventListener(l,n,r||!1)}</span>,a.off=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var s=<span class="cstat-no" title="statement not covered" >a.handlerMap.indexOf(t),</span>r=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.split(".")[0],</span>n=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.split(".")[1],</span>o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(-1!=s)<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >if("function"==typeof i&amp;&amp;(i=i._svgjsListenerId),!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >a</span></span>.listeners[s][r]&amp;&amp;a.listeners[s][r][n||"*"]&amp;&amp;(t.removeEventListener(r,a.listeners[s][r][n||"*"][i],!1),delete a.listeners[s][r][n||"*"][i])}</span>else <span class="cstat-no" title="statement not covered" >if(n&amp;&amp;r){<span class="cstat-no" title="statement not covered" >if(a.listeners[s][r]&amp;&amp;a.listeners[s][r][n]){<span class="cstat-no" title="statement not covered" >for(var l in a.listeners[s][r][n])<span class="cstat-no" title="statement not covered" >a.off(t,[r,n].join("."),l);<span class="cstat-no" title="statement not covered" >d</span></span>elete a.listeners[s][r][n]}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >for(var h in a.listeners[s])<span class="cstat-no" title="statement not covered" >for(var o in a.listeners[s][h])<span class="cstat-no" title="statement not covered" >n===o&amp;&amp;a.off(t,[h,n].join("."));e</span></span></span>lse <span class="cstat-no" title="statement not covered" >if(r){<span class="cstat-no" title="statement not covered" >if(a.listeners[s][r]){<span class="cstat-no" title="statement not covered" >for(var o in a.listeners[s][r])<span class="cstat-no" title="statement not covered" >a.off(t,[r,o].join("."));<span class="cstat-no" title="statement not covered" >d</span></span>elete a.listeners[s][r]}</span>}</span>else{<span class="cstat-no" title="statement not covered" >for(var h in a.listeners[s])<span class="cstat-no" title="statement not covered" >a.off(t,h);<span class="cstat-no" title="statement not covered" >d</span></span>elete a.listeners[s],delete a.handlerMap[s]}</span>}</span></span></span></span></span>,a.extend(a.Element,{on:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return a.on(this.node,t,e,i,s),this}</span>,off:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return a.off(this.node,t,e),this}</span>,fire:<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t instanceof e.Event?this.node.dispatchEvent(t):this.node.dispatchEvent(t=new a.CustomEvent(t,{detail:i,cancelable:!0})),this._event=t,this}</span>,event:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._event}</span>}),a.Defs=a.invent({create:"defs",inherit:a.Container}),a.G=a.invent({create:"g",inherit:a.Container,extend:{x:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.transform("x"):this.transform({x:t-this.x()},!0)}</span>},construct:{group:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.put(new a.G)}</span>}}),a.Doc=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t&amp;&amp;("svg"==(t="string"==typeof t?i.getElementById(t):t).nodeName?this.constructor.call(this,t):(this.constructor.call(this,a.create("svg")),t.appendChild(this.node),this.size("100%","100%")),this.namespace().defs())}</span>,inherit:a.Container,extend:{namespace:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.attr({xmlns:a.ns,version:"1.1"}).attr("xmlns:xlink",a.xlink,a.xmlns).attr("xmlns:svgjs",a.svgjs,a.xmlns)}</span>,defs:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >return this._defs||((t=this.node.getElementsByTagName("defs")[0])?this._defs=a.adopt(t):this._defs=new a.Defs,this.node.appendChild(this._defs.node)),this._defs}</span>,parent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node.parentNode&amp;&amp;"#document"!=this.node.parentNode.nodeName?this.node.parentNode:null}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().removeChild(this.node),this}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(;this.node.hasChildNodes();)<span class="cstat-no" title="statement not covered" >this.node.removeChild(this.node.lastChild);<span class="cstat-no" title="statement not covered" >r</span></span>eturn delete this._defs,a.parser.draw&amp;&amp;!a.parser.draw.parentNode&amp;&amp;this.node.appendChild(a.parser.draw),this}</span>,clone:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.writeDataToDom();v</span>ar e=<span class="cstat-no" title="statement not covered" >this.node,</span>i=<span class="cstat-no" title="statement not covered" >x(e.cloneNode(!0));<span class="cstat-no" title="statement not covered" ></span>return t?(t.node||t).appendChild(i.node):e.parentNode.insertBefore(i.node,e.nextSibling),i}</span>}}),a.extend(a.Element,{}),a.Gradient=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,a.create(t+"Gradient")),this.type=t}</span>,inherit:a.Container,extend:{at:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.put(new a.Stop).update(t,e,i)}</span>,update:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.clear(),"function"==typeof t&amp;&amp;t.call(this,this),this}</span>,fill:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"url(#"+this.id()+")"}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.fill()}</span>,attr:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return"transform"==t&amp;&amp;(t="gradientTransform"),a.Container.prototype.attr.call(this,t,e,i)}</span>},construct:{gradient:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.defs().gradient(t,e)}</span>}}),a.extend(a.Gradient,a.FX,{from:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return"radial"==(this._target||this).type?this.attr({fx:new a.Number(t),fy:new a.Number(e)}):this.attr({x1:new a.Number(t),y1:new a.Number(e)})}</span>,to:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return"radial"==(this._target||this).type?this.attr({cx:new a.Number(t),cy:new a.Number(e)}):this.attr({x2:new a.Number(t),y2:new a.Number(e)})}</span>}),a.extend(a.Defs,{gradient:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new a.Gradient(t)).update(e)}</span>}),a.Stop=a.invent({create:"stop",inherit:a.Element,extend:{update:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return("number"==typeof t||t instanceof a.Number)&amp;&amp;(t={offset:arguments[0],color:arguments[1],opacity:arguments[2]}),null!=t.opacity&amp;&amp;this.attr("stop-opacity",t.opacity),null!=t.color&amp;&amp;this.attr("stop-color",t.color),null!=t.offset&amp;&amp;this.attr("offset",new a.Number(t.offset)),this}</span>}}),a.Pattern=a.invent({create:"pattern",inherit:a.Container,extend:{fill:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"url(#"+this.id()+")"}</span>,update:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.clear(),"function"==typeof t&amp;&amp;t.call(this,this),this}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.fill()}</span>,attr:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return"transform"==t&amp;&amp;(t="patternTransform"),a.Container.prototype.attr.call(this,t,e,i)}</span>},construct:{pattern:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.defs().pattern(t,e,i)}</span>}}),a.extend(a.Defs,{pattern:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.put(new a.Pattern).update(i).attr({x:0,y:0,width:t,height:e,patternUnits:"userSpaceOnUse"})}</span>}),a.Shape=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,t)}</span>,inherit:a.Element}),a.Symbol=a.invent({create:"symbol",inherit:a.Container,construct:{symbol:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.put(new a.Symbol)}</span>}}),a.Use=a.invent({create:"use",inherit:a.Shape,extend:{element:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.attr("href",(e||"")+"#"+t,a.xlink)}</span>},construct:{use:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new a.Use).element(t,e)}</span>}}),a.Rect=a.invent({create:"rect",inherit:a.Shape,construct:{rect:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new a.Rect).size(t,e)}</span>}}),a.Circle=a.invent({create:"circle",inherit:a.Shape,construct:{circle:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new a.Circle).rx(new a.Number(t).divide(2)).move(0,0)}</span>}}),a.extend(a.Circle,a.FX,{rx:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("r",t)}</span>,ry:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.rx(t)}</span>}),a.Ellipse=a.invent({create:"ellipse",inherit:a.Shape,construct:{ellipse:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new a.Ellipse).size(t,e).move(0,0)}</span>}}),a.extend(a.Ellipse,a.Rect,a.FX,{rx:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("rx",t)}</span>,ry:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("ry",t)}</span>}),a.extend(a.Circle,a.Ellipse,{x:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.cx()-this.rx():this.cx(t+this.rx())}</span>,y:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.cy()-this.ry():this.cy(t+this.ry())}</span>,cx:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.attr("cx"):this.attr("cx",t)}</span>,cy:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.attr("cy"):this.attr("cy",t)}</span>,width:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?2*this.rx():this.rx(new a.Number(t).divide(2))}</span>,height:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?2*this.ry():this.ry(new a.Number(t).divide(2))}</span>,size:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >u(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return this.rx(new a.Number(i.width).divide(2)).ry(new a.Number(i.height).divide(2))}</span>}),a.Line=a.invent({create:"line",inherit:a.Shape,extend:{array:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new a.PointArray([[this.attr("x1"),this.attr("y1")],[this.attr("x2"),this.attr("y2")]])}</span>,plot:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return null==t?this.array():(t=void 0!==e?{x1:t,y1:e,x2:i,y2:s}:new a.PointArray(t).toLine(),this.attr(t))}</span>,move:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.attr(this.array().move(t,e).toLine())}</span>,size:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >u(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return this.attr(this.array().size(i.width,i.height).toLine())}</span>},construct:{line:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return a.Line.prototype.plot.apply(this.put(new a.Line),null!=t?[t,e,i,s]:[0,0,0,0])}</span>}}),a.Polyline=a.invent({create:"polyline",inherit:a.Shape,construct:{polyline:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new a.Polyline).plot(t||new a.PointArray)}</span>}}),a.Polygon=a.invent({create:"polygon",inherit:a.Shape,construct:{polygon:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new a.Polygon).plot(t||new a.PointArray)}</span>}}),a.extend(a.Polyline,a.Polygon,{array:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._array||(this._array=new a.PointArray(this.attr("points")))}</span>,plot:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.array():this.clear().attr("points","string"==typeof t?t:this._array=new a.PointArray(t))}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return delete this._array,this}</span>,move:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.attr("points",this.array().move(t,e))}</span>,size:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >u(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return this.attr("points",this.array().size(i.width,i.height))}</span>}),a.extend(a.Line,a.Polyline,a.Polygon,{morphArray:a.PointArray,x:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.bbox().x:this.move(t,this.bbox().y)}</span>,y:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.bbox().y:this.move(this.bbox().x,t)}</span>,width:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.bbox();<span class="cstat-no" title="statement not covered" ></span>return null==t?e.width:this.size(t,e.height)}</span>,height:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.bbox();<span class="cstat-no" title="statement not covered" ></span>return null==t?e.height:this.size(e.width,t)}</span>}),a.Path=a.invent({create:"path",inherit:a.Shape,extend:{morphArray:a.PathArray,array:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._array||(this._array=new a.PathArray(this.attr("d")))}</span>,plot:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.array():this.clear().attr("d","string"==typeof t?t:this._array=new a.PathArray(t))}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return delete this._array,this}</span>},construct:{path:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new a.Path).plot(t||new a.PathArray)}</span>}}),a.Image=a.invent({create:"image",inherit:a.Shape,extend:{load:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >new e.Image;<span class="cstat-no" title="statement not covered" ></span>return a.on(s,"load",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.off(s);v</span>ar e=<span class="cstat-no" title="statement not covered" >i.parent(a.Pattern);<span class="cstat-no" title="statement not covered" ></span>null!==e&amp;&amp;(0==i.width()&amp;&amp;0==i.height()&amp;&amp;i.size(s.width,s.height),e&amp;&amp;0==e.width()&amp;&amp;0==e.height()&amp;&amp;e.size(i.width(),i.height()),"function"==typeof i._loaded&amp;&amp;i._loaded.call(i,{width:s.width,height:s.height,ratio:s.width/s.height,url:t}))}</span>)),a.on(s,"error",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.off(s),"function"==typeof i._error&amp;&amp;i._error.call(i,t)}</span>)),this.attr("href",s.src=this.src=t,a.xlink)}</span>,loaded:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this._loaded=t,this}</span>,error:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this._error=t,this}</span>},construct:{image:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.put(new a.Image).load(t).size(e||0,i||e||0)}</span>}}),a.Text=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,a.create("text")),this.dom.leading=new a.Number(1.3),this._rebuild=!0,this._build=!1,this.attr("font-family",a.defaults.attrs["font-family"])}</span>,inherit:a.Shape,extend:{x:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.attr("x"):this.attr("x",t)}</span>,text:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(void 0===t){<span class="cstat-no" title="statement not covered" >t="";<span class="cstat-no" title="statement not covered" >f</span>or(var e=<span class="cstat-no" title="statement not covered" >this.node.childNodes,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.length;</span>i&lt;s;++i)<span class="cstat-no" title="statement not covered" >0!=i&amp;&amp;3!=e[i].nodeType&amp;&amp;1==a.adopt(e[i]).dom.newLined&amp;&amp;(t+="\n"),t+=e[i].textContent;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.clear().build(!0),"function"==typeof t)<span class="cstat-no" title="statement not covered" >t.call(this,this);e</span>lse{<span class="cstat-no" title="statement not covered" >i=0;<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >(t=t.split("\n")).length;</span>i&lt;r;i++)<span class="cstat-no" title="statement not covered" >this.tspan(t[i]).newLine()}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.build(!1).rebuild()}</span>,size:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("font-size",t).rebuild()}</span>,leading:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.dom.leading:(this.dom.leading=new a.Number(t),this.rebuild())}</span>,lines:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >(this.textPath&amp;&amp;this.textPath()||this).node,</span>e=<span class="cstat-no" title="statement not covered" >a.utils.map(a.utils.filterSVGElements(t.childNodes),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.adopt(t)}</span>));<span class="cstat-no" title="statement not covered" ></span>return new a.Set(e)}</span>,rebuild:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("boolean"==typeof t&amp;&amp;(this._rebuild=t),this._rebuild){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >this.dom.leading*new a.Number(this.attr("font-size"));<span class="cstat-no" title="statement not covered" ></span>this.lines().each((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.dom.newLined&amp;&amp;(e.textPath()||this.attr("x",e.attr("x")),"\n"==this.text()?i+=s:(this.attr("dy",s+i),i=0))}</span>)),this.fire("rebuild")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,build:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this._build=!!t,this}</span>,setData:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.dom=t,this.dom.leading=new a.Number(t.leading||1.3),this}</span>},construct:{text:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new a.Text).text(t)}</span>,plain:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new a.Text).plain(t)}</span>}}),a.Tspan=a.invent({create:"tspan",inherit:a.Shape,extend:{text:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.node.textContent+(this.dom.newLined?"\n":""):("function"==typeof t?t.call(this,this):this.plain(t),this)}</span>,dx:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("dx",t)}</span>,dy:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("dy",t)}</span>,newLine:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.parent(a.Text);<span class="cstat-no" title="statement not covered" ></span>return this.dom.newLined=!0,this.dy(t.dom.leading*t.attr("font-size")).attr("x",t.x())}</span>}}),a.extend(a.Text,a.Tspan,{plain:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!1===this._build&amp;&amp;this.clear(),this.node.appendChild(i.createTextNode(t)),this}</span>,tspan:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >(this.textPath&amp;&amp;this.textPath()||this).node,</span>i=<span class="cstat-no" title="statement not covered" >new a.Tspan;<span class="cstat-no" title="statement not covered" ></span>return!1===this._build&amp;&amp;this.clear(),e.appendChild(i.node),i.text(t)}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >(this.textPath&amp;&amp;this.textPath()||this).node;</span>t.hasChildNodes();)<span class="cstat-no" title="statement not covered" >t.removeChild(t.lastChild);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,length:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node.getComputedTextLength()}</span>}),a.TextPath=a.invent({create:"textPath",inherit:a.Parent,parent:a.Text,construct:{morphArray:a.PathArray,array:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.track();<span class="cstat-no" title="statement not covered" ></span>return t?t.array():null}</span>,plot:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.track(),</span>i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;(i=e.plot(t)),null==t?i:this}</span>,track:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.textPath();<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t.reference("href")}</span></span>,textPath:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.node.firstChild&amp;&amp;"textPath"==this.node.firstChild.nodeName)<span class="cstat-no" title="statement not covered" >return a.adopt(this.node.firstChild)}</span></span>}}),a.Nested=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,a.create("svg")),this.style("overflow","visible")}</span>,inherit:a.Container,construct:{nested:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.put(new a.Nested)}</span>}});v</span>ar l=<span class="cstat-no" title="statement not covered" >{stroke:["color","width","opacity","linecap","linejoin","miterlimit","dasharray","dashoffset"],fill:["color","opacity","rule"],prefix:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return"color"==e?t:t+"-"+e}</span>};</span>function <span class="fstat-no" title="function not covered" >h(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return i+s.replace(a.regex.dots," .")}</span>function <span class="fstat-no" title="function not covered" >c(</span>t){<span class="cstat-no" title="statement not covered" >return t.toLowerCase().replace(/-(.)/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.toUpperCase()}</span>))}</span>function <span class="fstat-no" title="function not covered" >d(</span>t){<span class="cstat-no" title="statement not covered" >return t.charAt(0).toUpperCase()+t.slice(1)}</span>function <span class="fstat-no" title="function not covered" >g(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.toString(16);<span class="cstat-no" title="statement not covered" ></span>return 1==e.length?"0"+e:e}</span>function <span class="fstat-no" title="function not covered" >u(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(null==e||null==i){var a=<span class="cstat-no" title="statement not covered" >t.bbox();<span class="cstat-no" title="statement not covered" ></span>null==e?e=a.width/a.height*i:null==i&amp;&amp;(i=a.height/a.width*e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{width:e,height:i}}</span>function <span class="fstat-no" title="function not covered" >f(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return{x:e*t.a+i*t.c+0,y:e*t.b+i*t.d+0}}</span>function <span class="fstat-no" title="function not covered" >p(</span>t){<span class="cstat-no" title="statement not covered" >return{a:t[0],b:t[1],c:t[2],d:t[3],e:t[4],f:t[5]}}</span>function <span class="fstat-no" title="function not covered" >x(</span>t){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >t.childNodes.length-1;</span>i&gt;=0;i--)<span class="cstat-no" title="statement not covered" >t.childNodes[i]instanceof e.SVGElement&amp;&amp;x(t.childNodes[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.adopt(t).id(a.eid(t.nodeName))}</span>function <span class="fstat-no" title="function not covered" >b(</span>t){<span class="cstat-no" title="statement not covered" >return null==t.x&amp;&amp;(t.x=0,t.y=0,t.width=0,t.height=0),t.w=t.width,t.h=t.height,t.x2=t.x+t.width,t.y2=t.y+t.height,t.cx=t.x+t.width/2,t.cy=t.y+t.height/2,t}</span>function <span class="fstat-no" title="function not covered" >m(</span>t){<span class="cstat-no" title="statement not covered" >return Math.abs(t)&gt;1e-37?t:0}<span class="cstat-no" title="statement not covered" ></span>["fill","stroke"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>e[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(void 0===e)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"==typeof e||a.Color.isRgb(e)||e&amp;&amp;"function"==typeof e.fill)<span class="cstat-no" title="statement not covered" >this.attr(t,e);e</span>lse <span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >l[t].length-1;</span>i&gt;=0;i--)<span class="cstat-no" title="statement not covered" >null!=e[l[t][i]]&amp;&amp;this.attr(l.prefix(t,l[t][i]),e[l[t][i]]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}</span>,a.extend(a.Element,a.FX,e)}</span>)),a.extend(a.Element,a.FX,{translate:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.transform({x:t,y:e})}</span>,matrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("transform",new a.Matrix(6==arguments.length?[].slice.call(arguments):t))}</span>,opacity:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.attr("opacity",t)}</span>,dx:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.x(new a.Number(t).plus(this instanceof a.FX?0:this.x()),!0)}</span>,dy:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.y(new a.Number(t).plus(this instanceof a.FX?0:this.y()),!0)}</span>}),a.extend(a.Path,{length:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node.getTotalLength()}</span>,pointAt:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.node.getPointAtLength(t)}</span>}),a.Set=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >Array.isArray(t)?this.members=t:this.clear()}</span>,extend:{add:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments),</span>e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >this.members.push(t[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.index(t);<span class="cstat-no" title="statement not covered" ></span>return e&gt;-1&amp;&amp;this.members.splice(e,1),this}</span>,each:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.members.length;</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >t.apply(this.members[e],[e,this.members]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,clear:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.members=[],this}</span>,length:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.members.length}</span>,has:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.index(t)&gt;=0}</span>,index:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.members.indexOf(t)}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.members[t]}</span>,first:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.get(0)}</span>,last:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.get(this.members.length-1)}</span>,valueOf:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.members}</span>},construct:{set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new a.Set(t)}</span>}}),a.FX.Set=a.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.set=t}</span>}),a.Set.inherit=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var e in a.Shape.prototype)<span class="cstat-no" title="statement not covered" >"function"==typeof a.Shape.prototype[e]&amp;&amp;"function"!=typeof a.Set.prototype[e]&amp;&amp;t.push(e);<span class="cstat-no" title="statement not covered" >f</span></span>or(var e in t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.Set.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.members.length;</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >this.members[e]&amp;&amp;"function"==typeof this.members[e][t]&amp;&amp;this.members[e][t].apply(this.members[e],arguments);<span class="cstat-no" title="statement not covered" >r</span></span>eturn"animate"==t?this.fx||(this.fx=new a.FX.Set(this)):this}</span>}</span>)),t=[],a.FX.prototype)<span class="cstat-no" title="statement not covered" >"function"==typeof a.FX.prototype[e]&amp;&amp;"function"!=typeof a.FX.Set.prototype[e]&amp;&amp;t.push(e);<span class="cstat-no" title="statement not covered" >t</span></span>.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.FX.Set.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.set.members.length;</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >this.set.members[e].fx[t].apply(this.set.members[e].fx,arguments);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>}</span>))}</span>,a.extend(a.Element,{}),a.extend(a.Element,{remember:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >if("object"===t(arguments[0]))<span class="cstat-no" title="statement not covered" >for(var a in e)<span class="cstat-no" title="statement not covered" >this.remember(a,e[a]);e</span></span>lse{<span class="cstat-no" title="statement not covered" >if(1==arguments.length)<span class="cstat-no" title="statement not covered" >return this.memory()[e];<span class="cstat-no" title="statement not covered" >t</span></span>his.memory()[e]=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,forget:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(0==arguments.length)<span class="cstat-no" title="statement not covered" >this._memory={};e</span>lse <span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length-1;</span>t&gt;=0;t--)<span class="cstat-no" title="statement not covered" >delete this.memory()[arguments[t]];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}</span>,memory:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._memory||(this._memory={})}</span>}),a.get=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >i.getElementById(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >(t||"").toString().match(a.regex.reference);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e[1]}</span></span>(t)||t);<span class="cstat-no" title="statement not covered" ></span>return a.adopt(e)}</span>,a.select=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new a.Set(a.utils.map((e||i).querySelectorAll(t),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.adopt(t)}</span>)))}</span>,a.extend(a.Parent,{select:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.select(t,this.node)}</span>});v</span>ar v=<span class="cstat-no" title="statement not covered" >"abcdef".split("");<span class="cstat-no" title="statement not covered" ></span>if("function"!=typeof e.CustomEvent){var y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e=e||{bubbles:!1,cancelable:!1,detail:void 0};v</span>ar a=<span class="cstat-no" title="statement not covered" >i.createEvent("CustomEvent");<span class="cstat-no" title="statement not covered" ></span>return a.initCustomEvent(t,e.bubbles,e.cancelable,e.detail),a}</span>;<span class="cstat-no" title="statement not covered" ></span>y.prototype=e.Event.prototype,a.CustomEvent=y}</span>else <span class="cstat-no" title="statement not covered" >a.CustomEvent=e.CustomEvent;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>,"function"==typeof define&amp;&amp;define.amd?define((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return k(w,w.document)}</span>)):"object"===("undefined"==typeof exports?"undefined":t(exports))&amp;&amp;"undefined"!=typeof module?module.exports=w.document?k(w,w.document):<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return k(t,t.document)}</span>:w.SVG=k(w,w.document),</span></span>
/*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >SVG.Filter=SVG.invent({create:"filter",inherit:SVG.Parent,extend:{source:"SourceGraphic",sourceAlpha:"SourceAlpha",background:"BackgroundImage",backgroundAlpha:"BackgroundAlpha",fill:"FillPaint",stroke:"StrokePaint",autoSetIn:!0,put:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.add(t,e),!t.attr("in")&amp;&amp;this.autoSetIn&amp;&amp;t.attr("in",this.source),t.attr("result")||t.attr("result",t),t}</span>,blend:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.BlendEffect(t,e,i))}</span>,colorMatrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.ColorMatrixEffect(t,e))}</span>,convolveMatrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.ConvolveMatrixEffect(t))}</span>,componentTransfer:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.ComponentTransferEffect(t))}</span>,composite:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.CompositeEffect(t,e,i))}</span>,flood:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.FloodEffect(t,e))}</span>,offset:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.OffsetEffect(t,e))}</span>,image:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.ImageEffect(t))}</span>,merge:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >[void 0];<span class="cstat-no" title="statement not covered" ></span>for(var e in arguments)<span class="cstat-no" title="statement not covered" >t.push(arguments[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.put(new(SVG.MergeEffect.bind.apply(SVG.MergeEffect,t)))}</span>,gaussianBlur:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.GaussianBlurEffect(t,e))}</span>,morphology:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.MorphologyEffect(t,e))}</span>,diffuseLighting:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.DiffuseLightingEffect(t,e,i))}</span>,displacementMap:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.DisplacementMapEffect(t,e,i,a,s))}</span>,specularLighting:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.SpecularLightingEffect(t,e,i,a))}</span>,tile:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.TileEffect)}</span>,turbulence:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >return this.put(new SVG.TurbulenceEffect(t,e,i,a,s))}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"url(#"+this.attr("id")+")"}</span>}}),SVG.extend(SVG.Defs,{filter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.put(new SVG.Filter);<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof t&amp;&amp;t.call(e,e),e}</span>}),SVG.extend(SVG.Container,{filter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.defs().filter(t)}</span>}),SVG.extend(SVG.Element,SVG.G,SVG.Nested,{filter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.filterer=t instanceof SVG.Element?t:this.doc().filter(t),this.doc()&amp;&amp;this.filterer.doc()!==this.doc()&amp;&amp;this.doc().defs().add(this.filterer),this.attr("filter",this.filterer),this.filterer}</span>,unfilter:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.filterer&amp;&amp;!0===t&amp;&amp;this.filterer.remove(),delete this.filterer,this.attr("filter",null)}</span>}),SVG.Effect=SVG.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this)}</span>,inherit:SVG.Element,extend:{in:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.parent()&amp;&amp;this.parent().select('[result="'+this.attr("in")+'"]').get(0)||this.attr("in"):this.attr("in",t)}</span>,result:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.attr("result"):this.attr("result",t)}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.result()}</span>}}),SVG.ParentEffect=SVG.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this)}</span>,inherit:SVG.Parent,extend:{in:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.parent()&amp;&amp;this.parent().select('[result="'+this.attr("in")+'"]').get(0)||this.attr("in"):this.attr("in",t)}</span>,result:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.attr("result"):this.attr("result",t)}</span>,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.result()}</span>}});v</span>ar t=<span class="cstat-no" title="statement not covered" >{blend:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().blend(this,t,e)}</span>,colorMatrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().colorMatrix(t,e).in(this)}</span>,convolveMatrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().convolveMatrix(t).in(this)}</span>,componentTransfer:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().componentTransfer(t).in(this)}</span>,composite:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().composite(this,t,e)}</span>,flood:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().flood(t,e)}</span>,offset:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().offset(t,e).in(this)}</span>,image:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().image(t)}</span>,merge:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().merge.apply(this.parent(),[this].concat(arguments))}</span>,gaussianBlur:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().gaussianBlur(t,e).in(this)}</span>,morphology:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().morphology(t,e).in(this)}</span>,diffuseLighting:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().diffuseLighting(t,e,i).in(this)}</span>,displacementMap:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().displacementMap(this,t,e,i,a)}</span>,specularLighting:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().specularLighting(t,e,i,a).in(this)}</span>,tile:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().tile().in(this)}</span>,turbulence:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >return this.parent()&amp;&amp;this.parent().turbulence(t,e,i,a,s).in(this)}</span>};<span class="cstat-no" title="statement not covered" ></span>SVG.extend(SVG.Effect,t),SVG.extend(SVG.ParentEffect,t),SVG.ChildEffect=SVG.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this)}</span>,inherit:SVG.Element,extend:{in:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.attr("in",t)}</span>}});v</span>ar e=<span class="cstat-no" title="statement not covered" >{blend:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.attr({in:t,in2:e,mode:i||"normal"})}</span>,colorMatrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >"matrix"==t&amp;&amp;(e=s(e)),this.attr({type:t,values:void 0===e?null:e})}</span>,convolveMatrix:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t=s(t),this.attr({order:Math.sqrt(t.split(" ").length),kernelMatrix:t})}</span>,composite:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.attr({in:t,in2:e,operator:i})}</span>,flood:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.attr("flood-color",t),null!=e&amp;&amp;this.attr("flood-opacity",e)}</span>,offset:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.attr({dx:t,dy:e})}</span>,image:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.attr("href",t,SVG.xlink)}</span>,displacementMap:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >this.attr({in:t,in2:e,scale:i,xChannelSelector:a,yChannelSelector:s})}</span>,gaussianBlur:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >null!=t||null!=e?this.attr("stdDeviation",r(Array.prototype.slice.call(arguments))):this.attr("stdDeviation","0 0")}</span>,morphology:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.attr({operator:t,radius:e})}</span>,tile:<span class="fstat-no" title="function not covered" >fu</span>nction(){},turbulence:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s){<span class="cstat-no" title="statement not covered" >this.attr({numOctaves:e,seed:i,stitchTiles:a,baseFrequency:t,type:s})}</span>},</span>i=<span class="cstat-no" title="statement not covered" >{merge:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >if(arguments[0]instanceof SVG.Set){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>arguments[0].each((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this instanceof SVG.MergeNode?e.put(this):(this instanceof SVG.Effect||this instanceof SVG.ParentEffect)&amp;&amp;e.put(new SVG.MergeNode(this))}</span>))}</span>else{<span class="cstat-no" title="statement not covered" >t=Array.isArray(arguments[0])?arguments[0]:arguments;<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >t[i]instanceof SVG.MergeNode?this.put(t[i]):this.put(new SVG.MergeNode(t[i]))}</span></span>}</span>,componentTransfer:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.rgb=new SVG.Set,["r","g","b","a"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this[t]=new(SVG["Func"+t.toUpperCase()])("identity"),this.rgb.add(this[t]),this.node.appendChild(this[t].node)}</span>.bind(this)),t)<span class="cstat-no" title="statement not covered" >for(var e in t.rgb&amp;&amp;(["r","g","b"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this[e].attr(t.rgb)}</span>.bind(this)),delete t.rgb),t)<span class="cstat-no" title="statement not covered" >this[e].attr(t[e])}</span></span></span>,diffuseLighting:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.attr({surfaceScale:t,diffuseConstant:e,kernelUnitLength:i})}</span>,specularLighting:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){<span class="cstat-no" title="statement not covered" >this.attr({surfaceScale:t,diffuseConstant:e,specularExponent:i,kernelUnitLength:a})}</span>},</span>a=<span class="cstat-no" title="statement not covered" >{distantLight:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.attr({azimuth:t,elevation:e})}</span>,pointLight:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >this.attr({x:t,y:e,z:i})}</span>,spotLight:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a,s,r){<span class="cstat-no" title="statement not covered" >this.attr({x:t,y:e,z:i,pointsAtX:a,pointsAtY:s,pointsAtZ:r})}</span>,mergeNode:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.attr("in",t)}</span>};</span>function <span class="fstat-no" title="function not covered" >s(</span>t){<span class="cstat-no" title="statement not covered" >return Array.isArray(t)&amp;&amp;(t=new SVG.Array(t)),t.toString().replace(/^\s+/,"").replace(/\s+$/,"").replace(/\s+/g," ")}</span>function <span class="fstat-no" title="function not covered" >r(</span>t){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length,</span>a=<span class="cstat-no" title="statement not covered" >[];</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >a.push(t[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.join(" ")}</span>function <span class="fstat-no" title="function not covered" >n(</span>){var t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" ></span>for(var e in"function"==typeof arguments[arguments.length-1]&amp;&amp;(t=arguments[arguments.length-1],Array.prototype.splice.call(arguments,arguments.length-1,1)),arguments)<span class="cstat-no" title="statement not covered" >for(var i in arguments[e])<span class="cstat-no" title="statement not covered" >t(arguments[e][i],i,arguments[e])}<span class="cstat-no" title="statement not covered" ></span></span></span>["r","g","b","a"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a["Func"+t.toUpperCase()]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(this.attr("type",t),t){case"table":<span class="cstat-no" title="statement not covered" >this.attr("tableValues",arguments[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"linear":<span class="cstat-no" title="statement not covered" >this.attr("slope",arguments[1]),this.attr("intercept",arguments[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"gamma":<span class="cstat-no" title="statement not covered" >this.attr("amplitude",arguments[1]),this.attr("exponent",arguments[2]),this.attr("offset",arguments[2])}</span>}</span>}</span>)),n(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >e.charAt(0).toUpperCase()+e.slice(1);<span class="cstat-no" title="statement not covered" ></span>SVG[i+"Effect"]=SVG.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,SVG.create("fe"+i)),t.apply(this,arguments),this.result(this.attr("id")+"Out")}</span>,inherit:SVG.Effect,extend:{}})}</span>)),n(i,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >e.charAt(0).toUpperCase()+e.slice(1);<span class="cstat-no" title="statement not covered" ></span>SVG[i+"Effect"]=SVG.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,SVG.create("fe"+i)),t.apply(this,arguments),this.result(this.attr("id")+"Out")}</span>,inherit:SVG.ParentEffect,extend:{}})}</span>)),n(a,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >e.charAt(0).toUpperCase()+e.slice(1);<span class="cstat-no" title="statement not covered" ></span>SVG[i]=SVG.invent({create:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.constructor.call(this,SVG.create("fe"+i)),t.apply(this,arguments)}</span>,inherit:SVG.ChildEffect,extend:{}})}</span>)),SVG.extend(SVG.MergeEffect,{in:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof SVG.MergeNode?this.add(t,0):this.add(new SVG.MergeNode(t),0),this}</span>}),SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{in2:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.parent()&amp;&amp;this.parent().select('[result="'+this.attr("in2")+'"]').get(0)||this.attr("in2"):this.attr("in2",t)}</span>}),SVG.filter={sepiatone:[.343,.669,.119,0,0,.249,.626,.13,0,0,.172,.334,.111,0,0,0,0,0,1,0]}}</span>.call(void 0),<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>t,s,r,n,o,l,h){<span class="cstat-no" title="statement not covered" >for(var c=<span class="cstat-no" title="statement not covered" >t.slice(s,r||h),</span>d=<span class="cstat-no" title="statement not covered" >n.slice(o,l||h),</span>g=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >{pos:[0,0],start:[0,0]},</span>f=<span class="cstat-no" title="statement not covered" >{pos:[0,0],start:[0,0]};</span>;){<span class="cstat-no" title="statement not covered" >if(c[g]=e.call(u,c[g]),d[g]=e.call(f,d[g]),c[g][0]!=d[g][0]||"M"==c[g][0]||"A"==c[g][0]&amp;&amp;(c[g][4]!=d[g][4]||c[g][5]!=d[g][5])?(Array.prototype.splice.apply(c,[g,1].concat(a.call(u,c[g]))),Array.prototype.splice.apply(d,[g,1].concat(a.call(f,d[g])))):(c[g]=i.call(u,c[g]),d[g]=i.call(f,d[g])),++g==c.length&amp;&amp;g==d.length)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >g</span></span>==c.length&amp;&amp;c.push(["C",u.pos[0],u.pos[1],u.pos[0],u.pos[1],u.pos[0],u.pos[1]]),g==d.length&amp;&amp;d.push(["C",f.pos[0],f.pos[1],f.pos[0],f.pos[1],f.pos[0],f.pos[1]])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{start:c,dest:d}}</span>function <span class="fstat-no" title="function not covered" >e(</span>t){<span class="cstat-no" title="statement not covered" >switch(t[0]){case"z":case"Z":<span class="cstat-no" title="statement not covered" >t[0]="L",t[1]=this.start[0],t[2]=this.start[1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"H":<span class="cstat-no" title="statement not covered" >t[0]="L",t[2]=this.pos[1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"V":<span class="cstat-no" title="statement not covered" >t[0]="L",t[2]=t[1],t[1]=this.pos[0];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"T":<span class="cstat-no" title="statement not covered" >t[0]="Q",t[3]=t[1],t[4]=t[2],t[1]=this.reflection[1],t[2]=this.reflection[0];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"S":<span class="cstat-no" title="statement not covered" >t[0]="C",t[6]=t[4],t[5]=t[3],t[4]=t[2],t[3]=t[1],t[2]=this.reflection[1],t[1]=this.reflection[0]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >i(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>return this.pos=[t[e-2],t[e-1]],-1!="SCQT".indexOf(t[0])&amp;&amp;(this.reflection=[2*this.pos[0]-t[e-4],2*this.pos[1]-t[e-3]]),t}</span>function <span class="fstat-no" title="function not covered" >a(</span>t){var e=<span class="cstat-no" title="statement not covered" >[t];<span class="cstat-no" title="statement not covered" ></span>switch(t[0]){case"M":<span class="cstat-no" title="statement not covered" >return this.pos=this.start=[t[1],t[2]],e;c</span>ase"L":<span class="cstat-no" title="statement not covered" >t[5]=t[3]=t[1],t[6]=t[4]=t[2],t[1]=this.pos[0],t[2]=this.pos[1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Q":<span class="cstat-no" title="statement not covered" >t[6]=t[4],t[5]=t[3],t[4]=1*t[4]/3+2*t[2]/3,t[3]=1*t[3]/3+2*t[1]/3,t[2]=1*this.pos[1]/3+2*t[2]/3,t[1]=1*this.pos[0]/3+2*t[1]/3;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"A":<span class="cstat-no" title="statement not covered" >t=(e=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i,a,s,r,n,o,l,h,c,d,g,u,f,p,x,b,m,v,y,w,k,A,S,C,L,P,T=<span class="cstat-no" title="statement not covered" >Math.abs(e[1]),</span>z=<span class="cstat-no" title="statement not covered" >Math.abs(e[2]),</span>I=<span class="cstat-no" title="statement not covered" >e[3]%360,</span>M=<span class="cstat-no" title="statement not covered" >e[4],</span>E=<span class="cstat-no" title="statement not covered" >e[5],</span>X=<span class="cstat-no" title="statement not covered" >e[6],</span>Y=<span class="cstat-no" title="statement not covered" >e[7],</span>F=<span class="cstat-no" title="statement not covered" >new SVG.Point(t),</span>R=<span class="cstat-no" title="statement not covered" >new SVG.Point(X,Y),</span>D=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0===T||0===z||F.x===R.x&amp;&amp;F.y===R.y)<span class="cstat-no" title="statement not covered" >return[["C",F.x,F.y,R.x,R.y,R.x,R.y]];<span class="cstat-no" title="statement not covered" >i</span></span>=new SVG.Point((F.x-R.x)/2,(F.y-R.y)/2).transform((new SVG.Matrix).rotate(I)),(a=i.x*i.x/(T*T)+i.y*i.y/(z*z))&gt;1&amp;&amp;(a=Math.sqrt(a),T*=a,z*=a);<span class="cstat-no" title="statement not covered" >s</span>=(new SVG.Matrix).rotate(I).scale(1/T,1/z).rotate(-I),F=F.transform(s),R=R.transform(s),r=[R.x-F.x,R.y-F.y],o=r[0]*r[0]+r[1]*r[1],n=Math.sqrt(o),r[0]/=n,r[1]/=n,l=o&lt;4?Math.sqrt(1-o/4):0,M===E&amp;&amp;(l*=-1);<span class="cstat-no" title="statement not covered" >h</span>=new SVG.Point((R.x+F.x)/2+l*-r[1],(R.y+F.y)/2+l*r[0]),c=new SVG.Point(F.x-h.x,F.y-h.y),d=new SVG.Point(R.x-h.x,R.y-h.y),g=Math.acos(c.x/Math.sqrt(c.x*c.x+c.y*c.y)),c.y&lt;0&amp;&amp;(g*=-1);<span class="cstat-no" title="statement not covered" >u</span>=Math.acos(d.x/Math.sqrt(d.x*d.x+d.y*d.y)),d.y&lt;0&amp;&amp;(u*=-1);<span class="cstat-no" title="statement not covered" >E</span>&amp;&amp;g&gt;u&amp;&amp;(u+=2*Math.PI);<span class="cstat-no" title="statement not covered" >!</span>E&amp;&amp;g&lt;u&amp;&amp;(u-=2*Math.PI);<span class="cstat-no" title="statement not covered" >f</span>or(p=Math.ceil(2*Math.abs(g-u)/Math.PI),b=[],m=g,f=(u-g)/p,x=4*Math.tan(f/4)/3,k=0;k&lt;=p;k++)<span class="cstat-no" title="statement not covered" >y=Math.cos(m),v=Math.sin(m),w=new SVG.Point(h.x+y,h.y+v),b[k]=[new SVG.Point(w.x+x*v,w.y-x*y),w,new SVG.Point(w.x-x*v,w.y+x*y)],m+=f;<span class="cstat-no" title="statement not covered" >f</span></span>or(b[0][0]=b[0][1].clone(),b[b.length-1][2]=b[b.length-1][1].clone(),s=(new SVG.Matrix).rotate(I).scale(T,z).rotate(-I),k=0,A=b.length;k&lt;A;k++)<span class="cstat-no" title="statement not covered" >b[k][0]=b[k][0].transform(s),b[k][1]=b[k][1].transform(s),b[k][2]=b[k][2].transform(s);<span class="cstat-no" title="statement not covered" >f</span></span>or(k=1,A=b.length;k&lt;A;k++)<span class="cstat-no" title="statement not covered" >w=b[k-1][2],S=w.x,C=w.y,w=b[k][0],L=w.x,P=w.y,w=b[k][1],X=w.x,Y=w.y,D.push(["C",S,C,L,P,X,Y]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn D}</span>(this.pos,t))[0]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t[0]="C",this.pos=[t[5],t[6]],this.reflection=[2*t[5]-t[3],2*t[6]-t[4]],e}</span>function <span class="fstat-no" title="function not covered" >s(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!1===e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;a;++i)<span class="cstat-no" title="statement not covered" >if("M"==t[i][0])<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>SVG.extend(SVG.PathArray,{morph:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >this.value,</span>a=<span class="cstat-no" title="statement not covered" >this.parse(e),</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>l=<span class="cstat-no" title="statement not covered" >!1;</span>!1!==r||!1!==n;){var h;<span class="cstat-no" title="statement not covered" >o=s(i,!1!==r&amp;&amp;r+1),l=s(a,!1!==n&amp;&amp;n+1),!1===r&amp;&amp;(r=0==(h=new SVG.PathArray(c.start).bbox()).height||0==h.width?i.push(i[0])-1:i.push(["M",h.x+h.width/2,h.y+h.height/2])-1),!1===n&amp;&amp;(n=0==(h=new SVG.PathArray(c.dest).bbox()).height||0==h.width?a.push(a[0])-1:a.push(["M",h.x+h.width/2,h.y+h.height/2])-1);v</span>ar c=<span class="cstat-no" title="statement not covered" >t(i,r,o,a,n,l);<span class="cstat-no" title="statement not covered" ></span>i=i.slice(0,r).concat(c.start,!1===o?[]:i.slice(o)),a=a.slice(0,n).concat(c.dest,!1===l?[]:a.slice(l)),r=!1!==o&amp;&amp;r+c.start.length,n=!1!==l&amp;&amp;n+c.dest.length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.value=i,this.destination=new SVG.PathArray,this.destination.value=a,this}</span>})}</span>(),
/*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>t){<span class="cstat-no" title="statement not covered" >t.remember("_draggable",this),this.el=t}<span class="cstat-no" title="statement not covered" ></span>t.prototype.init=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.constraint=t,this.value=e,this.el.on("mousedown.drag",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.start(t)}</span>)),this.el.on("touchstart.drag",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.start(t)}</span>))}</span>,t.prototype.transformPoint=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >(t=t||window.event).changedTouches&amp;&amp;t.changedTouches[0]||t;<span class="cstat-no" title="statement not covered" ></span>return this.p.x=i.clientX-(e||0),this.p.y=i.clientY,this.p.matrixTransform(this.m)}</span>,t.prototype.getBBox=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.el.bbox();<span class="cstat-no" title="statement not covered" ></span>return this.el instanceof SVG.Nested&amp;&amp;(t=this.el.rbox()),(this.el instanceof SVG.G||this.el instanceof SVG.Use||this.el instanceof SVG.Nested)&amp;&amp;(t.x=this.el.x(),t.y=this.el.y()),t}</span>,t.prototype.start=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("click"!=t.type&amp;&amp;"mousedown"!=t.type&amp;&amp;"mousemove"!=t.type||1==(t.which||t.buttons)){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.el.fire("beforedrag",{event:t,handler:this}),!this.el.event().defaultPrevented){<span class="cstat-no" title="statement not covered" >t.preventDefault(),t.stopPropagation(),this.parent=this.parent||this.el.parent(SVG.Nested)||this.el.parent(SVG.Doc),this.p=this.parent.node.createSVGPoint(),this.m=this.el.node.getScreenCTM().inverse();v</span>ar i,a=<span class="cstat-no" title="statement not covered" >this.getBBox();<span class="cstat-no" title="statement not covered" ></span>if(this.el instanceof SVG.Text)<span class="cstat-no" title="statement not covered" >switch(i=this.el.node.getComputedTextLength(),this.el.attr("text-anchor")){case"middle":<span class="cstat-no" title="statement not covered" >i/=2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"start":<span class="cstat-no" title="statement not covered" >i=0}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.startPoints={point:this.transformPoint(t,i),box:a,transform:this.el.transform()},SVG.on(window,"mousemove.drag",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.drag(t)}</span>)),SVG.on(window,"touchmove.drag",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.drag(t)}</span>)),SVG.on(window,"mouseup.drag",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.end(t)}</span>)),SVG.on(window,"touchend.drag",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.end(t)}</span>)),this.el.fire("dragstart",{event:t,p:this.startPoints.point,m:this.m,handler:this})}</span>}</span>}</span>,t.prototype.drag=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.getBBox(),</span>i=<span class="cstat-no" title="statement not covered" >this.transformPoint(t),</span>a=<span class="cstat-no" title="statement not covered" >this.startPoints.box.x+i.x-this.startPoints.point.x,</span>s=<span class="cstat-no" title="statement not covered" >this.startPoints.box.y+i.y-this.startPoints.point.y,</span>r=<span class="cstat-no" title="statement not covered" >this.constraint,</span>n=<span class="cstat-no" title="statement not covered" >i.x-this.startPoints.point.x,</span>o=<span class="cstat-no" title="statement not covered" >i.y-this.startPoints.point.y;<span class="cstat-no" title="statement not covered" ></span>if(this.el.fire("dragmove",{event:t,p:i,m:this.m,handler:this}),this.el.event().defaultPrevented)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f("function"==typeof r){var l=<span class="cstat-no" title="statement not covered" >r.call(this.el,a,s,this.m);<span class="cstat-no" title="statement not covered" ></span>"boolean"==typeof l&amp;&amp;(l={x:l,y:l}),!0===l.x?this.el.x(a):!1!==l.x&amp;&amp;this.el.x(l.x),!0===l.y?this.el.y(s):!1!==l.y&amp;&amp;this.el.y(l.y)}</span>else<span class="cstat-no" title="statement not covered" >"object"==typeof r&amp;&amp;(null!=r.minX&amp;&amp;a&lt;r.minX?n=(a=r.minX)-this.startPoints.box.x:null!=r.maxX&amp;&amp;a&gt;r.maxX-e.width&amp;&amp;(n=(a=r.maxX-e.width)-this.startPoints.box.x),null!=r.minY&amp;&amp;s&lt;r.minY?o=(s=r.minY)-this.startPoints.box.y:null!=r.maxY&amp;&amp;s&gt;r.maxY-e.height&amp;&amp;(o=(s=r.maxY-e.height)-this.startPoints.box.y),null!=r.snapToGrid&amp;&amp;(a-=a%r.snapToGrid,s-=s%r.snapToGrid,n-=n%r.snapToGrid,o-=o%r.snapToGrid),this.el instanceof SVG.G?this.el.matrix(this.startPoints.transform).transform({x:n,y:o},!0):this.el.move(a,s));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>,t.prototype.end=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.drag(t);<span class="cstat-no" title="statement not covered" ></span>this.el.fire("dragend",{event:t,p:e,m:this.m,handler:this}),SVG.off(window,"mousemove.drag"),SVG.off(window,"touchmove.drag"),SVG.off(window,"mouseup.drag"),SVG.off(window,"touchend.drag")}</span>,SVG.extend(SVG.Element,{draggable:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >"function"!=typeof e&amp;&amp;"object"!=typeof e||(i=e,e=!0);v</span>ar a=<span class="cstat-no" title="statement not covered" >this.remember("_draggable")||new t(this);<span class="cstat-no" title="statement not covered" ></span>return(e=void 0===e||e)?a.init(i||{},e):(this.off("mousedown.drag"),this.off("touchstart.drag")),this}</span>})}</span>.call(void 0),<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>t){<span class="cstat-no" title="statement not covered" >this.el=t,t.remember("_selectHandler",this),this.pointSelection={isSelected:!1},this.rectSelection={isSelected:!1},this.pointsList={lt:[0,0],rt:["width",0],rb:["width","height"],lb:[0,"height"],t:["width",0],r:["width","height"],b:["width","height"],l:[0,"height"]},this.pointCoord=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){var a=<span class="cstat-no" title="statement not covered" >"string"!=typeof t?t:e[t];<span class="cstat-no" title="statement not covered" ></span>return i?a/2:a}</span>,this.pointCoords=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.pointsList[t];<span class="cstat-no" title="statement not covered" ></span>return{x:this.pointCoord(i[0],e,"t"===t||"b"===t),y:this.pointCoord(i[1],e,"r"===t||"l"===t)}}</span>}<span class="cstat-no" title="statement not covered" ></span>t.prototype.init=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.el.bbox();<span class="cstat-no" title="statement not covered" ></span>this.options={};v</span>ar a=<span class="cstat-no" title="statement not covered" >this.el.selectize.defaults.points;<span class="cstat-no" title="statement not covered" ></span>for(var s in this.el.selectize.defaults)<span class="cstat-no" title="statement not covered" >this.options[s]=this.el.selectize.defaults[s],void 0!==e[s]&amp;&amp;(this.options[s]=e[s]);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >["points","pointsExclude"];<span class="cstat-no" title="statement not covered" ></span>for(var s in r){var n=<span class="cstat-no" title="statement not covered" >this.options[r[s]];<span class="cstat-no" title="statement not covered" ></span>"string"==typeof n?n=n.length&gt;0?n.split(/\s*,\s*/i):[]:"boolean"==typeof n&amp;&amp;"points"===r[s]&amp;&amp;(n=n?a:[]),this.options[r[s]]=n}<span class="cstat-no" title="statement not covered" ></span>t</span>his.options.points=[a,this.options.points].reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.indexOf(t)&gt;-1}</span>))}</span>)),this.options.points=[this.options.points,this.options.pointsExclude].reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.indexOf(t)&lt;0}</span>))}</span>)),this.parent=this.el.parent(),this.nested=this.nested||this.parent.group(),this.nested.matrix(new SVG.Matrix(this.el).translate(i.x,i.y)),this.options.deepSelect&amp;&amp;-1!==["line","polyline","polygon"].indexOf(this.el.type)?this.selectPoints(t):this.selectRect(t),this.observe(),this.cleanup()}</span>,t.prototype.selectPoints=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.pointSelection.isSelected=t,this.pointSelection.set?this:(this.pointSelection.set=this.parent.set(),this.drawPoints(),this)}</span>,t.prototype.getPointArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.el.bbox();<span class="cstat-no" title="statement not covered" ></span>return this.el.array().valueOf().map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0]-t.x,e[1]-t.y]}</span>))}</span>,t.prototype.drawPoints=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.getPointArray(),</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >e.length;</span>i&lt;a;++i){var s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >(i=i||window.event).preventDefault?i.preventDefault():i.returnValue=!1,i.stopPropagation();v</span>ar a=<span class="cstat-no" title="statement not covered" >i.pageX||i.touches[0].pageX,</span>s=<span class="cstat-no" title="statement not covered" >i.pageY||i.touches[0].pageY;<span class="cstat-no" title="statement not covered" ></span>t.el.fire("point",{x:a,y:s,i:e,event:i})}</span>}</span>(i),</span>r=<span class="cstat-no" title="statement not covered" >this.drawPoint(e[i][0],e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints+"_point").on("touchstart",s).on("mousedown",s);<span class="cstat-no" title="statement not covered" ></span>this.pointSelection.set.add(r)}</span>}</span>,t.prototype.drawPoint=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.options.pointType;<span class="cstat-no" title="statement not covered" ></span>switch(i){case"circle":<span class="cstat-no" title="statement not covered" >return this.drawCircle(t,e);c</span>ase"rect":<span class="cstat-no" title="statement not covered" >return this.drawRect(t,e);d</span>efault:<span class="cstat-no" title="statement not covered" >if("function"==typeof i)<span class="cstat-no" title="statement not covered" >return i.call(this,t,e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("Unknown "+i+" point type!")}</span>}</span>,t.prototype.drawCircle=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.nested.circle(this.options.pointSize).center(t,e)}</span>,t.prototype.drawRect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.nested.rect(this.options.pointSize,this.options.pointSize).center(t,e)}</span>,t.prototype.updatePointSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.getPointArray();<span class="cstat-no" title="statement not covered" ></span>this.pointSelection.set.each((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.cx()===t[e][0]&amp;&amp;this.cy()===t[e][1]||this.center(t[e][0],t[e][1])}</span>))}</span>,t.prototype.updateRectSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.el.bbox();<span class="cstat-no" title="statement not covered" ></span>if(this.rectSelection.set.get(0).attr({width:e.width,height:e.height}),this.options.points.length&amp;&amp;this.options.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){var s=<span class="cstat-no" title="statement not covered" >t.pointCoords(i,e);<span class="cstat-no" title="statement not covered" ></span>t.rectSelection.set.get(a+1).center(s.x,s.y)}</span>)),this.options.rotationPoint){var i=<span class="cstat-no" title="statement not covered" >this.rectSelection.set.length();<span class="cstat-no" title="statement not covered" ></span>this.rectSelection.set.get(i-1).center(e.width/2,20)}</span>}</span>,t.prototype.selectRect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.el.bbox();</span>function <span class="fstat-no" title="function not covered" >a(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >(i=i||window.event).preventDefault?i.preventDefault():i.returnValue=!1,i.stopPropagation();v</span>ar a=<span class="cstat-no" title="statement not covered" >i.pageX||i.touches[0].pageX,</span>s=<span class="cstat-no" title="statement not covered" >i.pageY||i.touches[0].pageY;<span class="cstat-no" title="statement not covered" ></span>e.el.fire(t,{x:a,y:s,event:i})}</span>}<span class="cstat-no" title="statement not covered" ></span>if(this.rectSelection.isSelected=t,this.rectSelection.set=this.rectSelection.set||this.parent.set(),this.rectSelection.set.get(0)||this.rectSelection.set.add(this.nested.rect(i.width,i.height).addClass(this.options.classRect)),this.options.points.length&amp;&amp;this.rectSelection.set.length()&lt;2){<span class="cstat-no" title="statement not covered" >this.options.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){var r=<span class="cstat-no" title="statement not covered" >e.pointCoords(t,i),</span>n=<span class="cstat-no" title="statement not covered" >e.drawPoint(r.x,r.y).attr("class",e.options.classPoints+"_"+t).on("mousedown",a(t)).on("touchstart",a(t));<span class="cstat-no" title="statement not covered" ></span>e.rectSelection.set.add(n)}</span>)),this.rectSelection.set.each((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.addClass(e.options.classPoints)}</span>))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.options.rotationPoint&amp;&amp;(this.options.points&amp;&amp;!this.rectSelection.set.get(9)||!this.options.points&amp;&amp;!this.rectSelection.set.get(1))){var s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >(t=t||window.event).preventDefault?t.preventDefault():t.returnValue=!1,t.stopPropagation();v</span>ar i=<span class="cstat-no" title="statement not covered" >t.pageX||t.touches[0].pageX,</span>a=<span class="cstat-no" title="statement not covered" >t.pageY||t.touches[0].pageY;<span class="cstat-no" title="statement not covered" ></span>e.el.fire("rot",{x:i,y:a,event:t})}</span>,</span>r=<span class="cstat-no" title="statement not covered" >this.drawPoint(i.width/2,20).attr("class",this.options.classPoints+"_rot").on("touchstart",s).on("mousedown",s);<span class="cstat-no" title="statement not covered" ></span>this.rectSelection.set.add(r)}</span>}</span>,t.prototype.handler=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.el.bbox();<span class="cstat-no" title="statement not covered" ></span>this.nested.matrix(new SVG.Matrix(this.el).translate(t.x,t.y)),this.rectSelection.isSelected&amp;&amp;this.updateRectSelection(),this.pointSelection.isSelected&amp;&amp;this.updatePointSelection()}</span>,t.prototype.observe=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(MutationObserver)<span class="cstat-no" title="statement not covered" >if(this.rectSelection.isSelected||this.pointSelection.isSelected)<span class="cstat-no" title="statement not covered" >this.observerInst=this.observerInst||new MutationObserver((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.handler()}</span>)),this.observerInst.observe(this.el.node,{attributes:!0});e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.observerInst.disconnect(),delete this.observerInst}</span>catch(t){}e</span></span>lse <span class="cstat-no" title="statement not covered" >this.el.off("DOMAttrModified.select"),(this.rectSelection.isSelected||this.pointSelection.isSelected)&amp;&amp;this.el.on("DOMAttrModified.select",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.handler()}</span>))}</span></span>,t.prototype.cleanup=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!this.rectSelection.isSelected&amp;&amp;this.rectSelection.set&amp;&amp;(this.rectSelection.set.each((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.remove()}</span>)),this.rectSelection.set.clear(),delete this.rectSelection.set),!this.pointSelection.isSelected&amp;&amp;this.pointSelection.set&amp;&amp;(this.pointSelection.set.each((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.remove()}</span>)),this.pointSelection.set.clear(),delete this.pointSelection.set),this.pointSelection.isSelected||this.rectSelection.isSelected||(this.nested.remove(),delete this.nested)}</span>,SVG.extend(SVG.Element,{selectize:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >return"object"==typeof e&amp;&amp;(i=e,e=!0),(this.remember("_selectHandler")||new t(this)).init(void 0===e||e,i||{}),this}</span>}),SVG.Element.prototype.selectize.defaults={points:["lt","rt","rb","lb","t","r","b","l"],pointsExclude:[],classRect:"svg_select_boundingRect",classPoints:"svg_select_points",pointSize:7,rotationPoint:!0,deepSelect:!1,pointType:"circle"}}</span>(),<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>t){<span class="cstat-no" title="statement not covered" >t.remember("_resizeHandler",this),this.el=t,this.parameters={},this.lastUpdateCall=null,this.p=t.doc().node.createSVGPoint()}<span class="cstat-no" title="statement not covered" ></span>t.prototype.transformPoint=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return this.p.x=t-(this.offset.x-window.pageXOffset),this.p.y=e-(this.offset.y-window.pageYOffset),this.p.matrixTransform(i||this.m)}</span>,t.prototype._extractPosition=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{x:null!=t.clientX?t.clientX:t.touches[0].clientX,y:null!=t.clientY?t.clientY:t.touches[0].clientY}}</span>,t.prototype.init=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.stop(),"stop"!==t){<span class="cstat-no" title="statement not covered" >for(var i in this.options={},this.el.resize.defaults)<span class="cstat-no" title="statement not covered" >this.options[i]=this.el.resize.defaults[i],void 0!==t[i]&amp;&amp;(this.options[i]=t[i]);<span class="cstat-no" title="statement not covered" >t</span></span>his.el.on("lt.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("rt.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("rb.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("lb.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("t.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("r.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("b.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("l.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("rot.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.el.on("point.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.resize(t||window.event)}</span>)),this.update()}</span>}</span>,t.prototype.stop=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.el.off("lt.resize"),this.el.off("rt.resize"),this.el.off("rb.resize"),this.el.off("lb.resize"),this.el.off("t.resize"),this.el.off("r.resize"),this.el.off("b.resize"),this.el.off("l.resize"),this.el.off("rot.resize"),this.el.off("point.resize"),this}</span>,t.prototype.resize=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.m=this.el.node.getScreenCTM().inverse(),this.offset={x:window.pageXOffset,y:window.pageYOffset};v</span>ar i=<span class="cstat-no" title="statement not covered" >this._extractPosition(t.detail.event);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters={type:this.el.type,p:this.transformPoint(i.x,i.y),x:t.detail.x,y:t.detail.y,box:this.el.bbox(),rotation:this.el.transform().rotation},"text"===this.el.type&amp;&amp;(this.parameters.fontSize=this.el.attr()["font-size"]),void 0!==t.detail.i){var a=<span class="cstat-no" title="statement not covered" >this.el.array().valueOf();<span class="cstat-no" title="statement not covered" ></span>this.parameters.i=t.detail.i,this.parameters.pointCoords=[a[t.detail.i][0],a[t.detail.i][1]]}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(t.type){case"lt":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.width-i[0]&gt;0&amp;&amp;this.parameters.box.height-i[1]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return this.el.move(this.parameters.box.x+i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize-i[0]);<span class="cstat-no" title="statement not covered" >i</span></span>=this.checkAspectRatio(i),this.el.move(this.parameters.box.x+i[0],this.parameters.box.y+i[1]).size(this.parameters.box.width-i[0],this.parameters.box.height-i[1])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rt":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,2);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.width+i[0]&gt;0&amp;&amp;this.parameters.box.height-i[1]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return this.el.move(this.parameters.box.x-i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize+i[0]);<span class="cstat-no" title="statement not covered" >i</span></span>=this.checkAspectRatio(i,!0),this.el.move(this.parameters.box.x,this.parameters.box.y+i[1]).size(this.parameters.box.width+i[0],this.parameters.box.height-i[1])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rb":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,0);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.width+i[0]&gt;0&amp;&amp;this.parameters.box.height+i[1]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return this.el.move(this.parameters.box.x-i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize+i[0]);<span class="cstat-no" title="statement not covered" >i</span></span>=this.checkAspectRatio(i),this.el.move(this.parameters.box.x,this.parameters.box.y).size(this.parameters.box.width+i[0],this.parameters.box.height+i[1])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"lb":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,1);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.width-i[0]&gt;0&amp;&amp;this.parameters.box.height+i[1]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return this.el.move(this.parameters.box.x+i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize-i[0]);<span class="cstat-no" title="statement not covered" >i</span></span>=this.checkAspectRatio(i,!0),this.el.move(this.parameters.box.x+i[0],this.parameters.box.y).size(this.parameters.box.width-i[0],this.parameters.box.height+i[1])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"t":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,2);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.height-i[1]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.el.move(this.parameters.box.x,this.parameters.box.y+i[1]).height(this.parameters.box.height-i[1])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"r":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,0);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.width+i[0]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.el.move(this.parameters.box.x,this.parameters.box.y).width(this.parameters.box.width+i[0])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"b":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,0);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.height+i[1]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.el.move(this.parameters.box.x,this.parameters.box.y).height(this.parameters.box.height+i[1])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"l":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,1);<span class="cstat-no" title="statement not covered" ></span>if(this.parameters.box.width-i[0]&gt;0){<span class="cstat-no" title="statement not covered" >if("text"===this.parameters.type)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.el.move(this.parameters.box.x+i[0],this.parameters.box.y).width(this.parameters.box.width-i[0])}</span>}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rot":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >t+this.parameters.p.x,</span>a=<span class="cstat-no" title="statement not covered" >e+this.parameters.p.y,</span>s=<span class="cstat-no" title="statement not covered" >Math.atan2(this.parameters.p.y-this.parameters.box.y-this.parameters.box.height/2,this.parameters.p.x-this.parameters.box.x-this.parameters.box.width/2),</span>r=<span class="cstat-no" title="statement not covered" >Math.atan2(a-this.parameters.box.y-this.parameters.box.height/2,i-this.parameters.box.x-this.parameters.box.width/2),</span>n=<span class="cstat-no" title="statement not covered" >this.parameters.rotation+180*(r-s)/Math.PI+this.options.snapToAngle/2;<span class="cstat-no" title="statement not covered" ></span>this.el.center(this.parameters.box.cx,this.parameters.box.cy).rotate(n-n%this.options.snapToAngle,this.parameters.box.cx,this.parameters.box.cy)}</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"point":<span class="cstat-no" title="statement not covered" >this.calc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.snapToGrid(t,e,this.parameters.pointCoords[0],this.parameters.pointCoords[1]),</span>a=<span class="cstat-no" title="statement not covered" >this.el.array().valueOf();<span class="cstat-no" title="statement not covered" ></span>a[this.parameters.i][0]=this.parameters.pointCoords[0]+i[0],a[this.parameters.i][1]=this.parameters.pointCoords[1]+i[1],this.el.plot(a)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.el.fire("resizestart",{dx:this.parameters.x,dy:this.parameters.y,event:t}),SVG.on(window,"touchmove.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.update(t||window.event)}</span>)),SVG.on(window,"touchend.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.done()}</span>)),SVG.on(window,"mousemove.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.update(t||window.event)}</span>)),SVG.on(window,"mouseup.resize",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.done()}</span>))}</span>,t.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t){var e=<span class="cstat-no" title="statement not covered" >this._extractPosition(t),</span>i=<span class="cstat-no" title="statement not covered" >this.transformPoint(e.x,e.y),</span>a=<span class="cstat-no" title="statement not covered" >i.x-this.parameters.p.x,</span>s=<span class="cstat-no" title="statement not covered" >i.y-this.parameters.p.y;<span class="cstat-no" title="statement not covered" ></span>this.lastUpdateCall=[a,s],this.calc(a,s),this.el.fire("resizing",{dx:a,dy:s,event:t})}</span>else <span class="cstat-no" title="statement not covered" >this.lastUpdateCall&amp;&amp;this.calc(this.lastUpdateCall[0],this.lastUpdateCall[1])}</span></span>,t.prototype.done=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.lastUpdateCall=null,SVG.off(window,"mousemove.resize"),SVG.off(window,"mouseup.resize"),SVG.off(window,"touchmove.resize"),SVG.off(window,"touchend.resize"),this.el.fire("resizedone")}</span>,t.prototype.snapToGrid=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s;<span class="cstat-no" title="statement not covered" >return void 0!==a?s=[(i+t)%this.options.snapToGrid,(a+e)%this.options.snapToGrid]:(i=null==i?3:i,s=[(this.parameters.box.x+t+(1&amp;i?0:this.parameters.box.width))%this.options.snapToGrid,(this.parameters.box.y+e+(2&amp;i?0:this.parameters.box.height))%this.options.snapToGrid]),t&lt;0&amp;&amp;(s[0]-=this.options.snapToGrid),e&lt;0&amp;&amp;(s[1]-=this.options.snapToGrid),t-=Math.abs(s[0])&lt;this.options.snapToGrid/2?s[0]:s[0]-(t&lt;0?-this.options.snapToGrid:this.options.snapToGrid),e-=Math.abs(s[1])&lt;this.options.snapToGrid/2?s[1]:s[1]-(e&lt;0?-this.options.snapToGrid:this.options.snapToGrid),this.constraintToBox(t,e,i,a)}</span>,t.prototype.constraintToBox=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,a){var s,r,n=<span class="cstat-no" title="statement not covered" >this.options.constraint||{};<span class="cstat-no" title="statement not covered" ></span>return void 0!==a?(s=i,r=a):(s=this.parameters.box.x+(1&amp;i?0:this.parameters.box.width),r=this.parameters.box.y+(2&amp;i?0:this.parameters.box.height)),void 0!==n.minX&amp;&amp;s+t&lt;n.minX&amp;&amp;(t=n.minX-s),void 0!==n.maxX&amp;&amp;s+t&gt;n.maxX&amp;&amp;(t=n.maxX-s),void 0!==n.minY&amp;&amp;r+e&lt;n.minY&amp;&amp;(e=n.minY-r),void 0!==n.maxY&amp;&amp;r+e&gt;n.maxY&amp;&amp;(e=n.maxY-r),[t,e]}</span>,t.prototype.checkAspectRatio=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!this.options.saveAspectRatio)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >t.slice(),</span>a=<span class="cstat-no" title="statement not covered" >this.parameters.box.width/this.parameters.box.height,</span>s=<span class="cstat-no" title="statement not covered" >this.parameters.box.width+t[0],</span>r=<span class="cstat-no" title="statement not covered" >this.parameters.box.height-t[1],</span>n=<span class="cstat-no" title="statement not covered" >s/r;<span class="cstat-no" title="statement not covered" ></span>return n&lt;a?(i[1]=s/a-this.parameters.box.height,e&amp;&amp;(i[1]=-i[1])):n&gt;a&amp;&amp;(i[0]=this.parameters.box.width-r*a,e&amp;&amp;(i[0]=-i[0])),i}</span>,SVG.extend(SVG.Element,{resize:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return(this.remember("_resizeHandler")||new t(this)).init(e||{}),this}</span>}),SVG.Element.prototype.resize.defaults={snapToAngle:.1,snapToGrid:1,constraint:{},saveAspectRatio:!1}}</span>).call(this)}</span>();<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar i=<span class="cstat-no" title="statement not covered" >e.insertAt;<span class="cstat-no" title="statement not covered" ></span>if(t&amp;&amp;"undefined"!=typeof document){var a=<span class="cstat-no" title="statement not covered" >document.head||document.getElementsByTagName("head")[0],</span>s=<span class="cstat-no" title="statement not covered" >document.createElement("style");<span class="cstat-no" title="statement not covered" ></span>s.type="text/css","top"===i&amp;&amp;a.firstChild?a.insertBefore(s,a.firstChild):a.appendChild(s),s.styleSheet?s.styleSheet.cssText=t:s.appendChild(document.createTextNode(t))}</span>}</span>('.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n.apexcharts-canvas.apexcharts-theme-dark {\n  background: #424242;\n}\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-candlestick&gt;div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-canvas.apexcharts-zoomable .hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-canvas.apexcharts-zoomable .hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers&gt;div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers&gt;div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}'),<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.__resizeTriggers__,</span>i=<span class="cstat-no" title="statement not covered" >e.firstElementChild,</span>a=<span class="cstat-no" title="statement not covered" >e.lastElementChild,</span>s=<span class="cstat-no" title="statement not covered" >i?i.firstElementChild:null;<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(a.scrollLeft=a.scrollWidth,a.scrollTop=a.scrollHeight),s&amp;&amp;(s.style.width=i.offsetWidth+1+"px",s.style.height=i.offsetHeight+1+"px"),i&amp;&amp;(i.scrollLeft=i.scrollWidth,i.scrollTop=i.scrollHeight)}</span>function <span class="fstat-no" title="function not covered" >e(</span>e){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t(this),this.__resizeRAF__&amp;&amp;r(this.__resizeRAF__),this.__resizeRAF__=s((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.offsetWidth!=t.__resizeLast__.width||t.offsetHeight!=t.__resizeLast__.height}</span>)(i)&amp;&amp;(i.__resizeLast__.width=i.offsetWidth,i.__resizeLast__.height=i.offsetHeight,i.__resizeListeners__.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.call(e)}</span>)))}</span>))}</span>var i,a,s=(<span class="cstat-no" title="statement not covered" >i=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return window.setTimeout(t,20)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return i(t)}</span>)</span>,r=(<span class="cstat-no" title="statement not covered" >a=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.clearTimeout,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a(t)}</span>)</span>,n=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >"animationstart",</span>l=<span class="cstat-no" title="statement not covered" >"Webkit Moz O ms".split(" "),</span>h=<span class="cstat-no" title="statement not covered" >"webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "),</span>c=<span class="cstat-no" title="statement not covered" >document.createElement("fakeelement");<span class="cstat-no" title="statement not covered" ></span>if(void 0!==c.style.animationName&amp;&amp;(n=!0),!1===n)<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;l.length;d++)<span class="cstat-no" title="statement not covered" >if(void 0!==c.style[l[d]+"AnimationName"]){<span class="cstat-no" title="statement not covered" >o=h[d];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>w</span></span></span>indow.addResizeListener=<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){<span class="cstat-no" title="statement not covered" >i.__resizeTriggers__||("static"==getComputedStyle(i).position&amp;&amp;(i.style.position="relative"),i.__resizeLast__={},i.__resizeListeners__=[],(i.__resizeTriggers__=document.createElement("div")).className="resize-triggers",i.__resizeTriggers__.innerHTML='&lt;div class="expand-trigger"&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="contract-trigger"&gt;&lt;/div&gt;',i.appendChild(i.__resizeTriggers__),t(i),i.addEventListener("scroll",e,!0),o&amp;&amp;i.__resizeTriggers__.addEventListener(o,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"resizeanim"==e.animationName&amp;&amp;t(i)}</span>))),i.__resizeListeners__.push(a)}</span>,window.removeResizeListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;(t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(i),1),t.__resizeListeners__.length||(t.removeEventListener("scroll",e),t.__resizeTriggers__.parentNode&amp;&amp;(t.__resizeTriggers__=!t.removeChild(t.__resizeTriggers__))))}</span>}</span>(),window.Apex={};v</span>ar It=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"initModules",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.ctx.publicMethods=["updateOptions","updateSeries","appendData","appendSeries","toggleSeries","showSeries","hideSeries","setLocale","resetSeries","zoomX","toggleDataPointSelection","dataURI","addXaxisAnnotation","addYaxisAnnotation","addPointAnnotation","clearAnnotations","removeAnnotation","paper","destroy"],this.ctx.eventList=["click","mousedown","mousemove","touchstart","touchmove","mouseup","touchend"],this.ctx.animations=new f(this.ctx),this.ctx.axes=new J(this.ctx),this.ctx.core=new Tt(this.ctx.el,this.ctx),this.ctx.config=new D({}),this.ctx.data=new O(this.ctx),this.ctx.grid=new _(this.ctx),this.ctx.graphics=new p(this.ctx),this.ctx.coreUtils=new m(this.ctx),this.ctx.crosshairs=new Q(this.ctx),this.ctx.events=new Z(this.ctx),this.ctx.exports=new V(this.ctx),this.ctx.localization=new $(this.ctx),this.ctx.options=new S,this.ctx.responsive=new K(this.ctx),this.ctx.series=new M(this.ctx),this.ctx.theme=new tt(this.ctx),this.ctx.formatters=new W(this.ctx),this.ctx.titleSubtitle=new et(this.ctx),this.ctx.legend=new lt(this.ctx),this.ctx.toolbar=new ht(this.ctx),this.ctx.dimensions=new nt(this.ctx),this.ctx.updateHelpers=new zt(this.ctx),this.ctx.zoomPanSelection=new ct(this.ctx),this.ctx.w.globals.tooltip=new bt(this.ctx)}</span>}]),t}</span>(),</span>Mt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >e(this,t),this.ctx=i,this.w=i.w}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"clear",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.ctx.zoomPanSelection&amp;&amp;this.ctx.zoomPanSelection.destroy(),this.ctx.toolbar&amp;&amp;this.ctx.toolbar.destroy(),this.ctx.animations=null,this.ctx.axes=null,this.ctx.annotations=null,this.ctx.core=null,this.ctx.data=null,this.ctx.grid=null,this.ctx.series=null,this.ctx.responsive=null,this.ctx.theme=null,this.ctx.formatters=null,this.ctx.titleSubtitle=null,this.ctx.legend=null,this.ctx.dimensions=null,this.ctx.options=null,this.ctx.crosshairs=null,this.ctx.zoomPanSelection=null,this.ctx.updateHelpers=null,this.ctx.toolbar=null,this.ctx.localization=null,this.ctx.w.globals.tooltip=null,this.clearDomElements()}</span>},{key:"killSVG",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.each((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.removeClass("*"),this.off(),this.stop()}</span>),!0),t.ungroup(),t.clear()}</span>},{key:"clearDomElements",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.ctx.eventList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >document.removeEventListener(e,t.ctx.events.documentEvent)}</span>));v</span>ar e=<span class="cstat-no" title="statement not covered" >this.w.globals.dom;<span class="cstat-no" title="statement not covered" ></span>if(null!==this.ctx.el)<span class="cstat-no" title="statement not covered" >for(;this.ctx.el.firstChild;)<span class="cstat-no" title="statement not covered" >this.ctx.el.removeChild(this.ctx.el.firstChild);<span class="cstat-no" title="statement not covered" >t</span></span></span>his.killSVG(e.Paper),e.Paper.remove(),e.elWrap=null,e.elGraphical=null,e.elAnnotations=null,e.elLegendWrap=null,e.baseEl=null,e.elGridRect=null,e.elGridRectMask=null,e.elGridRectMarkerMask=null,e.elDefs=null}</span>}]),t}</span>();<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>i,a){<span class="cstat-no" title="statement not covered" >e(this,t),this.opts=a,this.ctx=this,this.w=new N(a).init(),this.el=i,this.w.globals.cuid=g.randomId(),this.w.globals.chartID=this.w.config.chart.id?this.w.config.chart.id:this.w.globals.cuid,new It(this).initModules(),this.create=g.bind(this.create,this),this.windowResizeHandler=this._windowResize.bind(this)}<span class="cstat-no" title="statement not covered" ></span>return a(t,[{key:"render",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >if(null!==t.el){<span class="cstat-no" title="statement not covered" >void 0===Apex._chartInstances&amp;&amp;(Apex._chartInstances=[]),t.w.config.chart.id&amp;&amp;Apex._chartInstances.push({id:t.w.globals.chartID,group:t.w.config.chart.group,chart:t}),t.setLocale(t.w.config.chart.defaultLocale);v</span>ar a=<span class="cstat-no" title="statement not covered" >t.w.config.chart.events.beforeMount;<span class="cstat-no" title="statement not covered" ></span>"function"==typeof a&amp;&amp;a(t,t.w),t.events.fireEvent("beforeMount",[t,t.w]),window.addEventListener("resize",t.windowResizeHandler),window.addResizeListener(t.el.parentNode,t._parentResizeCallback.bind(t));v</span>ar s=<span class="cstat-no" title="statement not covered" >t.create(t.w.config.series,{});<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return e(t);<span class="cstat-no" title="statement not covered" >t</span></span>.mount(s).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"function"==typeof t.w.config.chart.events.mounted&amp;&amp;t.w.config.chart.events.mounted(t,t.w),t.events.fireEvent("mounted",[t,t.w]),e(s)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i(t)}</span>))}</span>else <span class="cstat-no" title="statement not covered" >i(new Error("Element not found"))}</span></span>))}</span>},{key:"create",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>new It(this).initModules();v</span>ar a=<span class="cstat-no" title="statement not covered" >this.w.globals;<span class="cstat-no" title="statement not covered" ></span>(a.noData=!1,a.animationEnded=!1,this.responsive.checkResponsiveConfig(e),i.config.xaxis.convertedCatToNumeric)&amp;&amp;new R(i.config).convertCatToNumericXaxis(i.config,this.ctx);<span class="cstat-no" title="statement not covered" >i</span>f(null===this.el)<span class="cstat-no" title="statement not covered" >return a.animationEnded=!0,null;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.core.setupElements(),0===a.svgWidth)<span class="cstat-no" title="statement not covered" >return a.animationEnded=!0,null;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >m.checkComboSeries(t);<span class="cstat-no" title="statement not covered" ></span>a.comboCharts=s.comboCharts,a.comboBarCount=s.comboBarCount;v</span>ar r=<span class="cstat-no" title="statement not covered" >t.every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.data&amp;&amp;0===t.data.length}</span>));<span class="cstat-no" title="statement not covered" ></span>(0===t.length||r)&amp;&amp;this.series.handleNoData(),this.events.setupEventHandlers(),this.data.parseData(t),this.theme.init(),new P(this).setGlobalMarkerSize(),this.formatters.setLabelFormatters(),this.titleSubtitle.draw(),a.noData&amp;&amp;a.collapsedSeries.length!==a.series.length&amp;&amp;!i.config.legend.showForSingleSeries||this.legend.init(),this.series.hasAllSeriesEqualX(),a.axisCharts&amp;&amp;(this.core.coreCalculations(),"category"!==i.config.xaxis.type&amp;&amp;this.formatters.setLabelFormatters()),this.formatters.heatmapLabelFormatters(),this.dimensions.plotCoords();v</span>ar n=<span class="cstat-no" title="statement not covered" >this.core.xySettings();<span class="cstat-no" title="statement not covered" ></span>this.grid.createGridMask();v</span>ar o=<span class="cstat-no" title="statement not covered" >this.core.plotChartType(t,n),</span>l=<span class="cstat-no" title="statement not covered" >new z(this);<span class="cstat-no" title="statement not covered" ></span>l.bringForward(),i.config.dataLabels.background.enabled&amp;&amp;l.dataLabelsBackground(),this.core.shiftGraphPosition();v</span>ar h=<span class="cstat-no" title="statement not covered" >{plot:{left:i.globals.translateX,top:i.globals.translateY,width:i.globals.gridWidth,height:i.globals.gridHeight}};<span class="cstat-no" title="statement not covered" ></span>return{elGraph:o,xyRatios:n,elInner:i.globals.dom.elGraphical,dimensions:h}}</span>},{key:"mount",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:null,</span>i=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >i.w;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(s,r){<span class="cstat-no" title="statement not covered" >if(null===i.el)<span class="cstat-no" title="statement not covered" >return r(new Error("Not enough data to display or target element not found"));<span class="cstat-no" title="statement not covered" >(</span></span>null===e||a.globals.allSeriesCollapsed)&amp;&amp;i.series.handleNoData(),i.axes.drawAxis(a.config.chart.type,e.xyRatios),i.grid=new _(i);v</span>ar n=<span class="cstat-no" title="statement not covered" >i.grid.drawGrid();<span class="cstat-no" title="statement not covered" ></span>i.annotations=new C(i),i.annotations.drawShapeAnnos(),i.annotations.drawImageAnnos(),i.annotations.drawTextAnnos(),"back"===a.config.grid.position&amp;&amp;n&amp;&amp;a.globals.dom.elGraphical.add(n.el);v</span>ar o=<span class="cstat-no" title="statement not covered" >new G(t.ctx),</span>l=<span class="cstat-no" title="statement not covered" >new q(t.ctx);<span class="cstat-no" title="statement not covered" ></span>if(null!==n&amp;&amp;(o.xAxisLabelCorrections(n.xAxisTickWidth),l.setYAxisTextAlignments()),"back"===a.config.annotations.position&amp;&amp;(a.globals.dom.Paper.add(a.globals.dom.elAnnotations),i.annotations.drawAxesAnnotations()),e.elGraph instanceof Array)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;e.elGraph.length;h++)<span class="cstat-no" title="statement not covered" >a.globals.dom.elGraphical.add(e.elGraph[h]);e</span></span>lse <span class="cstat-no" title="statement not covered" >a.globals.dom.elGraphical.add(e.elGraph);<span class="cstat-no" title="statement not covered" >i</span></span>f("front"===a.config.grid.position&amp;&amp;n&amp;&amp;a.globals.dom.elGraphical.add(n.el),"front"===a.config.xaxis.crosshairs.position&amp;&amp;i.crosshairs.drawXCrosshairs(),"front"===a.config.yaxis[0].crosshairs.position&amp;&amp;i.crosshairs.drawYCrosshairs(),"front"===a.config.annotations.position&amp;&amp;(a.globals.dom.Paper.add(a.globals.dom.elAnnotations),i.annotations.drawAxesAnnotations()),!a.globals.noData){<span class="cstat-no" title="statement not covered" >if(a.config.tooltip.enabled&amp;&amp;!a.globals.noData&amp;&amp;i.w.globals.tooltip.drawTooltip(e.xyRatios),a.globals.axisCharts&amp;&amp;(a.globals.isXNumeric||a.config.xaxis.convertedCatToNumeric))<span class="cstat-no" title="statement not covered" >(a.config.chart.zoom.enabled||a.config.chart.selection&amp;&amp;a.config.chart.selection.enabled||a.config.chart.pan&amp;&amp;a.config.chart.pan.enabled)&amp;&amp;i.zoomPanSelection.init({xyRatios:e.xyRatios});e</span>lse{var c=<span class="cstat-no" title="statement not covered" >a.config.chart.toolbar.tools;<span class="cstat-no" title="statement not covered" ></span>["zoom","zoomin","zoomout","selection","pan","reset"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >c[t]=!1}</span>))}<span class="cstat-no" title="statement not covered" ></span>a</span>.config.chart.toolbar.show&amp;&amp;!a.globals.allSeriesCollapsed&amp;&amp;i.toolbar.createToolbar()}<span class="cstat-no" title="statement not covered" ></span>a</span>.globals.memory.methodsToExec.length&gt;0&amp;&amp;a.globals.memory.methodsToExec.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.method(t.params,!1,t.context)}</span>)),a.globals.axisCharts||a.globals.noData||i.core.resizeNonAxisCharts(),s(i)}</span>))}</span>},{key:"destroy",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >window.removeEventListener("resize",this.windowResizeHandler),window.removeResizeListener(this.el.parentNode,this._parentResizeCallback.bind(this));v</span>ar t=<span class="cstat-no" title="statement not covered" >this.w.config.chart.id;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;Apex._chartInstances.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >e.id===t&amp;&amp;Apex._chartInstances.splice(i,1)}</span>)),new Mt(this.ctx).clear()}</span>},{key:"updateOptions",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]&amp;&amp;arguments[1],</span>a=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;2&amp;&amp;void 0!==arguments[2])||arguments[2],</span>s=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;3&amp;&amp;void 0!==arguments[3])||arguments[3],</span>r=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;4&amp;&amp;void 0!==arguments[4])||arguments[4],</span>n=<span class="cstat-no" title="statement not covered" >this.w;<span class="cstat-no" title="statement not covered" ></span>return n.globals.selection=void 0,t.series&amp;&amp;(this.series.resetSeries(!1,!0,!1),t.series.length&amp;&amp;t.series[0].data&amp;&amp;(t.series=t.series.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return e.updateHelpers._extendSeries(t,i)}</span>))),this.updateHelpers.revertDefaultAxisMinMax()),t.xaxis&amp;&amp;(t=this.updateHelpers.forceXAxisUpdate(t)),t.yaxis&amp;&amp;(t=this.updateHelpers.forceYAxisUpdate(t)),n.globals.collapsedSeriesIndices.length&gt;0&amp;&amp;this.series.clearPreviousPaths(),t.theme&amp;&amp;(t=this.theme.updateThemeOptions(t)),this.updateHelpers._updateOptions(t,i,a,s,r)}</span>},{key:"updateSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:[],</span>e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;2&amp;&amp;void 0!==arguments[2])||arguments[2];<span class="cstat-no" title="statement not covered" ></span>return this.series.resetSeries(!1),this.updateHelpers.revertDefaultAxisMinMax(),this.updateHelpers._updateSeries(t,e,i)}</span>},{key:"appendSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;2&amp;&amp;void 0!==arguments[2])||arguments[2],</span>a=<span class="cstat-no" title="statement not covered" >this.w.config.series.slice();<span class="cstat-no" title="statement not covered" ></span>return a.push(t),this.series.resetSeries(!1),this.updateHelpers.revertDefaultAxisMinMax(),this.updateHelpers._updateSeries(a,e,i)}</span>},{key:"appendData",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>i.w.globals.dataChanged=!0,i.series.getPreviousPaths();<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >i.w.config.series.slice(),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s++)<span class="cstat-no" title="statement not covered" >if(null!==t[s]&amp;&amp;void 0!==t[s])<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t[s].data.length;r++)<span class="cstat-no" title="statement not covered" >a[s].data.push(t[s].data[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn i.w.config.series=a,e&amp;&amp;(i.w.globals.initialSeries=JSON.parse(JSON.stringify(i.w.config.series))),this.update()}</span>},{key:"update",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(i,a){<span class="cstat-no" title="statement not covered" >new Mt(e.ctx).clear();v</span>ar s=<span class="cstat-no" title="statement not covered" >e.create(e.w.config.series,t);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return i(e);<span class="cstat-no" title="statement not covered" >e</span></span>.mount(s).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"function"==typeof e.w.config.chart.events.updated&amp;&amp;e.w.config.chart.events.updated(e,e.w),e.events.fireEvent("updated",[e,e.w]),e.w.globals.isDirty=!0,i(e)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a(t)}</span>))}</span>))}</span>},{key:"getSyncedCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.getGroupedCharts(),</span>e=<span class="cstat-no" title="statement not covered" >[this];<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;(e=[],t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.push(t)}</span>))),e}</span>},{key:"getGroupedCharts",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return Apex._chartInstances.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t.group)<span class="cstat-no" title="statement not covered" >return!0}</span></span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.w.config.chart.group===e.group?e.chart:t}</span>))}</span>},{key:"toggleSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.series.toggleSeries(t)}</span>},{key:"showSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.series.showSeries(t)}</span>},{key:"hideSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.series.hideSeries(t)}</span>},{key:"resetSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;0&amp;&amp;void 0!==arguments[0])||arguments[0],</span>e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1];<span class="cstat-no" title="statement not covered" ></span>this.series.resetSeries(t,e)}</span>},{key:"addEventListener",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.events.addEventListener(t,e)}</span>},{key:"removeEventListener",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.events.removeEventListener(t,e)}</span>},{key:"addXaxisAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:void 0,</span>a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(a=i),a.annotations.addXaxisAnnotationExternal(t,e,a)}</span>},{key:"addYaxisAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:void 0,</span>a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(a=i),a.annotations.addYaxisAnnotationExternal(t,e,a)}</span>},{key:"addPointAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >!(arguments.length&gt;1&amp;&amp;void 0!==arguments[1])||arguments[1],</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:void 0,</span>a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(a=i),a.annotations.addPointAnnotationExternal(t,e,a)}</span>},{key:"clearAnnotations",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:void 0,</span>e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e=t),e.annotations.clearAnnotations(e)}</span>},{key:"removeAnnotation",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:void 0,</span>i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(i=e),i.annotations.removeAnnotation(i,t)}</span>},{key:"getChartArea",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")}</span>},{key:"getSeriesTotalXRange",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.coreUtils.getSeriesTotalsXRange(t,e)}</span>},{key:"getHighestValueInSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:0,</span>e=<span class="cstat-no" title="statement not covered" >new U(this.ctx);<span class="cstat-no" title="statement not covered" ></span>return e.getMinYMaxY(t).highestY}</span>},{key:"getLowestValueInSeries",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:0,</span>e=<span class="cstat-no" title="statement not covered" >new U(this.ctx);<span class="cstat-no" title="statement not covered" ></span>return e.getMinYMaxY(t).lowestY}</span>},{key:"getSeriesTotal",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.seriesTotals}</span>},{key:"toggleDataPointSelection",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.updateHelpers.toggleDataPointSelection(t,e)}</span>},{key:"zoomX",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.ctx.toolbar.zoomUpdateOptions(t,e)}</span>},{key:"setLocale",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.localization.setCurrentLocaleValues(t)}</span>},{key:"dataURI",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new V(this.ctx).dataURI()}</span>},{key:"paper",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.w.globals.dom.Paper}</span>},{key:"_parentResizeCallback",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!this.w.globals.noData&amp;&amp;this.w.globals.animationEnded&amp;&amp;this.w.config.chart.redrawOnParentResize&amp;&amp;this._windowResize()}</span>},{key:"_windowResize",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>clearTimeout(this.w.globals.resizeTimer),this.w.globals.resizeTimer=window.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.w.globals.resized=!0,t.w.globals.dataChanged=!1,t.ctx.update()}</span>),150)}</span>}],[{key:"getChartByID",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Apex._chartInstances.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.id===t}</span>))[0];<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;e.chart}</span>},{key:"initOnLoad",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >document.querySelectorAll("[data-apexcharts]"),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++){<span class="cstat-no" title="statement not covered" >new t(e[i],JSON.parse(e[i].getAttribute("data-options"))).render()}</span>}</span>},{key:"exec",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >this.getChartByID(t);<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >i.w.globals.isExecCalled=!0;v</span>ar a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(-1!==i.publicMethods.indexOf(e)){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >arguments.length,</span>r=<span class="cstat-no" title="statement not covered" >new Array(s&gt;2?s-2:0),</span>n=<span class="cstat-no" title="statement not covered" >2;</span>n&lt;s;n++)<span class="cstat-no" title="statement not covered" >r[n-2]=arguments[n];<span class="cstat-no" title="statement not covered" >a</span></span>=i[e].apply(i,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>}</span>},{key:"merge",value:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return g.extend(t,e)}</span>}]),t}</span>()}</span>));
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Mon Jul 06 2020 20:55:33 GMT-0500 (Peru Standard Time)
            </div>
        </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    